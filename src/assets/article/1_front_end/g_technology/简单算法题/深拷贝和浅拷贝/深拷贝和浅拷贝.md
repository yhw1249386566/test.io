# 浅拷贝

## 概念

浅拷贝指的是将某个对象的属性依次进行复制，去传递给另一个对象，如：`let obj = cloneObj`，这样做并不会递归的复制，

而 JS 存储对象时都是存储的对象地址，所以浅拷贝会导致 源对象.xxx 和 拷贝源对象的对象.xxx  这两者的属性指向同一块内存地址，

这也就会使得 源对象 和 拷贝源对象的对象 指向同一个内存地址，则它们就会互相影响对方，**源对象改变某个属性，拷贝源对象的对象对应的属性也会改变，反之亦是如此。**

而深拷贝将是真正的拷贝一个对象，即：源对象和深拷贝源对象的对象不会互相冲突

注：深拷贝就和浅拷贝相反，***详见：深拷贝***

## 示例

```js
    var obj = {
        a: 1,
        arr: [2, 3],
        obj: {
            name: 'yomua',
            hobby: 'girl'
        }
    };
    // 将拷贝源对象到该对象
    var shallowObj = {
        ooo: 'sss'
    }
    shallowObj = shallowCopy(obj,shallowObj);
    function shallowCopy(src, cloneSrcObj) {
        // 若未传入需要将源对象拷贝过去的对象，则我们定义一个对象使用
        var cloneSrcObj = cloneSrcObj || {}
        for (var key in src) {
            if (src.hasOwnProperty(key)) {
                cloneSrcObj[key] = src[key];
            }
        }
        return cloneSrcObj;
    }

/**
    {
        ooo: 'sss',
        a: 1,
        arr: [2, 3],
        obj: {
            name: 'yomua',
            hobby: 'girl'
        }
    }
*/
    console.log(shallowObj);
    obj.a = 2
    console.log(shallowObj.a) // 2
```

# 深拷贝

## 概念

深拷贝和浅拷贝不同，深拷贝不仅会将对象的各个属性逐个复制出去，而且还会将源对象的各个属性所包含的对象也依次采用深复制的方法**递归复制**到新对象

并且深拷贝过后，源对象和拷贝源对象的对象之间不会互相影响。

## 将目标对象属性深拷贝到一个新对象并返回



```js
    let china = {
        nation: '中国',
        birthplaces: ['北京', '上海', '广州'],
        skincolr: 'yellow',
        friends: ['sk', 'ls']
    }

    // 深拷贝，要想达到深复制就需要用递归
    function deepCopy(srcObj, cloneSrcObj) {
        // 使用 var 可能不太好，考虑使用 const，参见： 深拷贝：防止拷贝的属性指向自己导致的堆栈溢出
        var cloneSrcObj = cloneSrcObj || {}
        for (let key in srcObj) {
            // 若 srcObj 的类型为 object
            if (typeof srcObj[key] === 'object') {
                if (srcObj[key].constructor === Array) {
                    //这是数组
                    cloneSrcObj[key] = []
                } else 
                    //这是对象
                    cloneSrcObj[key] = {}
                // 递归调用 deepCopy()
                deepCopy(srcObj[key], cloneSrcObj[key])
            } else {
                cloneSrcObj[key] = srcObj[key]
            }
        }
        return cloneSrcObj
    }
    let result = { name: 'result' }
    result = deepCopy(china, result)
    console.log(result)
    china.nation = '华夏'
    // 仍然是：中国。
    // 深拷贝是真正的拷贝，源对象和拷贝源对象的对象之间不会互相影响
    console.log(result.nation); 
```

- if (typeof srcObj[key] === 'object') {}
  
  若源对象的 key 属性的类型是一个 object
  
  - if (srcObj[key].constructor === Array) {}
    
    精确的说：若源对象的 key 属性的 constructor  是 Array 类型，则：
    
    - cloneSrcObj[key] = []
      
      为拷贝源对象的对象添加一个对应的 key 属性，并且值为 [] （Array 类型)
  
  - else {cloneSrcObj[key] = srcObj[key]}
    
    如果不是，则：
    
    为拷贝源对象的对象添加一个对应的 key 属性，并且值为 {} （Object 类型)

- else {cloneSrcObj[key] = srcObj[key]}
  
  若源对象的 key 属性的类型不是一个 object，则代表已经到达源对象属性的最底层，就把这个源对象最底层的属性和值赋值给 拷贝源对象的对象
  
  这样源对象的最底层的属性和值拷贝完之后，那么导致去拷贝源对象的最底层的属性 的函数就会从栈中出去，执行上一个栈，
  
  这个栈（deepCopy(srcObj[key], cloneSrcObj[key]) 调用形成）就会去将源对象的某个（key）属性的最底层的属性的上一个属性 赋值给 cloneSrcObj （拷贝源对象的对象），
  
  以此类推，这样一层层往上赋值，cloneSrcObj 就会拥有源对象的一切，并且和源对象独立。

## 深拷贝：防止拷贝的属性指向自己导致的堆栈溢出

```ts
const source = {
  birthplaces: ["北京", "上海", "广州"],
  // friends: ["sk", "ls"],
  obj: { name: "yomua" },
};

// repeat 属性指向 source 本身，这在深拷贝时会导致堆栈溢出
// source.repeat = source

// 深拷贝，要想达到深复制就需要用递归
function deepClone(obj, visited = new Set()) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }

  const result = Array.isArray(obj) ? [] : {};

  if (visited.has(obj)) {
    // 可以抛错，或直接 return 都行。
    throw new Error("自指向"); // 对象中有个属性指向了对象本身，这会导致堆栈溢出
  }

  visited.add(obj);

  for (const key in obj) {
    result[key] = deepClone(obj[key], visited);
  }

  visited.delete(obj);

  return result; // 是一个已经完成深拷贝的对象
}

const cloneObj = deepClone(source);

source.obj.name = "yhw";
console.log("__source", source); // name => yhw
console.log("__cloneObj", cloneObj); // name => yomua

```

