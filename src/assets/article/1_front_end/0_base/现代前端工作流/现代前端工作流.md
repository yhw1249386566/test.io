# 工作流 Workflow

通常，对于现在（2023年8月17日）的前端来说，大多数使用 React、Vue、Angular 等框架和配套库（如：webpack）辅助开发，那么在它们背后，它们的工作流是什么？

以及我们使用框架背后进行本地开发的工作流又是什么？

# 简易工作流

## SPA 工作流简化如下

这是一个 SPA 本地开发思想，我们通过 `node` 启动本地服务器，进行前端项目展示和调试，其背后工作流也是类似的。

- 注：我们这里通过 `node` 读取本地 `operator.js` 文件返回给前端。
  在 `webpack` 是将所有打包好的文件*(如：dist)*的[存到内存](https://webpack.docschina.org/guides/development/) 中，然后再根据请求从内存读取并返回给前端，这会让这些打包后的文件就好像真的挂载在硬件服务器的根路径一样。
  这么做的好处是获取内存资源快。

```
app
 - index.html
 - operator.js
 - server.js
```

1. 你在本地写个 `index.html`，
   通过 `operator.js` 绑定相关事件和插入/更新 DOM/跳转路由等操作，让 `index.html` 成为可交互页面，
   再通过 `server.js` 启动一个前端服务，用来处理用户请求。
2. 然后访问 `index.html`，让浏览器加载 server.js，
   在 `server.js` 中，将 `operator.js` 作为响应返回给 `index.html`
3. 这样浏览器拿到 `server.js` 返回的 `operator.js` 后，就会开始将 `oeprator.js` 作为脚本文件解释执行
4. operator.js 中就可以为 `index.html` 进行绑定 DOM 事件，`index.html` 就成为了可交互网页。

```html
<!-- index.html -->
<body>
  <script src="http://localhost:3000/opeartor"></script>
</body>
```

```js
// server.js
const http = require('http')
const fs = require('fs')
const path = require('path')

const server = http.createServer((req, res) => {
    const url = req.url

    if (url === '/opeartor') {
        const filePath = path.join(__dirname, 'operator.js')
        fs.readFile(filePath, (err, data) => {
            if (err) {
                res.writeHead(404, { 'Content-Type': 'text/plain' })
                res.end('File not found')
                return
            }

            res.writeHead(200, { 'Content-Type': 'text/html' })
            res.end(data)
        })
    }
})

const PORT = 3000
server.listen(PORT, () => {
    console.log(`Server is running at http://localhost:${PORT}`)
})

```

```js
// operator.js
console.log("test1")
console.log("window",window) // 将在控制台输出
```

### 将 index.html 放入本地服务器

我们可以将 `index.html` 作为文件数据，通过 `server.js` 读取，并返回给前端，这样，我们就能通过 `http://localhost:8000` 访问到 `index.html`，就像将 `index.html` 放到服务器上面。

这么做就和使用 webpack 启动服务的原理类似。而且这样还能设置 Cookie（`file://` 协议是无法设置 Cookie 的）

## 将文件放到服务器的工作流如下

对于直接将文件放到某个服务器里面，而不是通过本地开发，如果是纯前端的项目，就不需要 `server.js` 文件，所以文件目录为：

```
app
 - index.html
 - operator.js
```

- 硬件服务器：指物理硬件，即：一台可以托管应用程序、数据或服务的计算机。
  比如：自己的计算机、云服务器等。
- 软件服务器（或服务器软件）：服务器除了指硬件服务器之外，还有软件服务器，即：**运行在硬件服务器上的软件**，用于提供服务、应用程序或资源等。
  比如：Naginx, Tomact, Apache 等，
  软件服务器有多种多样的，比如：Web 服务器、数据库服务器、应用服务器等。

工作流是：

1. 将 `index.html` 和 `operator.js` 放到硬件服务器，利用 `Nginx` 或 `Tomcat` 等服务器软件提供资源（js, html, 图片等）给前端。
2. 使用 DNS 解析域名，将域名指向硬件服务器的 ip 地址，在硬件服务器上安装服务器软件（如：Nginx）并进行配置——比如：监听端口号，设置访问的域名等，
   让前端访问域名时，域名转到硬件服务器，然后此硬件服务器上的服务器软件可以进行拦截，处理前端请求。
3. 前端访问域名（如: whyhw.com），然 Nginx 处理请求并返回 `index.html`
4. 浏览器解析 `index.html`，如果解析到 `<script  src='/operator.js'/>`，则继续向 Nginx  发送请求并获取此资源（`https://www.whyhw.com/opeartor.js`）
5. 浏览器开始解释执行 `operator.js`
6. `operator.js` 执行完毕*（如果非异步执行，脚本文件就会先被浏览器执行，再解析 DOM，\<style/> 也是）*，再继续解析 DOM。
   当所有工作完成，浏览器会开始绘制 DOM，最终呈现给用户。
