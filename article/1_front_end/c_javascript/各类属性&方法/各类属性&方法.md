# String

## 关于截取的方法

### slice()和substring()

#### slice()

提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。

**其索引从0计算;**

#### substring()

返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。并返回此截取的字符串,此方法并不会改变原有的字符串.

**其索引从0计算;**

#### slice() & substring()相同点

##### X：正数 & X > Y

##### Y：正数 & Y < Xzz

1. ### [x];
   
   ​    都是截取x参数包括余下的所有字符。

2. ### [x,y); → [起始位置，终结位置);
   
   ​    即都是包括起始位置，但不包括终结位置

3. ### [x,y,z,a,b,..,n];
   
   ​    等于：[x,y);
   
   > ​    由于js是动态语言，所以它可以接受任意个参数（最多不超过255个）,js将按照传递过来的参数的顺序放入函数的形参当中，
   > 
   > ​    超过则被忽略。
   > 
   > ​    而任何遗漏的参数（即接受两个参数的函数只接收到1个传递过来的参数）都会以undefined传递过来。
   > 
   > 详情请了解：
   
   > https://www.w3school.com.cn/js/pro_js_functions_arguments_object.asp

4. 

5. 留白目录

##### X，Y：正数/负数 & X == Y

- (x,x);
  
  ​    ~~被忽略。~~
  
  ​    将输出空字符串，可用if(){} 证实。
  
  ​    即若指定的两个参数相等~~，则程序将忽略此代码。~~

#### slice() & substring()不同点

##### X > Y

1. ### [-x]
   
   ​    slice(); 
   
   ​        会从右→左计算x，索引从0开始，直到x的值，但不包括x本身，且输出时依然是从左→右输出。
   
   ​            `s = '123456’; s.slice(-3); → 456`
   
   ​    substring();
   
   ​        将返回整个字符串，无论 x 是多大。
   
   ​            `s.slice(-1/-2/n); → 123456`

2. ### [-x,y)
   
   ​    slice();
   
   ​        ~~将被程序忽略~~。
   
   ​        将输出空字符串，可用if(){} 证实。
   
   ​    substring();
   
   ​        [0, y);
   
   ​        即[0, 不为负数的参数);
   
   ​        对于sbustring()来说，只要有个参数为负，其结果都是以上规则

3. ### [x,-y);
   
   ​    slice();
   
   ​        [x, 从右→左的y所指定的位置]; 
   
   ​        这里的终结位置包括被指定的位置。索引从0开始
   
   ​    substring();
   
   ​        [0, x);
   
   ​        即[0, 步为负数的参数)。
   
   ​        对于sbustring()来说，只要有个参数为负，其结果都是以上规则

4. ### [-x,-y);
   
   ​    slice();
   
   ​        将会等于: [y,x); 从右→左计算。
   
   > ​        NOTICE: 若 -y <-x ,即y>x，x<y则程序将输出空字符串，可用if(){} 证实。
   
   ​    substring();
   
   ​        将输出空字符串，可用if(){} 证实。。

5. 留白目录

##### X < Y

1. [x, y]
   
   ​    slice();
   
   ​        将输出空字符串，可用if(){} 证实。
   
   ​    substring();
   
   ​        [y, x)

2. 留白目录

### substr()

#### 格式：

substr[指定的搜索位置，需要提取的长度（从搜索位置开始));

#### 描述:

若只有一个参数，则从指定的搜索位置（包括）截取余下的所有字符。

若有两个参数，则从指定的搜索位置起，提取第二个参数指定的长度。

NOTICE：substr()包括指定的搜索位置。这很正常啊~~。。。其它的也是。

##### 代码示例

```js
let s = 'yomua,#I love#you.'

let x = s.substr(2);  // mua,#I love#you.
let c = s.substr(-4);   // you
let a = s.substr(2,5);  // mua,#

let b = s.substr(2,0);  // 空字符串
let d = s.substr(-4,0); // 空字符串
let e = s.substr(4,-1); // 空字符串
let f = s.substr(-4,-1); // 空字符串
```

##### 代码解析

`let x = s.substr(2);`

​    若只指定一个参数，且参数为正数。

​    **[2, 余下所有的字符);** 

`let c = s.substr(-4);`

​    若只指定一个参数，且参数为负数。

​    则从右→左，索引为0开始计算，不包括指定的参数-x。

​    即**(-4);** 从结尾往前开头数第4个，但**不包括第4**个（索引从**0**开始）

`let a = s.substr(2,5);` 

​    若指定两个参数，则第二个参数为：提取的长度是多少。

​    即从第二个索引开始，提取5个字符，从第1个参数指定的位置开始提取，从1开始计算

​    **[2, 第2个索引且从1开始计算往后提取5个参数];**

`第二个参数为0 或 负数`

​    对于substr()来说，第二个参数不能为0和负数，否则无论第一个参数是什么，都返回空字符串。

​    因为这没有任何意义，这代表着：

​        截取0/负数个字符。

​    长度不能为负！为0也没有意义！

## 关于正则表达式的方法

### String.prototype.match()

## String.prototype.split()

### 描述

使用指定的分割符字符串将一个String对象分割成子字符串数组,以指定的分割符来决定每个子字符串数组的拆分位置.

*注意: 如果使用空字符串("")作为分隔符，则字符串不是在每个用户感知的字符(图形素集群)之间，*

*也不是在每个Unicode字符(代码点)之间，而是在每个UTF-16代码单元之间。这会摧毁代理对。*

即在找到分隔符后,将其从整个字符串中删去,并将分割符分割的子字符串以数组形式返回,得到一个包含子字符串的数组.如['xxx','xxx','...']

若未找到分隔符或省略分隔符,则会将整个字符串以数组形式返回['xxxx'].

```js
// ["yomua"]
console.log('yomua'.split()); 
```

若分隔符为空字符串,则将整个字符串转换为字符数组并返回.

```js
// ["y", "o", "m", "u", "a"]
console.log('yomua'.split('')); 
```

若分隔符出现在字符串的开始或结尾,分别以空字符串开头/结尾。

```js
console.log('yomua'.split('y')) // ["", "omua"]
console.log('yomua'.split('a')) // ["omua",""]
```

若分隔符是包含捕获分组(括号)的正则表达式,则每次分隔符匹配时,捕获分组的结果(包括任何未定义的结果)将被拼接到输出数组中.但是,并不是所有浏览器都支持此功能.

**Note:** 当字符串为空时，split()返回一个**包含一个空字符串**的数组，而不是一个空数组，如果**字符串和分隔符都是**空字符串，则返回一个空数组。

### 语法

str.split([separator [, limit] ])

#### 参数解释

##### separator(分隔符)

指定表示每个拆分应发生的点的字符串。

separator 可以是一个字符串或正则表达式。 

如果纯文本分隔符包含多个字符，则必须找到整个字符串来表示分割点。

如果在str中省略或不出现分隔符，则返回的数组包含一个由整个字符串组成的元素。

如果分隔符为空字符串，则将str原字符串中每个字符的数组形式返回。

##### limit(限制)

一个整数，限定返回的分割片段数量。

当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。

如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。

即若此参数为x个,那么数组中包含的字符串索引值从0开始,至多为x-1个(若从1开始计算,就是x个),x超过分割的片段则无视超过部分,不会补上空字符串作为数组索引.

```js
// ["1", "2", "3", "4", "5"]
console.log('1,2,3,4,5,6,7,8'.split(',',5));
// ["1", "2", "3", "4", "5", "6", "7", "8"]
console.log('1,2,3,4,5,6,7,8'.split(',',9));
```

新数组中不返回剩下的文本。也就是得出的返回值为被限制的片段数,剩下的文本则不会被返回.

#### 返回值

返回源字符串以分隔符出现位置分隔而成的一个 Array.

也就是返回一个被分隔符分割过后的数组.

## String.prototype.replace()

更深了解请看:[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace)

### 描述

该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。

在进行全局的搜索替换时，正则表达式需包含 `g` 标志。

### 语法

`str.replace(regex/oldStr, newString/function);`

#### 描述

让一个字符串调用replace()方法,

​    当第一个参数(匹配的模式)是正则表达式时,则会将该字符串被正则表达式匹配到的**所有项**,全部使用newString/function的返回值替换.

​    当第一个参数是一个字符串时,则会让源字符串(调用方法的字符串)中**第一个**和该字符串一样的项被newString/function返回值替换.

#### 参数解析

##### regex/substr

###### regex

一个[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象或者其字面量。该正则所匹配的所有内容会被第二个参数函数的返回值/一个新的字符串替换掉。

###### substr

一个将被newString参数替换的字符串,该字符串会被视为一个整体,而不是一个正则表达式,会让源字符串(调用方法的字符串)中**第一个**和该字符串一样的项被newString/function返回值替换.

##### newString/function

###### newString

用于替换掉第一个参数在原字符串中的匹配部分的[`字符串`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String)。该字符串中可以内插一些特殊的变量名。参考下面的:使用字符串作为参数.

###### function

一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的:指定一个函数作为参数。

### 替换字符串作为第二个参数

替换字符串可以插入下面的特殊变量名：

| 变量名    | 代表的值                                                                                                                                           |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `$$`   | 插入一个 "$"。                                                                                                                                      |
| `$&`   | 插入匹配的子串。                                                                                                                                       |
| `$``   | 插入当前匹配的子串左边的内容。                                                                                                                                |
| `$'`   | 插入当前匹配的子串右边的内容。                                                                                                                                |
| `$*n*` | 假如第一个参数是 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp)对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始 |

### 指定一个函数作为第二个参数

你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 

**(注意：上面提到的特殊替换参数在这里不能被使用。)** 

另外要注意的是，如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。

下面是该函数的参数：

| 变量名               | 代表的值                                                                                                                          |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `match`           | 匹配的子串。（对应于上述的$&。）                                                                                                             |
| `p1,p2, ...`      | 假如replace()方法的第一个参数是一个[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象，则代表第n个括号匹配的字符串。 |
| `offset`          | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 `'abcd'`，匹配到的子字符串是 `'bc'`，那么这个参数将会是 1）                                                         |
| `string`          | 被匹配的原字符串。                                                                                                                     |
| NamedCaptureGroup | 命名捕获组匹配的对象                                                                                                                    |

(精确的参数个数依赖于 `replace()` 的第一个参数是否是一个正则表达式（[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp)）对象，以及这个正则表达式中指定了多少个括号子串，如果这个正则表达式里使用了命名捕获， 还会添加一个命名捕获的对象)

### 示例

#### 使用substr和regex作为第一个参数

```js
let regex = /Yomua/gi
let str = 'Yomua is my baby that Yomua is my favorite.'
console.log(str.replace('Yomua', 'yhw'));
console.log(str.replace(regex, 'yhw'));
/*
yhw is my baby that Yomua is my favorite.
yhw is my baby that yhw is my favorite.
*/
```

- 请注意查看输出的结果,由substr作为第一个参数,只能匹配源字符串的第一次出现substr的内容.
  
  而由regex作为第一个参数,则可以匹配所有源字符串的项,并将之替换

### 使用函数作为第二个参数

```js
let str = 'Yomua is my baby that Yomua is my favorite.'
let modify = () => 'yhw';  
console.log(str.replace('Yomua', modify));
/*
yhw is my baby that Yomua is my favorite.
*/
```

- modify函数的返回值会作为替换字符串,替换源字符串中被regex匹配到的所有项 或 被substr匹配到的第一个项.

### 作用

- 由于replace()方法能使用regex匹配内容,且可以使用函数返回值替换内容,所以它最明显的一个作用就是精准而又灵活的替换一个字符串内容且返回一个新的字符串.
- 可以将使用此方法来让用户输入的字符串中的常见污言秽语替换成乱码.

## String对象

> https://www.w3school.com.cn/jsref/jsref_obj_string.asp

# Number

## 描述

Number方法能帮我们处理数值。但是对于Number 原始值类型来说(3.14,2020),无法拥有属性和方法的,因为他们不是对象.

但是通过JavaScript,方法和属性也可以用于原始值,这是因为JavaScript在执行方法和属性时,将原始值也视为对象(这并不是它们就是对象的,只是视为!)

而且通过JavaScript,对于Number的所有方法来说,它可以用于任何类型的数字.(字面量,变量,表达式,1,1.1,22.2222等)

这是理所当然的,因为对于JavaScript来说,所有数字都可以称之为Number类型.

而且对于Number的方法来说,近乎所有的方法都是存于Prototype原型对象中,即是使用prototype属性创建的指针.

​    例如: Number.prototype.toString(); Number.prototype.toFixed()等.

## toString(radix)

### 描述

以字符串返回数值.

#### radix

即以什么进制返回字符串形式,默认为10进制.

## toExponential(**fractionDigits**)

### 描述

Exponential:指数

以指数表示法返回该数值的字符串表示形式,且是用科学计数法表达出来.

### fractionDigits

可选.一个0~20的整数,用来指定小数点后面有几位数字.默认使用尽可能多的位数来显示.

若超过指定的fractionDigits,则舍去后面的; 若不够现实指定的fractionDigits则用0补齐.

### Example

```js
let numObj = 123.123

numObj.toExponential(); // 1.23123e + 2

numObj.toExponential(2);  // 1.23e + 2

numObj.toExponential(10); // 1.2312300000e + 2
```

## ValueOf()

### 描述

以数值返回数值. 

这句话有点抽象,铺展开来说:将任何数值类型(包括Number对象类型)都转为原始类型number(数值)

该方法通常是由JavaScript引擎在内部隐式调用的,而不是由开发着在代码中显式调用,没有理由在代码中使用它.

### Example

```js
let num = new Number(10);

document.write(n) // 10

document.write(typeof n ) // object

document.write(typeof n.valueOf()) // number
```

# 对象

## for...in

### 描述

以任意顺序遍历一个对象的可枚举的属性,除了Symbol以外.

​    *Symbol:(详情看<基本类型(原始类型).md>)*

for...in不应该用于迭代一个数值.它只是用来迭代对象,且迭代时最好不要对对象上进行添加,修改或删除属性的操作,除非是对当前正在被访问的属性.

详情请看 \<Javascript>文档.

### 语法

for(variable in object) { 

​    statement

}

variable: let,var 等

object: 非Symboll类型的可枚举属性被迭代的对象(名).

当然,我们可以先声明变量,不一定要在()中声明

```js
let variable = v;
for(v in objName);
```

### Example

```js
    let obj = 
    {
        name:'Yomua',
        hobby:'Girl',
        like:'why'
    }
    for(let propertyVariable in obj) {
document.write(`obj.${propertyVariable}=${obj[propertyVariable]}</br>`)
    }

/* 
    最后输出 
    obj.name=Yomua
    obj.hobby=Girl
    obj.like=why
*/
```

#### 说明

以上的代码很明显.

- propertyVariable: 即代表的是当前对象的当前属性
- obj: 遍历的对象名.

或者说: 上面的for...in代码,在被调用时,传入一个对象作为参数,并传入对象的所有可枚举属性, 进行遍历. 

每一次的遍历都是根据propertyVariable 来进行遍历的.

## for...of

***<详情请看,for...of.md>***

前面我们讲到了for ... in 的概念,现在我们来讲一个和它类似又有所区别的for...of的概念.

注意:for...of并不是只用来遍历对象的,请往下看:

### 描述

for...of语句是在ES6中提出来的为所有具有Iterator接口的数据结构,提供了一种统一的访问(迭代)机制 ,

而ES6又规定:默认的Iterator接口部署在Symbol.Iterator属性上,所以一个数据结构只要存在Symbol.Iterator属性,那么此数据结构默认就是可遍历的.

- 数据结构,即数据的构成方法,或者说组合数据的方式.例如对象,数组,字符串等它们都属数据结构.

for...of语句在[可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)上创建一个迭代循环,调用自定义钩子,并为每个不同属性的值执行语句.

​    可迭代对象,如:Array,Map,Set,String,arguments,TypedArray对象等等.

所以，由于字面量对象（纯对象，如：let obj ={...}）不存在 Iterator 接口，所以无法使用 for...of 进行迭代，但是 for...in 则可以迭代对象。

## 访问对象的属性和值

```js
    let obj = 
    {
        name:'Yomua',
        hobby:'Girl',
        like:'why'
    }
    document.write(obj['name']); // Yomua
    document.write(obj['hobby']); // Girl
```

### NOTICE

请把对象的访问和数组的访问区分开来.

对象访问:是使用名称(属性)来访问对象的值.

数组访问:是使用下标索引来访问数组的值.

#### NOTICE

对象声明时就和数组声明差不多,从表面看只是符号的和属性声明的区别,请看:

##### 对象声明

```js
let obj =
{
    name:'Yomua'.
    hobby:'Girl',
    ....
}
```

##### 数组声明

```js
let arr = 
[
    'Yomua',
    'Girl',
    ....
]
```

还需要注意的一点就是,在对象声明/数组声明时请不要在最后面加上逗号(,),这有可能存在跨浏览器兼容的问题.

## delete

### 描述

它是一个操作符,用于删除某个对象的某个属性,如果没有指向这个属性的引用,那它最终会被释放.(即它没删除任何属性,那么它就如同不存在,被释放了)

### 格式

delete expression

#### expression

##### 描述

其计算结果应该是某个属性的引用,例如:

```js
delete object.property
delete object['property']
```

### Example

```js
    let obj =
    {
        name: 'yomua',
        like: 'why',
        hobby: 'love you'
    }
    for(let property in obj) {
        console.log(obj[property])
    }
/*
    yomua
    why
    love you
*

    /* 以下两种方式都能删除obj对象的属性hobby */
    delete obj['hobby']
    // delete obj.hobby;

    for(let property in obj) {
        console.log(obj[property])
    }; 
/*
    yomua
    why
*
```

1. 需要注意的是,由于在JavaScript中数组也是对象的原因,这个delete操作符也能删除数组元素,但是:
   
   ​    被删除的数组元素,会留下未定义的空洞,即:
   
   ```js
   let arr = ['yhw','yomua']; 
   delete arr[0]; // ,yomua
   ```
   
   - 请注意输出的那个逗号[,], 这就是空洞,所以删除数组元素请使用pop()或者shift()等其他方法.

## ~~对象排序[错误]!!!~~

### ~~sort([compareFunction])~~

- ​    ~~详情请看数组 - 数组排序 - sort([compareFunction])~~

- ​    ~~此方法也能对数组进行排序,这是一句废话.~~
  
  ​    ~~因为数组也时对象,能对数组进行排序,当然也能对对象排序~~

- ​    ~~只不过如果未有参数的情况下好像是0作用..~~

**<u>sort()方法无法对对象进行排序,只能对特殊的对象,数组进行排序!!!</u>**

# 数组

## length

### 描述

请注意是length,不是length(), 它是一个属性,而不是一个方法!在调用时没有小括号()!

1. 用来返回数组的长度,索引从1开始计算,而不是0.
   
   ```js
   let arr = 
   [
       '0',
       '1'
   ]
   arr.length; 
   ```
   
   ​    将输出2,而不是1

## 遍历/迭代数组

### 描述

1. 使用for循环遍历数组是最好的选择. 或者forEach(),map()

详情了解:https://www.w3school.com.cn/js/js_array_iteration.asp

### forEach(callback [,thisArg])

#### 描述

1. 用来遍历数组.
2. 没有办法终止或跳出forEach()循环,除非抛出一个异常. 如果你需要终止/跳出循环,则不应该使用forEach()方法,这样是错误的
3. 详情了解<JavaScript参考文档>

#### 格式

arrName.forEach(callback [,    thisArg]);

##### 描述

1. callback : 回调函数,为数组中每个元素执行一段代码的函数,该函数接受3个参数
   
   - currentValue
     
     ​    数组中正处理的当前元素.
   
   - index可选
     
     ​    数组中正处理的当前元素的索引.
   
   - array可选
     
     ​    forEach()方法正在操作的数组.
   
   它将会依次传入此三个参数,即
   
   - 数组当前项的值
   - 数组当前项的索引
   - 数组对象本身
   
   > 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。
   > 
   > 如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象。callback 函数最终可观察到 this 值，这取决于函数观察到 this 的常用规则。

2. [,    thisArg] : 表示可选项
   
   - 当执行回调函数时 用作this的值(参考/引用对象)
   - 通常用不到.

3. 注意:callback函数是可以独立出来的,不用一定直接写到forEach()小括号里面.
   
   ```js
   arrName.forEach(callback);
   function callback(...) {
       ...
   }
   ```

#### 返回值

**undefined**

`forEach()` 为每个数组元素执行`callback`函数；不像 [`map()`](2b1e8cd99a0f2d5e7530ee3cbb98ffdc.html) 或者 [`reduce()`](67ea78251e08b45e193eabc412f6a508.html)，forEach() 总是返回 [`undefined`](db35d98c3293670a2e3d56d18027152b.html) 值，并且不可链式调用。典型用例是在一个链的最后执行副作用。

#### Example

```js
    let array1 = ['a', 'b', 'c'];

    array1.forEach(
        function (element,index,arrObject) {
            console.log(element)
            console.log(index)
            console.log(arrObject)
        },
        this // 可选
    );
/*

    a
    0
    a,b,c

    b
    1
    a,b,c

    c
    2
    a,b,c

*/
```

##### 描述

以上的回调函数function (element,index,arrObject) {...}可以写成: 

```js
    array1.forEach( 
        (element,index,arrObject) => 
            document.write(element + '</br>',index+     '</br>',arrObject+ '</br>'),
        this
    );

    // 写成以下形式皆可
    array1.forEach( 
        (element,index,arrObject) => 
            console.log(element,index,arrObject),
        this
    );

/* 
    a
    0
    a,b,c

    b
    1
    a,b,c

    c
    2
    a,b,c

*/
```

1. 不论是使用匿名函数还是使用箭头函数,它们都代表为当前的数组元素执行一段函数代码.

### map(callback[,thisArg])

#### 描述

调用此方法会创建一个新的数组,其结果(数组的元素)为: 

​    自动调用此方法的数组中的每个元素,然后这些元素都调用了其参数(提供的函数)后 所返回的结果.

简单来说: **旧数组的所有元素都调用参数(即方法)且执行完后,其返回的结果变成新数组中的元素.**

和forEach()方法有着相似的地方,不同的是它是返回的结果组成新的数组,而forEach()没有返回值的,它根据回调函数来做出其判断.

<u>需要注意的是:</u>

1. map()方法通过对每个数组的元素执行函数(参数)来创建新数组.

2. map()方法不会对没有值的数组元素执行函数

3. map()方法不会更改原始数组

4. ​    map()方法处理数组元素的范围是在callback方法(参数)第一次调用时就已经确定. 
   
   ​    即调用map()方法之后追加的数组元素不会被callback方法访问.
   
   ​    如果存在的数组元素改变了，那么传给callback的值是map访问该元素时的值。
   
   ​    在map函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。

5. 若当你不想使用所返回的新数组时,不应该使用map()方法,因为它违背设计初衷.你可以使用forEach() 或 for...of代替

#### 格式

let newArray = arrName.map(callback [,thisArg]);

##### 描述

这里使用let newArrray声明的原因很简单, map()是会将返回的结果组成一个新数组的,所以需要将它赋值给另一个数组变量,否则我们怎么操控新数组?

##### 参数

###### callback 必选

细心的人可能看出来了,它的参数和forEach(callback [,thisArg]); 方法差不多或者说是一样的.

callback里面也接受3个参数,但是必须接受其中一个.

1. currentElement必选
   
   调用callback函数的数组中正在处理的当前元素。

2. index可选
   
   调用callback函数的数组中正在处理的当前元素的索引。

3. array可循啊
   
   map 方法调用的数组。

<u>注意</u>,callback函数(参数)是可以独立出来的,和forEach()一样

```js
    let arr = [45, 4, 9, 16, 25];
    function callback(element) {
        return Math.sqrt; // 返回平方根
    }
    console.log(arr.map(callback()))
    // 
```

###### thisArg 可选

执行 callback 函数时值被用作this。

这个...蒽...我也不知道啥意思,反正这个不经常用,先不管他.

#### 返回值

回调函数的返回值(结果)组成新数组中的每一个元素.

这和forEach()不同,它没有返回值.

#### Example

##### 求数组中每个元素的平方根

```js
     /* 最简单的例子. */
    let arr = [45, 4, 9, 16, 25];
     console.log(arr.map(Math.sqrt)); // Math.sqrt:平方根
     // [6.708203932499369, 2, 3, 4, 5]
```

map()方法不仅能改变数组中的元素然后转为新数组,而且还能对数组中的对象有所操作,在sort()中也有类似的操作.

##### 重新格式化数组中的对象

```js
    var kvArray = [
        { key: 1, value: 10 },
        { key: 2, value: 20 },
        { key: 3, value: 30 }
    ];

    var reformattedArray = kvArray.map(
        // 匿名函数
        function (obj) {
            var rObj = {};

            rObj[obj.key] = obj.value;
            return rObj;
    });

    console.log(reformattedArray);
    console.log(kvArray);
/*
    其输出结果为:
    新数组:
    [{…}, {…}, {…}]
    // 数组中的元素,即对象
        0: {1: 10} 
        1: {2: 20}
        2: {3: 30}

    旧数组:
     [{…}, {…}, {…}]
0: {key: 1, value: 10}
1: {key: 2, value: 20}
2: {key: 3, value: 30}    

*/
```

###### 代码解析

- rObj[obj.key] = obj.value;
  
  ​    对于对象来说,obj[命名索引] = xxx; 这个就会变成对象中的 属性:值,即命名索引: xxx
  
  ​    其实这也是理所当然的,不妨想想,=号是不是代表右边为值,左边是需要被赋值的变量. 那么let x = y ; 是不是就是将y赋值给x, 写成对象的形式就是为: { x:y}; 即x的值为y
  
  ​    [obj.key]就是对象中的属性key的值
  
  ​    ojb.value就是对象中的value属性的值.
  
  ​    最后输出的是 → 1:10 ,等号变成: 冒号.

###### 描述

所以着就是格式了化了数组中的对象,不过原数组依然不变.

## toString()

### 描述

近乎所有对象都拥有此方法.

对于数组来说,它是把数组转为数组值,用逗号分割的字符串.

```js
let fruits = ["Banana", "Orange", "Apple", "Mango"];
console.log(fruits.toString());
// 将输出  Banana,Orange,Apple,Mango
```

## join([separator])

### 描述

join();是一个数组/类数组对象的方法，它将数组中所有的元素拼接成一个字符串，并返回这个字符串。

[separator]：为可选参数，意为返回字符串后，以什么方式分割其本来的字符串

1. 若只返回了一个字符串，则不适用分隔符；
2. 若有多个字符串，()代表逗号分割；('')：不使用任何分隔符
3. 若想自己添加分割符，则使用双引号/单引号括住，并添加想要分割的分隔符：”,” 、 ‘ +’ 等。

## pop() & push

### pop

#### 描述

其英文为:popping, 这个意思是弹出.

即删除数组最后一个元素.

其返回值为被删除的元素.

也就是说,若某个数组调用此方法,将会删除最后一个元素,同时返回被删除的元素.

#### Example

```js
    let arr = 
    [
        'yomua',
        'why',
        'love you'
    ]
    document.write(arr); // yomua,why,love you
    document.write('</br>');
    document.write(arr.pop()); // love you
    document.write('</br>');
    document.write(arr); // yomua,why
```

1. 很明显的可以看到第9行,此pop()方法返回值为被删除的元素.

### push

#### 描述

其英文为:pushing, 这个意思是推入.

即在数组的末尾处添加一个新元素,让此元素变成该数组的最后一个元素.

其返回值为新数组的长度,可以另类的用它来判断数组的长度..(只需要不添加任何参数,直接调用即可)

#### Example

```js
    let arr = 
    [
        'yomua',
        'why',
        'love you'
    ]
    document.write(arr.push('yhw')); // 4
    document.write('</br>');
    document.write(arr); // yomua,why,love you
```

1. 显而易见,第7行返回了新数组的长度,若为以下写法,则可以判断
   
   "当前"数组的长度.
   
   `document.write(arr.push());` // 3

## shift() & unshift()

### shift()

#### 描述

其英文意思为:位移,转移. 

即移除数组的首位元素.

其返回值为被位移出去的元素.

#### Example

```js
    let arr = 
    [
        'yomua',
        'why',
        'love you'
    ]
    document.write(arr); // yomua,why,love you
    document.write('</br>');
    document.write(arr.shift()); // yomua
    document.write('</br>');
    document.write(arr); // why,love you
```

1. 很明显,第9行返回的是被位移出去的元素.

### unshift()

#### 描述

其英文意思:反向位移/不位移

即向数组开头添加元素,将添加的元素变为索引为0的元素.

其返回值为新数组的长度,与push()一样,能测试"当前"数组的长度.

#### Example

```js
    let arr = 
    [
        'yomua',
        'why',
        'love you'
    ]
    document.write(arr); // yomua,why,love you
    document.write('</br>');
    document.write(arr.unshift('yhw')); // 4
    document.write('</br>');
    document.write(arr); // yhw,yomua,why,love you
```

1. 此方法与push()类似,都是添加元素,返回新数组长度.类似的还有pop()和shift()

## pop()&push() & shift()&unshift()的相同与区别.

### 相同

#### pop() & shift()

1. 它们二者很类似

2. pop和shift都是删除元素
   
   pop:删除末尾元素
   
   shift:删除首位元素

3. 其返回值都为被删除的元素

### 区别

#### push()&unshift();

1. 它们二者很类似.

2. push和unshift都是添加元素
   
   push:向末尾添加元素
   
   unshift:向首位添加元素

3. 其返回值都为新数组的长度

## splice()

### 描述

方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。

此方法会改变原数组。 而不是创建一个新数组.

**其返回的值为被删除的元素**

### 格式

arrName.splice(start [,deleteCount] [,addItem1,addItem2,..,addItemn])

#### start必选

##### 描述

从哪里开始(从0开始计算).

​    若此参数超过了数组的长度,则默认从数组末尾开始.

​        删除则删除最后一个,添加则将添加的元素变成最后一个元素.

##### 参数为负数

​    若此参数指定的值为负数,则倒过来算,即从右→左计算(从-1计数).

即倒数第几个元素 → 

- -1:倒数第1个元素,
- -2:倒数第2个元素,
- -n倒数第n个元素

若-n的绝对值>数组的长度(arr.length),则将会默认从0(首位)开始

​    很容易理解,即超过就取极值,不管你超过多少,我只有这么多,超过的部分直接舍去

```js
        let arr = ['yomua','why','love you']
        console.log(arr.splice(-4,1)); // yomua
        console.log(arr) // why,love you
```

#### deleteCount可选

##### 描述

此参数为整数,表示要移除的元素的个数是几个.

- 通常来说,删除的个数不会删除start参数指定的那个元素.
  
  ```js
          let arr = ['yomua','why','love you']
          arr.splice(2,1); // love you 
  ```
  
  1. 即love you元素被删除.

- ​    注意:在JavaScript文档中,说到:如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。
  
  ​    ...蒽,其实不管有没有大于,它都会删除第start位置.
  
  ```js
  let arr = ['yomua','why','love you'];
  arr.splice(1,3); // yomua
  arr.splice(1,1) // yomua ,love you
  ```
  
  ​    ~~经过实践表明,这是错误的,不会删除第start位,而是只会删除start位后面的所有元素.~~

#### addItem1,addItem2,..,addItemn可选

##### 描述

从start位置开始添加元素,可以多选,其用逗号分隔.

​    即,将当前添加的元素变为第start个,若添加多个元素,则依次往后添加.

若没有指定此参数,则splice()方法,将只会删除元素.

1. 添加元素会从第start个索引开始添加,若添加多个元素,则依次往后添加.

#### NOTICE

1. ~~这里所说的从start位置开始,是不包含其start的.~~
   
   ~~即 (start,deleteCount];~~

2. ~~添加元素亦是如此,是从start位置之后的那个元素a开始添加,会挤掉那个元素a,而a元素的索引将会往后移位.~~

3. 这里的选择标准为:
   
   [start,deleteCount]

4. 添加元素会从第start个索引开始添加,若添加多个元素,则依次往后添加.
   
   ```js
     let arr = ['yomua','why','love you']
     arr.splice(2,0,"rh",'yhw','love'); 
       // yomua,why,rh,yhw,love,love you
   ```

## concat()

### 描述

**<u>其英文:concatenate ,意思为: 级联.</u>**

1. 合并1个或多个数组,以新数组的形式返回,
2. 或将数组与1个数组值或多个数组值合并.
3. 此方法不会更改现有数组,它总是返回一个新数组.

### 语法

arrName1.concat(arrName2 [,arrName3,..,arrNamen]);

arrName1.concat(['...' , '...' , '...'] , 【['...' , '...' , '...'] ,['...' , '...' , '...'] 】);

1. 如你所见, 值和数组都能作为参数
2. 值需是数组值, 用[]中括号将之括起来.
3. 在合并并返回一个新数组时,调用此方法的数组将排在前面,而小括号中的参数的值/数组依次排在后面进行合并 并 返回.

## slice()

### 描述

和字符串中的slice有些类似,只不过其返回值变了.

slice() 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括`end`），且原始数组不会被改变。

`slice` **实际上截取的是: 在执行它时，它的上下文中的 `this`**

- `[1,2,3].slice(0,3);` 执行 slice() 时，此函数中的 this 相当于 [1,2,3]。 换句话来说就是：Array.prototype.slice() 方法截取 this
  
  所以根据此函数的特性，我们可以用此函数将一个[类数组对象](https://juejin.cn/post/6844903711022514184)([mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays))转为一个真正的数组：`Array.prototype.slice.call(任意一个类数组对象)` 
  
  ```js
  (function func(a, b, c) {
    // 将 arguments 转为类数组对象
      const array = Array.prototype.slice.call(arguments)
  })(1, 2, 3)
  ```

- 原理：为什么 `slice.call(类数组对象)` 可以将类数组对象转为数组呢？首先 slice() 返回一个数组实例，且若不存在 [start, begin) 则默认截取所有值，所以截取 this(类数组对象) 后的所有值将会一一放入此数组实例中，从而让类数组对象转成数组；
  
  所以将 `slice.call(this)` 换成 `slice.apply(this)` 也是一样的。

`slice` 不会修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：

- 如果该元素是个对象引用 （不是实际的对象），`slice` 会拷贝这个对象引用到新的数组里。
  
  两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。

- 对于字符串、数字及布尔值来说（不是 [`String`](09f4a07c17343b9bed7cee730b468dc5.html)、[`Number`](9bc7c92b76d1a3c2c0729701b7eb45d0.html) 或者 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean) 对象），`slice` 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。

如果向两个数组任一中添加了新元素，则另一个不会受到影响。

### 格式

arrName.slice(start [,end])

其选择的标准为: [start, end);

### slice.apply/call()

使用 Array.prototype.slice.apply() 或  [].slice.apply() 可以将一个类数组对象转为数组，如：将一个 argumes 转为数组：

```js
function t(a, b, c) {
  return [].slice.call(arguments); // PS:箭头函数没有 arguments
}
console.log(t(1, 2, 3)); // [1,2,3]
```

还有一些类似这样利用 apply() 或 call() 的，这里不予多家说明。

## 数组排序

详情请看:https://www.w3school.com.cn/js/js_array_sort.asp

或者看\<JavaScript>帮助文档

### sort([compareFunction])p

#### 描述

**<u>sort()方法只能对特殊的对象:数组,进行排序,而无法对单纯的对象进行排序!</u>**

sort()方法用原地算法对数组进行排序,并返回数组.

其默认情况下的排序为: **先将元素转为字符串**

**(~~无论是否有参数~~若有参数则按照返回值进行判断,而且是根据数组本身的元素类型进行使用)**,

然后根据UTF-16代码单元值进行构建. 

注意:由于它取决于具体实现,因为无法保证排序的时间和空间复杂性.

> ​    **原地算法**:在CS中,基本上不需要额外辅助的数据结构来转换数据的算法,但是允许少量额外的辅助变量来转换数据.
> 
> ​    当算法运行时,输入的数据通常会被要输出的数据覆盖掉. 而不是原地算法的有时会称之为非原地(not-in-place)或不得其所(out-of-place). 
> 
> ​    通常使用原地算法的有:sort();
> 
> ​    详情请看:维基百科-原地算法.   

#### 语法

arrName.sort([compareFunction])

##### compareFunction 可选

###### 若未省略

则用来指定按照某种顺序排序的函数.可以有许多种类型:

​    例如:以随机顺序进行排序,升/降序排序后查找最大值/最小值等.反正这个参数是一个函数,即方法. 你可以脑洞大开按照各种顺序进行排序.

即调用sort()方法的数组,会调用该函数的返回值来进行排序,~~但是仍然会将函数转为字符串再进行排序,~~不会将元素转为字符串.而是根据数组本身的元素类型进行使用

即~~用元素的字符串进行返回值~~用函数的返回值来判断然后排序.

1. compareFunction(a,b) < 0,则a排序在b前面.

2. compareFunction(a,b) > 0,则a排序在b后面.

3. compareFunction(a,b) = 0,则a和b的相对位置不变.
   
   ​    注意:ES标准并不保证这一行为,而且也不是所有浏览器都会遵守这 一相对不变.(基于内核为Mozilla的， 在 2003 年之前的版本)

###### 若省略

元素则按照(先将元素转为字符串)转换为字符串的各个元素的Unicode位点进行排序.

1. ​    例如'Cherry' 和 'Band', Band会被排序到Cherry前面.

2. ​    80和9, 通常人们的思维会认为9会排在80前面.
   
   ​    但是由于sort()方法在进行排序时,会首先将元素转为字符串,然后再排序的原因, 导致变成了字符串比较,
   
   ​    所以80和9进行比较时, 通常是第1字符进行比较,即8和9比较, 所以8的Unicode位点比9的小,排在前面.

###### 最基本的比较函数为:

```js
/* 未省略参数将不会把数组元素转为字符串,而是根据数组本身的元素类型进行使用 */
function compare(a, b) {
  // a排序在b的前面
  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b
    return -1;
  }
  // a排序在b的后面
  if (a > b ) {
    return 1;
  }
  // a和b按照相对位置进行排序
  return 0;
}
```

a

第一个用于比较的元素

b 

第二个用于比较的元素. 

##### 返回值

其返回值为排序后的数组. 注意: 数组已原地排序,并且不进行复制!

#### Example

##### 省略compareFunction函数

```js
const arr = [80,9];
arr.sort();
console.log(arr); // [80,9]
```

- 很明显的,当sort()方法在进行排序时,会将元素转为字符串然后再排序.

##### 未省略compareFunction函数

```js
const arr = [80,9];
arr.sort(function compareFunction(a,b) {
  if (a < b ) {           
    return -1;
  }
  if (a > b ) {
    return 1;
  }
  return 0;
});
console.log(arr); // [9,80]
/* 以上写法可以写成以下形式 */
```

- ​    很明显,未省略compareFunction参数的sort()方法,将会根据数组元素的类型来进行使用. 
  
  ​    所以这里判断 80和9的关系时,是用number类型来判断的,即80>9,所以执行第二个判断,a>b,return 1; 所以输出[9,80];

```js
/* 
    在进行书写sort()方法的compareFunction函数参数时
是可以使用箭头函数的
*/
const arr = [80,9];
arr.sort((a,b) => return a-b); // [9,80]
```

- #### 数组中包含对象可以让此对象按照某个属性排序

##### 描述

即当某个对象存在于数组中: [ {}]时,可以让此对象按照它的某个属性进行排序

##### Example

```js
    var items = [
        { name: 'Edward', value: 21 },
        { name: 'Sharpe', value: 37 },
        { name: 'And', value: 45 },
        { name: 'The', value: -12 },
        { name: 'Magnetic' },
        { name: 'Zeros', value: 37 }
    ];

    // 通过name属性进行排序
    items.sort(function (a, b) {
        // 将a元素中的name属性的值全部转为大写形式.
        var nameA = a.name.toUpperCase(); 
        var nameB = b.name.toUpperCase(); 
        if (nameA < nameB) {
            return -1;
        }
        if (nameA > nameB) {
            return 1;
        }
        /* 
            若name属性的值相等,则按照相对位置排序.
            即元素中是什么样的排序,就排序成什么样.
            这是理想情况,但是一般会根据实现而决定.
        */
        return 0;
    });
    console.log(items) 

    // 通过value属性进行排序
    items.sort(function (a, b) {
        return (a.value - b.value)
    });
    console.log(items)
```

1. 按照name属性的值进行排序会输出
   
   ```js
   /* 
       0: {name: "And", value: 45}
       1: {name: "Edward", value: 21}
       2: {name: "Magnetic"}
       3: {name: "Sharpe", value: 37}
       4: {name: "The", value: -12}
       5: {name: "Zeros", value: 37}
       length: 6
       __proto__: Array(0)
   */
   ```

2. 按照value属性的值进行排序会输出
   
   ```js
   /*
       0: {name: "The", value: -12}
       1: {name: "Edward", value: 21}
       2: {name: "Sharpe", value: 37}
       3: {name: "And", value: 45}
       4: {name: "Magnetic"}
       5: {name: "Zeros", value: 37}
       length: 6
       __proto__: Array(0)
   */
   ```

#### NOTICE

有个很有意思的情况,上面的那段很长的代码, 在直接执行时,它们两个的console.log(items);运行出的答案是一样的

​    **即都是按照value属性的值来排序.**

但是若使用断点(debug)的方法来一步步运行,则它们会输出不一样的答案.

​    **即一个按照name属性的值,一个按照value属性的值进行判断然后排序.**

初步怀疑,这是因为执行的顺序有关,即如果将按照name属性的值排序的那段函数代码放在最后面(按照value属性的值进行排序的函数代码块), 亲测:

​    会得出两个答案都会以name属性的值进行排序,而不会以value属性值排序.

但是这无法解释为什么当我用断点方式一步步执行代码时,它将会输出正确的答案...

### reverse()

#### 描述

其功能如字面意思:相反

反转数组中的元素,即将数组中的元素倒过来.

此方法会改变原数组. 

即第一个变成最后一个元素,最后一个元素变成第一个元素.

```js
const a = [1, 2, 3];

console.log(a); // [1, 2, 3]

a.reverse(); 

console.log(a); // [3, 2, 1]
```

## 数组中方法/属性的知识点

### 属性

1. length是属性,不是方法,调用时不需要();

### 方法

#### 方法中需要函数的

##### 需要回调函数的

1. forEach( callback [,thisArg] )
2. map( callback [,thisArg] )

##### 需要函数的

1. sort( compareFunction )

## filter()

### 描述

顾名思义,它是一个过滤/审查方法,它创建一个新数组, 其包含通过所提供的函数测试的所有元素。 

`filter` 为数组中的每个元素调用一次 `callback` 函数，并利用所有使得 `callback` 函数的返回值 true 或[等价于 true 的值](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)的元素创建一个新数组。

`callback` 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。

那些没有通过 `callback` 测试的元素会被跳过，不会被包含在新数组中。

----

所以filter函数并不会改变原有数组,它返回的是一个新数组,`filter` 遍历的元素范围在第一次调用 `callback` 之前就已经确定了。

在调用 `filter` 之后被添加到数组中的元素不会被 `filter` 遍历到。

如果已经存在的元素被改变了，则他们传入 `callback` 的值是 `filter` 遍历到它们那一刻的值。

被删除或从来未被赋值的元素不会被遍历到。

### 语法

`var newArray =` 

​    `arr.filter(callback(element[, index[, array]])[, thisArg])`

#### 参数解析

##### callback

用来测试数组的每个元素的函数,其返回值为一个布尔值.

返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：

1. element 必选
   数组中当前正在处理的元素。

2. index可选
   
   正在处理的元素在数组中的索引。

3. array可选
   
   调用了 filter 的数组本身。

##### thisArg

执行 `callback` 时， 该函数内部的`this`的指向 。

#### 返回值

一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

### 示例

#### 筛选排除所有较小的值

下例使用 `filter` 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。

```js
function isBigEnough(element) {
  return element >= 10;
}
var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered is [12, 130, 44] 
```

#### 过滤 JSON 中的无效条目

以下示例使用 `filter()` 创建具有非零 `id` 的元素的 json。

```js
var arr = [
  { id: 15 },
  { id: -1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  { },
  { id: null },
  { id: NaN },
  { id: 'undefined' }
];

var invalidEntries = 0;

function isNumber(obj) {
  return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
}

function filterByID(item) {
  if (isNumber(item.id) && item.id !== 0) {
    return true;
  } 
  invalidEntries++;
  return false; 
}

var arrByID = arr.filter(filterByID);

console.log('Filtered Array\n', arrByID); 
// Filtered Array
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log('Number of Invalid Entries = ', invalidEntries); 
// Number of Invalid Entries = 5
```

#### 在数组中搜索

下例使用 `filter()` 根据搜索条件来过滤数组内容。

```
var fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];

/**
 * Array filters items based on search criteria (query)
 */
function filterItems(query) {
  return fruits.filter(function(el) {
      return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
  })
}

console.log(filterItems('ap')); // ['apple', 'grapes']
console.log(filterItems('an')); // ['banana', 'mango', 'orange']
```

#### ES6的实现

```js
const fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];

/**
 * Array filters items based on search criteria (query)
 * 基于搜索条件的数组筛选项
 */
const filterItems = (query) => {
  return fruits.filter((el) =>
    el.toLowerCase().indexOf(query.toLowerCase()) > -1
  );
}

console.log(filterItems('ap')); // ['apple', 'grapes']
console.log(filterItems('an')); // ['banana', 'mango', 'orange']
```

- 上面等效于

```js
        const filterItems = function (query) {

        return fruits.filter(

            function (element) {

                return element.toLowerCase().indexOf(query.toLowerCase()) > -1
            }
        );
    }
```

- ***function (query) {const filterItems = function (query) {}***
  
  创建一个函数,接收你要查询的参数.

- ***return fruits.filter(callback)***
  
  ​    该return语句返回一个新数组,该新数组的内容是:通过callback检测元素.
  
  ​        *即传进来的参数如果存在当前正被调用的元素中,则该元素会被放入新数组*

- ***function (element) {}***
  
  ​    调用fiter()方法时的第一个参数:callback; 
  
  ​    element参数是调用fitler()方法的数组 的当前正被遍历的元素(从0开始→length-1)

- ***return element.toLowerCase().indexOf(query.toLowerCase()) > -1***
  
  ​    返回一个新字符串:element元素的小写形式,判断query(传进来的参数)值是否存于该字符串中,
  ​    存在返回true,不存在返回false.(因为最后面进行了比较运算了)
  ​     即其整体返回一个布尔值,
  
  ​    这个返回值为callback的返回值,所以必须是布尔值,否则如果不是布尔值,则filter()方法将会输出一个新的空数组,
  
  ​    因为没有任何元素通过callback函数的检测,即当前倍调用的元素经过callback函数检测时,其返回值不为true.

## 如何判断一个对象是否是数组

详情请看《h5_css_js》.doc

# 全局方法

## 描述

所谓的全局方法,即可用于所有JavaScript数据类型.

## 处理数字时最相关的方法

1. Number()
2. parseFoloat()
3. parseInt()
