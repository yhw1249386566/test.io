# [可选链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE)

## 描述

可选链运算符的符号表示为: `?.`

可选链?.  :能够读取一个指定对象的 深层次属性的值,而不用去明确校验这个深层次属性的 链条上的每一个引用 是否正确.

可选链运算符?. 的功能类似于[`.`运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors),不同之处在于如果链条上的一个引用是[nullish](https://developer.mozilla.org/en-US/docs/Glossary/nullish) ([`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined))，**`.`**操作符会引起一个错误; 而可选链操作符`?.`是会按照短路计算的方式返回一个undefined.

- 在不存在可选链运算符时,曾经我们想要获取一个对象的 深层次属性的值,我们需要判断该属性前面的引用*(若这深层次属性存于另一个属性中)*是否为null/undefined,

  如果不进行这样判断,则若深层次属性 前面的引用不存在,那么浏览器将会返回一个错误.

  ---

  而现在我们可以使用可选链运算符,即使不明确的去判断深层次属性 前面的引用是否为null/undefined,浏览器也不会报错,

  只不过若前面的引用等于null/undefined,则会如同短路运算般,整个使用可选链运算符语句 会直接返回undefined.

  但是程序依然会照成执行,就如同try...catch语句般.

可选链运算符除了用于判断一个对象的深层次属性的 链条引用上的 属性是否为null/undefined, 还能用判断某个函数是否为null/undefined,如:一个class中是否的某个函数是否为null/undefined.

通常可选链运算符目的是: 当访问链条上存在某个属性可能却不存在时，`?.`操作符将会使表达式更短和更简单。当不能保证哪些属性是必需的时，**`?.`**操作符对于探索一个对象的内容是很有帮助的。

注意: 一个对象不存在是为undefined和定义了该对象但是将对象值设置为undefined,这两个undefined是由不同的,***详见: 示例 - 使用`?.`判断一个对象是否为null/undefined***

## 语法

- `obj?.prop;` 

  obj是否等于null/undefined,若等于则返回undefined;

  否则如同正常的调用prop属性: **obj.prop**

- `obj?.[expr]`

  obj是否等于null/undefined,若等于则返回undefined;

  否则如同正常的调用prop属性: **obj[prop]**

- `arr?.[index]`

  arr是否等于null/undefined,若等于则返回undefined; 

  否则如同正常的调用arr的索引: **arr[index]**

  - 实际上,对于数组来说,即使不用可选链运算符,直接使用arr[42],浏览器不会报错,而是还是返回undefined.

- `func?.(arg1,...argn)`

  func(args)是否为null/undefined,若等于则返回undefined; 

  否则就如同正常的调用函数:**func(args)** 

## 为什么要使用可选链运算符?

### 不使用可选链查找一个深度嵌套的属性

首先我们得了解不使用可选链查找一个深度嵌套的属性,到底是有多麻烦?

现在请你们思考一个存在嵌套结构的对象obj。

不使用可选链的话，查找obj对象中的一个深度嵌套的子属性需要验证之间的引用，除非你不在乎浏览器给你报错致使你的程序终止运行.

例如：

```js
    let obj = {
        // first: {
        //     second: 'http://www.whyhw.com'
        // }
    }
    let prop = obj.first && obj.first.second;
    console.log(prop); // undefined
```

***&&参见:<逻辑运算符.md>***

- ***obj.first && obj.first.second;***

  若obj.first为true,则返回obj.first.second; 否则直接返回obj.first.

  而obj.first为true的条件是:obj.first存在且不为null/undefined.

通过以上的这个示例,我们发现不使用可选链查找一个深度嵌套的属性,则需要验证每一个属性之间的引用, 如:

为了确保obj.first.second可以执行,则obj.first一定需要存在且不为null.

而如果这个second属性嵌套层次再深一点: obj.a.b.c.first.second; 那么想要引用second属性且保证浏览器不会报错,则需要验证这条链上的每个引用的正确性,很显然,这很麻烦: `obj.a &&obj.b && obj.c && obj.first && obj.first.second`

所以为了解决这个问题,可选链诞生了.

### 使用可选链查找一个深度嵌套的属性

我们依然使用刚才的示例: obj.a.b.c.first.second; 这次我们使用可选链来验证链上的 每个引用的正确性: `obj?. a?. b?. c?. first?. second;` 

很显然,这大大的加深了易读性和可理解性以及可维护性,所以这就是我们使用可选链运算符的原因.

这条使用可选链运算符的语句的对象如下:

```js
    let obj = {
        a: {
            b: {
                c: {
                    first: {
                        second: {

                        }
                    }
                }
            }
        }
    }
```

## 是否可用`?.`取代`.`运算符（可）

如果你愿意的话,你完全可以使用可选链运算符取代 `.`运算符.

通过使用`?.`操作符取代`.`操作符,JavaScript会知道在尝试访问某个对象的深层属性之前先明确的校验并确定深层属性 前面的引用是非`null`且非`undefined`。

如果深层属性的 前面的引用是null或undefined，表达式将会短路计算直接返回undefined; 

而如果使用 `.`操作符且没有进行判断,则只要链上的属性之间的引用一个为null/undefined,则浏览器将会报错,程序会终止运行,这是非常不好的.

## 示例

### 语法中的简单示例

#### obj?.prop; 

```js
    let obj = {}
    let say = obj?.say;
    console.log(say); // undefined
```

obj是否等于null/undefined,若等于则返回undefined;

否则如同正常的调用prop属性: **obj.prop**

显然的,这里obj.say不存在===undefined,所以整个语句返回值为undefined.

#### obj?.[expr]	

```js
    let obj = {}
    let say = obj?.['say'];
    console.log(say); // undefined
```

obj是否等于null/undefined,若等于则返回undefined;

否则如同正常的调用prop属性: **obj[prop]**

显然的,这里obj['say']不存在===undefined,所以整个语句返回值为undefined.

#### arr?.[index]

```js
    let arr = [];
    let arrayItem = arr?.[42];
    console.log(arrayItem)
```

arr是否等于null/undefined,若等于则返回undefined; 

否则如同正常的调用arr的索引: **arr[index]**

显然的,这里arr[42]不存在===undefined,所以整个语句返回值为undefined.

- 实际上,对于数组来说,即使不用可选链运算符,直接使用arr[42],浏览器不会报错,而是还是返回undefined.

#### func?.(arg1,...argn)

```js
    class Test {
        say(num) {
            return num
        }
    }
    let result = Test.prototype.say?.(2);
    console.log(result); // 2
```

- Test.prototype.say(2)是否为null/undefined,若等于则返回undefined; 

  否则就如同正常的调用函数:**Test.prototype.say(2)** 

通过前面的三个小示例,我相信你们都已经大概知道了可选链运算符的用法了,所以这里我不在故意使链条上的引用为null/undefined,而是让它们存在.

所以这里的result的值为2.

### 可选链与函数调用

在 ***语法中的简单示例 - func?.(arg1,...argn)***我们已经稍微提过可选链运算可以使用于函数,这里我将详细在讲解一番.

当尝试调用一个可能不存在的方法时也可以使用可选链。这将是很有帮助的，比如，当使用的一个API的方法可能不可用时=>要么因为实现的版本问题,要么因为当前用户的设备不支持该功能。

函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回`undefined`而不是抛出一个异常。

```js
let result = someInterface.customMethod?.();
```

**注意:** 如果存在一个属性名且不是函数, 使用 `?.` 仍然会产生一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常 (x.y is not a function), 如:

```js
    let someInterface = {
        customMethod: 'httt://www.whyhw.com'
    }
    let result = someInterface.customMethod?.();
    console.log(result);
```

将会报错:

​	Uncaught TypeError: someInterface.customMethod is not a function

#### 处理可选的callbacks或事件handlers

```js
//  ES2019的写法
function doSomething(onContent, onError) {
  try {
    // ... do something with the data 
  }
  catch (err) {
    if (onError) { // 校验onError是否真的存在
      onError(err.message);
    }
  }
}

// 使用可选链进行函数调用
function doSomething(onContent, onError) {
  try {
   // ... do something with the data
  }
  catch (err) {
    onError?.(err.message); // 如果onError是undefined也不会有异常
  }
}
```

### 可选链在赋值时无效

需要知道的是,可选链运算符在赋值时无效的.

```js
    let obj = {}
    obj?.test = 'yomua'
```

浏览器会报错:

Uncaught SyntaxError: Invalid left-hand side in assignment

### map中查找不存在的key

```js
let myMap = new Map();
myMap.set("foo", {name: "baz", desc: "inga"});

let nameBar = myMap.get("bar")?.name; // undefined
```

- ***map参见:<Map和Set.md>***

以上的例子在一个不存在bar属性的map中查找bar中name的值，因此结果是undefined。

### 可选链是短路计算的

当在表达式中使用可选链时，如果左操作数是null或undefined，表达式将不会被计算，例如：

```js
let potentiallyNullObj = null;
let x = 0;
let prop = potentiallyNullObj?.[x++];
console.log(prop); // undefined
console.log(x); // 作为0的x将不会被递增，依旧输出0
```

### 可选链运算符和nullish合并运算符

nullish合并运算符,***参见:<nullish合并运算符>***

```js
  let custom = {
      name: 'Yomua',
      details: {
          age: '21',
          // city: '成都'
      },
  }

  let customCity = custom.details?.city ?? 'Unkonw City';
  console.log(customCity); // Unkonw City
```

将可选链运算符和nullish合并运算符一起使用的好处是: 即使某个对象的深层属性在引用过程中,导致整个语句返回undefined,那么使用nullist合并运算符将可以赋予一个默认值给这个语句.

nullish合并运算符:左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。

所以我们以上的例子中: 

- ***custom.details?.city ?? 'Unkonw City';***

  若custom.details?.city返回一个null或undefined,则这个语句的值为Unknown city, 否则值为:custom.details.city => 成都

### 使用`?.`判断一个对象是否为null/undefined

请注意:使用`?.`判断一个对象是否为null/undefined可能是没意义的,**因为如果对象不存在**(undefined),则仍然会报错,而不是返回undefined.

```js
let result = obj?.prop;
console.log(result);
```

- ***obj?.prop;***

  从常理来看,这语句的意思为: 若obj为null/undefined,则返回undefined,但是实际上,浏览器会直接报错:

  **Uncaught ReferenceError: obj is not defined**

**但是,如果对象存在定义**,只是值为undefined或null,则仍旧有意义,整个表达式不会报错,而是会返回undefined.

```js
    let obj = undefined / null ;
    let result = obj?.prop;
    console.log(result); // undefined
```

​	