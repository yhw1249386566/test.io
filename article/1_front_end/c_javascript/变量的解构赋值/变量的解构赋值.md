[TOC]

# 定义

**ES6允许按照一定模式,从数组和对象中提取值,然后对变量进行赋值,这被称为解构(Destructuring)**

# 描述

ES6允许按照一定模式,从数组和对象中提取值,然后对变量进行赋值,这被称为解构(Destructuring)

解构赋值有条很重要的规则,即:**只要等号右边不是对象/数组,那么就先将其转为对象,然后再进行解构赋值**.

由于null和undefined无法转为对象,所以它们无法进行解构赋值.

可以解构赋值的有:

- 数组
- 对象
- 字符串(转为类数组对象)
- 数值和布尔值(转为对象)
- 函数参数

# 示例

## 基本用法

```js
let a = 1;
let b = 2;
let c = 3;
// ES6(ES2015)中允许写成:
let [a, b, c] = [1, 2, 3];
```

其意思为:**从右边的数组中提取值,并按照对应的位置,将之一一赋值给左边变量.**

它的本质上是一种"模式匹配",即只要左等号两边的模式相同,左边的变量就会被赋予对应的值,实际上,对象的解构赋值也是这样.

如果解构不成功,即右边的值无法赋值给左边,那么左边的变量将会等于undefined. 

解构存在不完全结构,即等号右边只能赋值一部分给左边.

```js
let [a, b, c] = []; // 解构失败
let [a, b, c] = [, , 3]; // 不完全解构
```

## 数组的解构赋值

### 基本用法

```js
// foo=1,bar=2,baz=3
let [foo, [ [bar], baz] ] = [1, [ [2], 3] ];
/** head=1,tail=234 这是很有趣,...是什么意思,我暂时还不清楚,应该和iterator有关.
这是因为在这里使用...扩展运算符,它就会相当于在函数参数中使用->变成剩余参数,接收余下所有值,参见:<展开语法.md>
*/
let [head, ...tail] = [1, 2, 3, 4];
```

注意如果左边为数组,右边却不是数组,或着严格来说不是可遍历的结构，*参见《Iterator》*,那么就会报错.

其实想想也对,毕竟这种数组形式解构是靠匹配,靠位置来进行赋值的,如果不能迭代,那么怎么赋值?

 且等号左边为数组那么等号右边也要为数组,不论是数组,还是对象又或者是其他,当然是有一点除外,即:

​    由于数组是特殊的对象,所以实际上数组的值是可以赋值给对象的,而对象的值无法赋值给数组.

### 右边值为不可遍历的解构

```js
// 报错 xxx is not iterable. xxx无法被迭代
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

对于 Set 结构，也可以使用数组的解构赋值。

```javascript
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用**数组**形式的解构赋值。

### 用方法对数组解构赋值

```js
    let [a, b, c] = []; // initial
    function add() {
       return ([a, b, c] = [1, 2, 3])
    }
    let [q, e, w] = add();
    console.log(q,e,w); // 1 2 3
```

这个示例充分的告诉我们,对于数组的结构赋值来说,只要右边是可以进行迭代,可遍历的值,那么就能进将之赋值给左边.

### 解构赋值使用默认值

#### 默认值是原始值

数组的解构赋值允许指定默认值。(对象的解构赋值也允许)

```javascript
let [foo = true] = [];
// foo = true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。

```javascript
let [x = 1] = [undefined];
// x = 1

let [x = 1] = [null];
// x = null
```

#### 默认值是一个表达式

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

```javascript
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
console.log(x); // 1

// 这个也就是相当于:

let _ = 1;
function f() {
  console.log('aaa');
}
if(x = _ === undefined ) {
    x = f();
}else {
    x = _;
}
console.log(x); // 1
```

即:若[1]的值 === undefined,则`f函数`的返回值将会赋值给x.

下面是官方的翻译版本,其结果是等效的.

```js
/* 下面为babel官网的翻译 */
function f() {
    console.log('aaa');
}
var _ = 1,
    x = _ === undefined ? f() : _;
console.log(x); // 1
```

- x = _ === undefined ? f() : _; 
  
  三目运算符.
  
  即,将 `_`变量的值1赋值给x,若严格等于undefined,则将f()赋值给x,否则将 `_`这个赋值给x

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

```javascript
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
```

请把这些代码行单独拆开来看.

### 数组的构造函数的解构赋值

```js
let [a, b, c] = new Array(1, 2, 3); // bad
// 由于数组也是对象,所以可以写成以下形式,其结果是等效的.
let { 0: a, 1: b, 2: c } = new Array(1,2,3);
console.log(a,b,c); // 1 2 3
```

虽然可以这么做,但是其意义不大.因为我们建议不要使数组复杂化,有更简单的方法,数组字面量的创建方法:

`let [a, b, c] = [1, 2, 3];` // good

这代码行和上面的两个代码行其结果也是等效的,而且更优,它不会让事情复杂化,这种原始值的创建数组的方法,更优秀.

## rest参数/剩余参数说明

可以看<展开语法.md>

### 描述

[rest参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/rest_parameters)即剩余参数,或者说是以展开语法的形式作为函数参数.**它允许我们将一个不定数量的参数表示为一个数组。**

​    即:**接收余下的所有实参,将之全部放入指定的某个数组变量中.**

如果函数的最后一个命名参数以`...`为前缀,则它将成为一个由剩余参数组成的真数组,这个数组的元素由传过来的参数提供.

且注意:用在函数参数中,叫做剩余参数,且把此参数作为数组; 如果用于解构赋值中,也将它叫做剩余参数. 

因为实际上,**用于函数参数和解构赋值中的"展开语法"和真正的展开语法可以说功能相反,但语法一样. **

**因为剩余参数的目的是将多个变量合成一起,而展开语法是将一个变量展开成多个变量**

​    PS:用在函数调用中的展开语法和用在函数参数中的剩余参数是不一样的.

```js
// 用在函数调用中
myFunction(...args);

// 用在函数参数中
function(a, b, ...theArgs) {
}
```

### 语法

```js
function(a, b, ...theArgs) {
  // ...
}
```

在上面的例子中，`theArgs`将收集该函数的第三个参数（因为传过来的第一个参数被映射到`a`，而第二个参数映射到`b`）和所有后续传过来的参数,

相当于: `let theArgs = [传过来的所有参数,xx,...]`

#### 函数中的剩余参数和 arguments对象的区别

剩余参数和 `arguments`对象之间的区别主要有三个：

- 剩余参数只包含那些**没有对应形参**的实参，而 `arguments` 对象包含了传给函数的所有实参。    
- `arguments`对象不是一个真正的数组，**而剩余参数是真正的 `Array` 实例**，也就是说你能够在它上面直接使用所有的数组方法/属性，比如 `sort`，`map`，`forEach`或`pop`。
- `arguments`对象还有一些附加的属性 （如`callee`属性）。

#### rest参数用在函数参数中是一个数组

rt,虽说是一个数组,但是由于数组是特殊的对象,所以返回类型依然为object

```js
function fun1(...theArgs) {
  alert(theArgs.length);
    console.log(theArgs); // [] [5] [5,6,7]
}

fun1();  // 弹出 "0", 因为theArgs没有元素
fun1(5); // 弹出 "1", 因为theArgs只有一个元素
fun1(5, 6, 7); // 弹出 "3", 因为theArgs有三个元素
```

通过此示例,我们可以知道,如果将剩余参数作为作为函数参数,那么此剩余参数将可以通过 `...`后面的名字使用数组对象的所有方法和属性.

- console.log(theArgs); // [] [5] [5,6,7]
  
  因为将展开语法用于函数参数中变成剩余参数之后,它就成为了数组,所以输出的当然也是数组.
  
  即意思为:接收余下的所有实参,将之全部放入theArgs数组变量中.

#### 用展开语法解构赋值 字符串/对象/数组

如果将展开语法作为解构赋值中的一员,用在字符串/对象/数组的解构赋值中,那么我们可以使用展开语法,即`...变量`,以变量作为对象的形式,使用当前展开语法所在的类型的所有方法/属性;

注意:以展开语法为变量的返回类型为object,请看以下示例:

- 字符串解构赋值时会被转成一个类数组对象,所以返回类型为object.
- 数组本身就是特殊的对象
- 对象,就是对象.

```js
let  { x, y, ...z } = { x: 1, y: 2, a: 3 };
console.log(typeof z); // object
console.log(z['a']); // 3
console.log(z); // {a: 3}

let [x, y, ...z] = [1, 2, 3, 4];
console.log(typeof z); // object
console.log(z.push('yooo')); // 3
console.log(z); // [3, 4, "yooo"]

let [x, y, ...z] = "yomua";
console.log(typeof z); // object
console.log(z.concat('yomua'));//["m", "u", "a", "yomua"]
console.log(z); // ["m", "u", "a"]
```

很明显的我们可以发现,将剩余参数应用解构赋值的特点:

- 获取余下的所有key / 值
- 展开语法展开的变量返回的类型都为对象
- 被展开语法展开的变量能使用当前所处的赋值语句类型的所有属性/方法

## 对象的解构赋值

### 定义

**对象的解构赋值以等号左边的属性名匹配右边的属性名,若能匹配到,则将右边的属性的值赋值给左边匹配到的属性的值.**

### 描述

对象的解构赋值以等号左边的属性名匹配右边的属性名,若能匹配到,则将右边的属性的值赋值给左边匹配到的属性的值.

其右边的属性名的顺序并不会影响赋值的效果.这点和数组按位置排序来赋值有着重大区别.

对象的解构赋值有简写形式,和完整形式.

**简写形式**:

​     `let { foo: baz } = { foo: 'aaa', bar: 'bbb' };`

**完整形式**: 

​    `let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };`

详情请继续往下看.

### 真正的 对象解构赋值 ★

请看以下示例:

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
console.log(foo, baz); // undefined aaa
```

我们能清楚的发现,在输出foo这个属性时,竟然为undefined,而输出属性的值baz竟然为aaa,这到底是怎么一回事呢?

因为实际上,我们常看到的对象的解构赋值其实是下面形式的简写.

```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
let { xxx: xxx, xx: xx } = { xxx: 'aaa', xx: 'bbb' };
```

从上面这个完整写法来看,也就是说,对象解构赋值的**内部机制**是: 

​    **是先使用左边的属性名,匹配右边的属性名,若能匹配到,则将右边的属性的值赋值给左边的属性的值.**

也就是说等号左边,真正被赋值的其实是后者,而前者只是一个属性,或者说是一个需要匹配属性名的一种蓝图(一个模板,一种模式).

而我们常看到的简易写法,看上去像是将右边的属性的值赋值给左边的属性(蓝图),但是实际上不是这样子的,

而是因为使用简写时,左边的属性名和它的值刚好名字一样罢了.让我们看看一下简写形式:

```js
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
// 其完整写法应该为:
let { bar:bar, foo:foo } = { foo: 'aaa', bar: 'bbb' };
```

所以实际上,当对象进行解构赋值时,赋值的是左边的属性的值*(此值才是变量,左边的后者;而不是属性名,左边的前者,*

*它只是一种匹配的机制,就和我们使用对象的属性名取值一样: `obj['objName'] = objValue;`* 

*'objName'请加引号(单/双/反引号都行,否则不加则代表objName是变量) ,实际上,如果想要让某个对象中的属性变成变量的形式,需要一些特殊的做法)*

这个非常重要.

### 对象的解构以蓝图匹配属性名进行赋值

对象的解构赋值和数组还是有所区别的,即使数组是特殊的对象.

**数组和对象的解构赋值其重大区别在于:** 

​    数组的元素是按次序排列（数组和数组进行解构赋值）,变量的被赋值什么由右边的值的顺序决定; 

​    但是对象的解构赋值（对象和对象进行解构赋值）可不会因为右边的顺序不同从而导致取值不同,这是因为对象的属性名才是关键, 

**只要等号左边的属性名和右边的属性名相同,属性的值(变量)就可以取到右边的属性的值**

​    **(前提是正确的语法)**

以下示例为对象的解构赋值,蓝图(左边的属性)bar,foo若可以匹配到相对应的属性名,就能取到这个属性的值.

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
consoloe.log(bar,foo); // bbb aaa
```

若右边,即对象的属性名中没有一个等于变量,那么变量值就为undefined.

```javascript
let { baz } = { foo: 'aaa', bar: 'bbb' };
console.log(baz); // undefined
```

以上第一个示例证明: 等号右边(值)的顺序排列和变量的取值没有任何关系,只在乎变量所属的属性的名字是不是能匹配到相同的属性名.

以上第二示例则说明:当进行对象的解构赋值时,若变量它所属的属性(baz)匹配不到相应的属性名,则它的值和数组未有相对位置的值一样,为undefined.

### 嵌套结构的对象的解构赋值

```javascript
let obj = { p: ['Hello',{ y: 'World' } ] };

let { p: [x, { y }] } = obj;
console.log(x,y); // Hello World
```

这里我要强调,p是一种匹配的蓝图(*不懂得请看: 真正的 对象解构赋值.*),而x和y才是需要被赋值的变量, 这里的对象解构赋值其实并不完整,而是属于简写,完整写法如下:

```js
let { p: [x, { y : y }] } = obj;
```

不过有点需要注意: `[x, { y : y }]`,是一个数组,它在取右边的属性的值是会按照数组的解构赋值进行取值,即按照顺序来取值的,所以如果顺序改变,此时就会影响到x,y的值,例如:

```js
let obj = { p: ['Hello',{ y: 'World' } ] };

let { p: [{ y:y }, x] } = obj;
console.log(x,y); // { y: 'World' } undefined
```

很明显的,由于{ y:y } 和 'Hello'并不是一个类型的解构赋值,所以此时y这个变量==undefined, 而x此时是一个数组中的变量,并不是对象,所以此时x进行解构赋值,就相当于: `let x = { y: 'World' }`, 输出x当然是{ y: 'World' }了.

如果将这个示例转换成ES6以下的其他版本,将会非常的复杂, 不过我们其实大多数时候不需要了解其他版本是如何书写的,因为自然会有转码器帮我们做到这一步,

就算我们不懂其他版本的ES如何进行编写,也不影响我们使用ES6写出好代码,毕竟时代在进步,工具也在进步,何况这ES6不是工具,而是官方升级的一个JS语言版本. 不然要了解ES6还要了解其他ES版本?那机器语言你要不要了解一下?

### 对象的解构赋值可以取到继承的属性

```javascript
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);

const { foo } = obj1;
// bar
```

`Object.setPrototypeOf(obj, prototype)`

​    即设置一个对象的原型对象,也就是说指定obj这个对象的原型对象是prototype.(将第一个参数的原型对象设置为第二个参数)

- ​    prototype为另一个对象或null.

​    简单来说就是: obj的原型对象是另一个对象或null对象.

​        *详情请看JavaScript帮助文档或<JavaScript高级.md>*

所以此时obj1可以使用原型对象中的属性/方法,也就是说obj1这个对象能使用obj2对象的属性/方法. 而此时obj2对象的属性只有1个foo,所以obj1也能使用它.

`const { foo } = obj1;`

​    那么这个就很好理解,也就相当于:

​        **const{ foo } = obj1.prototype = obj2 = {foo: 'bar}';**

所以console.log(foo); 则输出bar.

因为系统会先在obj1这个对象中寻找有没有能匹配foo这个属性的属性名,如果没有,则会去原型链上找,即prototype中去找,而这里的prototype就为obj2这个对象.

所以系统就去obj2上寻找,若找到了就将之使用,若还没找到,就继续寻找obj2.prototype,直到顶层Object或碰到null对象.

​    *详情了解prototype原型链请看:<JavaScript高级.md>*

### 将对象的方法,使用解构赋值给变量

```javascript
const { log } = console;
log('hello') // hello
```

即使用log属性匹配console对象的方法,若匹配到console对象 存在此方法,则将的此log方法整个赋值给log属性的值log变量.

很显然console对象存在log方法,所以成功赋值给log变量.

- 但是请注意,console不要加大括号,因为JS引擎会将之认为是一个变量或则和值赋值给log,而不是一个完整的对象.

诸如类似的有:

```javascript
let { log, sin, cos } = Math;
```

使用log(),sin(),cos()就如同使用Math这个内置对象的Math.log(),.sin(),.cos().

以上的示例说,对象的解构赋值,可以取到对象的方法.

### 使用默认值

显而易见,和数组的解构赋值一样,对象的解构赋值也存在默认值,请看以下示例:

```javascript
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = 'Something went wrong' } = {};
msg // "Something went wrong"
```

PS:请注意,和数组的解构赋值一样的是,对象的属性值严格等于`undefined`默认值才会生效,否则都是等于等号右边赋予的属性值.

```javascript
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
```

上面代码中，属性`x`匹配到的x等于undefined,所以就会使用默认值3.

而另一个代码行,属性x匹配到的x属性并不是undefined,所以不会使用默认值,依然为nll.

### 使用展开语法/rest参数对 对象解构赋值

*展开语法请看<展开语法.md>*

- #### 解构剩余参数/对剩余参数进行解构赋值

*了解展开语法请看<展开语法.md>*

```js
let {x, y, ...z} = { x: 1, y: 2, a: 3, b: 4 }
/*
    x为1
    y为2
    z为{a:3, b:4}
*/
```

以上的{...z}参数,也叫做Rest参数,即剩余参数,这是官方的叫法,虽然我们也可以将它叫做对象的展开语法就是了.

在上面的对象解构赋值中,我们可以看到变量z使用了展开语法(rest参数),如果只存在{...z};则代表将对象z在语法层次上展开,但是这里{...z}存于解构赋值语句中,

它会将等号右边尚未使用的key和value全部拷贝过来,即拷贝到对象z中.也就是说,此时的变量z是一个对象类型object,不像x和y,它们属于number.

**请注意:**使用展开语法(rest参数)对 对象进行解构赋值,必须保证使用展开语法的对象为最后一个参数,例如上面的示例的{...z},它就是最后一个参数,如果写成以下形式,则报错:

```js
let {...z, x, y} = { x: 1, y: 2, a: 3, b: 4 };
/*
Uncaught SyntaxError: Rest element must be last element
即:未捕获的语法错误:Rest元素必须是最后一个元素.
*/
```

## 字符串的解构赋值

没想到吧,ES6连字符串都存在解构赋值.这是因为,字符串被进行解构赋值时,它会被转换成一个类数组对象对象,请看示例:

```js
const {0:a,1:b,2:c,3:d,4:e} = 'hello'
let {length:len} = 'hello';
console.log(a,b,c,d,e); // h e l l o
console.log(len); // 5
```

这个转换过程非常的麻烦,这里为了更为清晰的讲解,我将这过程使用babel进行编译:

```js
'use strict';

var _slicedToArray = function () {
    function sliceIterator(arr, i) {
        var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value); if (i && _arr.length === i) break;
            }
        } catch (err) { _d = true; _e = err; }
        finally {
            try {
                if (!_n && _i["return"]) _i["return"]();
            }
            finally {
                if (_d) throw _e;
            }
        } return _arr;
    } return function (arr, i) {
        if (Array.isArray(arr)) {
            return arr;
        } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
        } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
    };
}();
var _hello = 'hello',
    _hello2 = _slicedToArray(_hello, 5),
    a = _hello2[0],
    b = _hello2[1],
    c = _hello2[2],
    d = _hello2[3],
    e = _hello2[4];
```

**类数组对象定义:**

> 可以通过**索引**访问元素，并且拥有 length 属性；
> 
> 没有数组的其他方法，例如 `push` ， `forEach` ， `indexOf` 等。
> 
> 所以才称之为类数组对象

- **_slicedToArray(stiring,number)**
  
  ​    此方法就是将字符串转为类数组对象的方法.
  
  ​    而为什么有个number参数呢,这是因为number代表着需要被赋值的变量的个数,从0开始计数.
  
  ​    如果变量的个数超出被转成类数组对象的"hello"长度,则超出的那部分值为undefined.

## 数组和布尔值的解构赋值

解构赋值有条很重要的规则,即:**只要等号右边不是对象/数组,那么就先将其转为对象,然后再进行解构赋值.**

由于null和undefined无法转为对象,所以它们无法进行解构赋值.

```js
let {toString:s} = 123;
let {toString:s} = true;
```

以上的示例可以被官方编译为以下形式:

```js
var _123 = 123,s = _123.toString;
var _true = true,s = _true.toString;
```

那我为什么会说只要等号右边不是对象/数组,那么就先将其转为对象,然后再进行解构赋值,因为这两个代码行分别严格等于:

- **s === Number.prototype.toString // true**
  
  返回指定Number对象的toString整个方法的代码.

- **s === Boolean.prototype.toString // true**
  
  返回指定Boolean对象的toString整个方法的代码.

所以以上的ES6代码,不如说等于:

```js
var _123 = new Number(123), s = _123.toString;
var _true = new Boolean(true),s = _true.toString;
```

即先将右边的数值/布尔值转为对象,然后赋值给一个临时变量,再将这个临时变量的toString方法整个赋值给属性的值s 变量.

至于中间的那两个示例为什么被官方编译为不是对象的形式,还不是ES在进步,即使用创建构造器对象的方法,没有使用直接用原始值来赋值快,

而且用构造器创建对象反而会使程序变得更加复杂,所以不如使用等效的原始值赋值方式进行赋值.

但是你们仍然要清楚的知道,解构赋值的过程中**,如果等号右边不是对象/数组,那么此右边的值将会被转为对象/类数组对象.**

## 函数参数的解构赋值

### 基本用法

在前面的数组的解构赋值,对象的解构赋值中,其实都存在函数参数的解构赋值操作.

即将一个函数的参数进行解构赋值.

```javascript
function add([x, y]){
  return x + y;
}
add([1, 2]); // 3
```

在函数add的参数中,此参数看上去是一个数组参数,确实也是.但是如果执行add([1,2])的那一刻开始,add函数中的数组参数就会被解构赋值成变量x,y.

那么此时,add函数内部只能**感受到变量x和y**,而**不是数组参数[x,y],**因为此数组参数已经被解构赋值了.

而add函数中的[x,y]参数其实被解构赋值时,等于:

​    `([x, y] = [1, 2])`

这样一看,是不是就感觉清楚明了了,即变量x的值为1,y的值为2.

需要注意的是:看上去使用ES6很简单的对函数参数进行解构赋值,实际上若编译成ES6之下的ES版本的代码,将会和 *字符串的解构赋值* 示例中的遍历过后的代码一样,将会非常的复杂.

不过,我们其实不需要去了解,不是吗,准确来说,我们只需要知道ES6之下版本的代码大概是如何实现ES6的代码就行了,不是吗?

### 使用默认值的函数参数的解构赋值

函数参数的解构赋值,当然也可以使用默认值,但是也是必须等号右边的值需要严格等于undefined,才会应用默认值.

并且此示例不仅使用了默认值,还将函数参数的解构赋值写成对象的形式,而不是数组的形式.

```javascript
function move({x = 0, y = 0} = {}) {
  return x + y;
}

move({x: '阿', y: '思'}); // 阿思
move({x: 3, y: 8}); // 11
move({x: 3}); // 3
move({}); // 0
move(); // 0
```

**代码解析**

- ***function move({x = 0, y = 0} = {}) {...}***
  
  即创建一个名为move的函数,
  
  ​    *或者说使用move指针指向了一个内存地址空间,并在其里面存入了一个函数(一个行为),不过要这样说,必须是这样的形式:*
  
  ​        *let move = function(arg1,..,argn,"function_body");详情请看<Difficult.md>*
  
  ​    其参数为对象,并且是解构赋值,然后接收一个对象,并将此对象中相匹配的属性的值赋值给参数对象中对应的属性的值.

- ***{x = 0, y = 0} = {}***
  
  ​    请注意,这里并不需要 `={}`, 当然了,写也不错,不写也行.它们二者是等效的行为,
  
  ​    在 *函数参数的解构赋值 - 基本用法* 中将参数使用数组的解构赋值中我们也没有写,当然写可以.

## important point

### 将一个已声明的变量进行解构赋值

#### 若需要解构赋值的是对象

如题,这样做时,要非常小心,请看以下示例:

```javascript
// 错误的写法
let x;
{x} = {x: 1};

/* 
    SyntaxError: syntax error
         甚至会直接在编译时报错:
    Declaration or statement expected.
 */
```

之所以会报错,或编译错误,是因为JavaScript引擎会将{x}理解成一个代码块,从而发生语法错误/声明错误.代码块怎么能这样赋值呢?

而想要解决此问题也很贱,即不将{}大括号写在行首(开头),避免JS将{x}理解成一个代码块.

```javascript
// 正确的写法
let x;
({x} = {x: 1});
console.log(x); // 1
```

上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。

关于圆括号与解构赋值的关系:

#### 若需要解构赋值的是数组

上面的示例要加圆括号是因为,解构赋值的是对象,JS引擎可能将大括号里面的代码认为是一个代码块,所以才加的圆括号.

但是如果是为一个已声明的变量,进行数组的解构赋值,就不需要加圆括了,因为JS引擎并不会将之认为是代码块等．

```js
// 不需要圆括号也正确
let x;
[ x  ]= [ 1 ];
console.log(x); // 1
```

### 解构赋值的左边可以不设置任何属性以及变量名

由于解构赋值的左边可以不设置任何属性以及变量名,所以可以写出非常古怪的赋值表达式.

即使它们非常怪和没有意义,但是它们仍然能编译成功.

```js
({} = [true, false]);
({} = 'abc');
({} = []);
```

### 将数组解构赋值给对象

由于数组本质是特殊的对象，因此可以将数组解构赋值给对象.

```javascript
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
```

在这里,由等号左边的属性名0去匹配右边的属性名,若由,则取值,若无,则为undefined.

即此时 first == 1, 而[arr.length - 1]的计算结果为 3-1=2,所以此时last变量的值为3.

方括号这种写法，属于“属性名表达式”（参见《对象的扩展.md》）。

# 圆/小括号()的问题

## 描述

在 *示例 - important point - 将一个已声明的变量进行解构赋值* 中,我们讲过在对已声明的变量进行对象解构赋值时,需要使用圆括号才能解构赋值,

但是我们却没讲使用圆括号需要注意什么以及什么情况下能使用,这是一个大问题,否则到时候出错都明白为什么.

这里我就讲解一番.

首先解构赋值虽然方便,但是解析起来时并没有我们想象的那么容易,因为编译器在进行编译时: 

一开始时并不知道一个式子到底是需要被解构赋值还是说单纯的只是一个表达式,必须得解析到等号,或解析不到等号(即不存在等号)才知道这个式子是不是解构赋值还是表达式.

所以这样在JS引擎进行从左→右的解析时,可能会遇到一些会出现歧义的代码,例如:如果在解析过程中,存在圆括号(),那么该怎么处理呢? 

比如 `let {x: (c)} = { x : 2};`这行代码,JS引擎解析到`{x: (c)}`这里时,是先解析被圆括包裹住的c这个属性的值,还是先进行左右两边的模式匹配,等号左边的x属性匹配右边的x属性然后再进行赋值 呢?

所以ES6给出了解决方案,粗暴而简单: **即只要存在有任何可能导致解构的歧义产生,就不得使用圆括号,否则编译时错误或运行时错误.**

## 不得使用圆括号的情况

### 描述

- **在变量声明语句中,解构赋值不得使用圆括号**
  
  ​    当然了,指的是等号左边,即变量值那里不能使用,右边可以使用,只要是正确合乎语法即可.

- **函数参数中也不得使用圆括号.**
  
  ​    因为函数参数中使用解构赋值: 函数参数其实就等于变量声明,而传过来的值就是赋值语句,所以不得使用.
  
  ​    function demo({x,y]){...}; ({x,y}) → let {x,y} = {};
  
  ​    因为形参其实就是一个变量,只不过这个变量是只能在当前所属的函数内部使用罢了.

- **解构赋值语句的匹配蓝图无法使用圆括号**
  
  ​    即类如: 在对象的解构赋值中,蓝图(即属性名)都不得(等号左右两边都是一样)使用圆括号,
  
  ​    而值:它们都可以使用圆括号,只要不在以上三点使用即可.

### 变量声明语句

```javascript
// 全部报错
let [(a)] = [1];
let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};
let { o: ({ p: p }) } = { o: { p: 2 } };
```

因为它们都是变量声明语句,不得使用圆括号.

### 函数参数

```javascript
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

### 赋值语句的模式

```javascript
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
[({ p: a }), { x: c }] = [{}, {}];
```

## 可以使用圆括号

即赋值语句的非模式部分,即不用以等号左边的某个东西去匹配等号右边的某个东西之外的东西,就能使用圆括号.

```javascript
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；

其次它们的圆括号都不属于模式的一部分。

第一行语句中，模式是取数组的第一个成员，跟圆括号无关；

第二行语句中，模式是`p`，而不是`d`；

第三行语句与第一行语句的性质一致。

如果将第二句写成:  `let ({ p: (d) } = {}); // Error`就是错误的,因为这变成了声明语句,声明语句无论如何都不能在解构赋值中使用圆括号,当然了,等号右边的属性的值可以使用,但是属性不能使用.

# 解构赋值的用途

## 交换变量的值

```javascript
let x = 1;
let y = 2;
[x, y] = [y, x];
console.log(x,y); // 2 1
```

这样的写法不仅简洁，而且易读，语义非常清晰。

或许你会认为在执行 `[x, y] = [y, x];`此语句时,x的值不是已经变成了y的值2了吗, 为什么y被赋值的时候,右边的x仍然赋值的是1,不是2?

这是因为程序从上到下,从左到右执行,执行到该语句时,先执行了等号的右边,即[y, x],然后再执行的等号的左边[x, y], 所以[y, x]此时的值等于[2, 1],

且执行[x, y]时,等号右边将不会在继续执行,所以[y, x]的值并不会被改变,当然y变量也不会被赋值为2了.

## 从函数返回多个值

```javascript
// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
```

## 函数参数的使用

解构赋值可以方便地将一组参数与变量名对应起来.

```javascript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

此时,参数x,y,z都直接被赋予了值,而我们不需要像ES6版本之前那样,要给一个函数传数组值时,需要先在外面重新定义一个数组变量然后进行赋值,再把此数组变量传给函数,

而想要在函数内部使用这个数组变量的索引对应的值,我们还需要变量这个数组,或者直接指定数组索引然后取值,

这样就会非常的麻烦,不信你们看以下的示例:

```js
function f(arr) {
    let x, y, z;
    for (let i = 0; i < arr.length; i++) {
        if (typeof x === 'undefined') {
            x = arr[i];
            continue;
        }
        if (typeof y === 'undefined') {
            y = arr[i];
            continue;
        }
        if (typeof z === 'undefined') {
            z = arr[i];
            return;
        }
    }
    console.log(x,y,z); // 1 2 3
};
let arrStorage = [1, 2, 3];
f(arrStorage);
```

要达到ES6的效果,是不是非常的麻烦,不仅增加了代码行,还增加了JS引擎编译的速度.

这时候你回头看看最初的示例,ES6版本的.

我可以直接在函数内部使用x,y,z变量,根本不需要什么赋值啊,然后遍历,严格等于,跳出循环这些操作,即使有更优的代码,也无法达到质的变化,不信你看看下面的最初示例,ES6版本:

```js
// 参数是一组有次序的值
function f([x, y, z]) { 
    console.log(x,y,z)
}
f([1, 2, 3]);
```

**噢!看到了吗,多么简洁明了,直接就可以使用.**

## 使用解构赋值指定函数参数的默认值

在 *函数参数的使用* 中,我们已经说过了,可以将解构赋值用在函数参数中,这将大大减少工作量,代码行,但是我们那时没说在参数中使用解构赋值时可以使用默认值,

这样在某些情况写,可以避免函数内部再写赋值默认值. 比如我们使用原始JS封装AJAX时: 

```javascript
Obj.ajax = function (url, {
  async: async = true, // 完整形式,被赋值的是蓝色字体的async
  beforeSend = function () {},
  cache = true, 
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do something
};
```

以上的函数,只需要其他开发者调用ajax函数,传递参数时,即使有许多值没有指定,那么我们依然能直接在程序执行参数时,为一些必须要有默认值的属性赋为默认值,而不必在函数内部写.

**代码解析**

- ***(url, { key = value, ...} = {} )***
  
  ​    即接收传过来的一个url,和一个对象,此对象是将要赋值给变量的对象.
  
  ​    如同 let { key = value, ...} = {传过来的对象}.
  
  ​    我们可以一一使用key获取的此传过来的对象的属性的值,若形参无法匹配到传过来的对象的属性,那么就会赋予我们设定的默认值.

## 提取 JSON 数据

由于JSON格式可以使用JSON.parse(jsonData,receiver);函数将JSON格式字符串转为JS对象/原始值,

所以若使用解构赋值能轻松的将JOSN数据全部取到,而且精准方便,并以前的要么遍历对象,要么使用对象['属性名'] 或 对象.属性名的方法快捷多了.

```javascript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```

当然了,使用解构赋值也可以取到JS对象的值仍然是个对象的情况,请看:

```js
let jsonData = {
  id: 42,
  status: "OK",
  data: {
      name:"yomua"
  }
};

 let { id, status, data:{name} } = jsonData;

console.log(id, status, number);
// 42 "OK" "yomua"
```

注意,解构赋值比我们想象的还要灵活,因为我们不一定要使用JOSN数据中的对象的属性名来作为我们需要用到的属性名,我们可以换个名字:

`let { id, status, data:{name : nameTemp} } = jsonData;`

看到了吗,具体原因还需要我说吗?好吧,我还是再提一下: 即被赋值的变量是等等号左边的属性的值,而不是属性名,属性名只是一个匹配模板罢了,

此匹配模板匹配到了等号右边的属性名,就将此属性名的值取出来赋值给匹配模板的值.

需要注意的是, `data:{name}`中的{}大括号千万别丢,否则意思就会被改变: 即将{name:"yomua"}整个对象赋值给name,

而不会去匹配这个对象中的name属性,然后将"yomua"赋值给变量name.

这点非常需要注意,因为这是对象的解构赋值是匹配模式的,即有没有大括号影响非常大.

## 输入模块的指定方法

加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。

```javascript
const { SourceMapConsumer, SourceNode } = require("source-map");
```

其意思简单明了,即将`require("source-map");`函数的返回值中的SourceMapConsumer,SourceNode属性的值赋值给等号左边的变量SourceMapConsumer,SourceNode.

前提是此函数返回的是对象/数组/类数组对象等,反正只要能被等号左边相匹配即可,不匹配也要合法,不合法就报错了呗..

## 遍历 Map 结构

任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

​    *请注意:for...in遍历对象时也可以用解构赋值,但是没有任何意义,就和将等号左边赋予空变量一样,*

​    *因为for...in只能遍历对象/类数组对象,且一次只能遍历一个属性,而且我们是按顺序遍历,也不知道对象的属性名.,并且for(let temp in obj)中的temp还是个临时变量.*

​    *种种原因之下,那我们该如何取到对象中被匹配的属性,根本取不到.*

***for...of详情请看:<各类属性&方法.md>***

```javascript
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

如果只想获取键名，或者只想获取键值，可以写成下面这样。

```javascript
// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
```