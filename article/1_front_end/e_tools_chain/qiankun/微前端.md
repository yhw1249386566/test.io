# Micro FE





# Bilii

## 快速开始 - Bilili - umi

### 新建子应用

主应用和子应用都使用 umi, 新建子应用，并添加到主应用中：

> TIP: [@umijs/preset-react](https://v3.umijs.org/zh-CN/plugins/preset-react) 包含许多 umi 插件

[主应用配置](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E4%B8%BB%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE)：

1. 主应用左侧菜单栏添加子应用
   dev: `@\layouts\menu.config.tsx - menus`
   prod:  `@\layouts\basicLayout.tsx - getMenu()`

2. [注册子应用](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%B3%A8%E5%86%8C%E5%AD%90%E5%BA%94%E7%94%A8) 
   `@\app.ts - qiankun`

3. [添加子应用路由映射（装载子应用到主应用）](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%A3%85%E8%BD%BD%E5%AD%90%E5%BA%94%E7%94%A8) 

   `@\routes.ts` 

[子应用配置](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E5%AD%90%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE)：

1. 插件注册
2. 设置生命周期（使用 umi plugin qiankun 时可选）
3. 配置环境变量（使用 umi plugin qiankun 时可选），如子应用启动的端口号

### 路由匹配

在主应用中，要加载子应用路由的对应组件，则主应用此时的 url 地址应该是：`主应用配置子应用的 path 值 + 子应用路由值`，如：

比如我们在主应用 routes 中配置了：

```json
{
  path: '/app1/user',
  microApp: 'app1', // 注册子应用时的 name
}
```

子应用 app1 的路由配置是：

```json
{
  path: '/article',
  component: './Article',
}
```

那么我们必须通过 `/app1/user/article` 路径才能正常的访问到子应用的 Article 页面。

相当于：当主应用此时地址包含 `/app1/user`（如：`/app1/user`, `/app1/user/xx`）时，

就会激活子应用 app1,  子应用 app1 此时就会把 `/app1/user` 当作根路由（base 路由）地址，所以 `/app1/user/article` 对于子应用就如同 `/article`.

例子2：如果子应用 routes 配置 

```json
{ 
  path: '/', 
  components: '@/pages/User'
}
```



则主应用访问 `http://localhost:8000/app1/user` 时，就相当于访问子应用的 `/` 路由，就会匹配到子应用组件 `@/pages/User`.

### 存储

通过主应用加载了子应用后，如果子应用的 localstorage 设置的 key 和主应用的 localstorage 设置的 key 一样，

则它们会按照覆盖规则（后使用覆盖先使用）相互覆盖（localstorage 已经试过了，料想 cookie, session 也是一样，因为主应用和子应用都在同一个域名）

## Bilii 微前端流程

- 主应用通过 `@\layouts\basicLayout.tsx- Link`  显示左侧菜单并切换路由（进入子应用）

- 点击对应菜单，切换路由（切换浏览器地址），路由 url 来源：
  dev: `@\layouts\menu.config.tsx - menus`
  prod:  `@\layouts\basicLayout.tsx - getMenu()`
  路由 url 例如：`/default-base/personnel/attendance`

- 如果主路由切换到地址  `/default-base/personnel/attendance`，则此地址实际分为两部分：

  a. 主应用配置微应用时的 path 地址：`/default-base/personnel`，由 `/routes.ts - path`  配置
  b. 子应用需要匹配的路由地址：减去主地址的那份 -> `/attendance`

  即：以上地址将会匹配对用子应用路由地址：`/attendance` 

- 匹配到子应用对应路由并拿到组件后，qiankun 自动会将子应用的组件插入到主应用对应的容器（插槽）中。

## FAQ

- request() 基本地址
  通过 [@umijs/plugin-request](https://v3.umijs.org/zh-CN/plugins/plugin-request#requestinterceptors) 提供的请求拦截机制添加：`@/app.ts - request`
  例子: ` /api/personnel/quited/request/redRemind`, `/authServer/user/code_role_menu?moduleId=5&system=1&grades=2`

  > TIP: 使用 `/xx`  时，浏览器在发送请求时会自动使用当前域名拼接在最左边，如当前域名为 `http://localhost:8000` 时，则请求地址为: `http://localhost:8000/xx`.

- 主应用路由 `/default-base/personl/attendance/deadline` 怎么变成 `/attendance/deadline` 
  参见: `快速开始 - 路由匹配`

- 已经知道主应用从哪里渲染子应用的布局容器（libii-content-wrapper），那此布局容器下的东西是怎么来的？
  `qiankun-micro-app-wrapper`, `qiankun-micro-app-container` 这 2 个属于 umi-plugin-qiankun 封装的: `@\.umi\plugin-qiankun\MicroApp.tsx - microAppWrapperClassName 和 microAppClassName`

- 子应用插入的容器在哪里定义的？

  ​	a. [qiankun](https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles): 在主应用通过 [registerMicroApps - container](https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles) 方法注册微应用的同时，使用 container 字段为微应用指定要加载的容器。
  ​	b. [@umijs/plugin-qiankun](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97): 在 `src/app.ts - qiankun - apps` 中，对 apps 数组的每一项值（微应用）可以单独配置容器 -> [plugin-qiankun-关联微应用](https://v3.umijs.org/zh-CN/plugins/plugin-qiankun#%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97). 

  ​	这是因为 umi 对其进行了封装，你可以在 `@\.umi\plugin-qiankun\masterRuntimePlugin.ts -registerMicroApps `  查看

  > TIP: container 配置是可选的，使用  microApp 代替。

- 主应用对子应用进行注册 - 入口配置
  -> 是为了当主应用嵌入子应用时, 能正确从对应的入口地址(url) 寻找匹配的子应用的资源(javaScript, css, 图片等);

- 主应用和子应用的配置相互独立
  当通过主应用加载子应用时, 子应用使用的配置是自己的, 比如:

  -> 子应用对请求(请求头, 延迟时间, `credentials` 等) 的一些配置, 即使请求地址的根是主应用的, 但是这些配置仍然会使用子应用的配置, 而不是主应用的配置.

  -> 即使子应用什么都没配置, 也不会应用主应用的配置, 因为它们两个是独立的, 
  -> 不过是由于子应用使用了根路径(`/xx/xx`), 而导致子应用会应用主应用的根地址罢了, 如果独立启动子应用, 那么此时的 API 地址就是子应用的根地址.