```html
<script>
  function execPolyfill() {

    (function () {
      // CustomElementsV1.min.js v1 polyfill from https://github.com/webcomponents/webcomponentsjs/tree/v1/src/CustomElements/v1.
      /*
       Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
       This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
       The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
       The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
       Code distributed by Google as part of the polymer project is also
       subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
      */
      'use strict'; (function () {
        function q(a) { return l.test(a) && -1 === r.indexOf(a) } function e() { this.a = new Map; this.l = new Map; this.o = new Map; this.m = new Set; this.D = new MutationObserver(this.F.bind(this)); this.f = null; this.L = !0; this.h = !1; this.g(document) } var g = document, f = window, r = "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "), l = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/; e.prototype = {
          J: function (a, b) {
            function c(a) {
              var b = m[a]; if (void 0 !== b &&
                "function" !== typeof b) throw Error(d + " '" + a + "' is not a Function"); return b
            } a = a.toString().toLowerCase(); if ("function" !== typeof b) throw new TypeError("constructor must be a Constructor"); if (!q(a)) throw new SyntaxError("The element name '" + a + "' is not valid."); if (this.a.has(a)) throw Error("An element with name '" + a + "' is already defined"); if (this.l.has(b)) throw Error("Definition failed for '" + a + "': The constructor is already used."); var d = a, m = b.prototype; if ("object" !== typeof m) throw new TypeError("Definition failed for '" +
              a + "': constructor.prototype must be an object"); var e = c("connectedCallback"), f = c("disconnectedCallback"), h = c("attributeChangedCallback"); this.a.set(d, { name: a, localName: d, constructor: b, w: e, A: f, v: h, K: b.observedAttributes || [] }); this.l.set(b, d); this.b(g.childNodes); if (e = this.o.get(d)) e.resolve(void 0), this.o.delete(d)
          }, get: function (a) { return (a = this.a.get(a)) ? a.constructor : void 0 }, M: function (a) {
            if (!l.test(a)) return Promise.reject(new SyntaxError("The element name '" + a + "' is not valid.")); if (this.a.has(a)) return Promise.resolve();
            var b = { B: null }; b.B = new Promise(function (a) { b.resolve = a }); this.o.set(a, b); return b.B
          }, C: function () { this.h && (console.warn("flush!!!"), this.m.forEach(function (a) { this.s(a.takeRecords()) }, this)) }, H: function (a) { this.f = a }, g: function (a) { a.c = new MutationObserver(this.s.bind(this)); a.c.observe(a, { childList: !0, subtree: !0 }); this.h && this.m.add(a.c) }, I: function (a) { a.c && (a.c.disconnect(), a.c = null, this.h && this.m.delete(a.c)) }, s: function (a) {
            for (var b = 0; b < a.length; b++) {
              var c = a[b]; "childList" === c.type && (this.b(c.addedNodes),
                this.G(c.removedNodes))
            }
          }, b: function (a) {
            for (var b = 0; b < a.length; b++) {
              var c = a[b]; if (c.nodeType === Node.ELEMENT_NODE) {
                this.I(c); c = g.createTreeWalker(c, NodeFilter.SHOW_ELEMENT, null, !1); do {
                  var d = c.currentNode, e = this.a.get(d.localName); e && (d.j || this.u(d, e, !0), d.j && !d.i && (d.i = !0, e && e.w && e.w.call(d))); d.shadowRoot && this.b(d.shadowRoot.childNodes); if ("LINK" === d.tagName) {
                    var f = function () { var a = d; return function () { a.removeEventListener("load", f); this.g(a.import); this.b(a.import.childNodes) }.bind(this) }.call(this);
                    d.import ? f() : d.addEventListener("load", f)
                  }
                } while (c.nextNode())
              }
            }
          }, G: function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; if (c.nodeType === Node.ELEMENT_NODE) { this.g(c); c = g.createTreeWalker(c, NodeFilter.SHOW_ELEMENT, null, !1); do { var d = c.currentNode; if (d.j && d.i) { d.i = !1; var e = this.a.get(d.localName); e && e.A && e.A.call(d) } } while (c.nextNode()) } } }, u: function (a, b, c) {
            a.__proto__ = b.constructor.prototype; c && (this.H(a), a.j = !0, new b.constructor, console.assert(null == this.f)); c = b.K; if (b.v && 0 < c.length) for (this.D.observe(a,
              { attributes: !0, attributeOldValue: !0, attributeFilter: c }), b = 0; b < c.length; b++) { var d = c[b]; if (a.hasAttribute(d)) { var e = a.getAttribute(d); a.v(d, null, e) } }
          }, F: function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; if ("attributes" === c.type) { var d = c.attributeName, e = c.oldValue, f = c.target, g = f.getAttribute(d); f.attributeChangedCallback(d, e, g, c.attributeNamespace) } } }
        }; window.CustomElementsRegistry = e; e.prototype.define = e.prototype.J; e.prototype.get = e.prototype.get; e.prototype.whenDefined = e.prototype.M; e.prototype.flush =
          e.prototype.C; e.prototype.polyfilled = e.prototype.L; e.prototype.enableFlush = e.prototype.h; var h = f.HTMLElement; f.HTMLElement = function () { var a = f.customElements; if (a.f) { var b = a.f; a.f = null; return b } if (this.constructor) return a = a.l.get(this.constructor), g.b(a, !1); throw Error("unknown constructor. Did you call customElements.define()?"); }; f.HTMLElement.prototype = Object.create(h.prototype); Object.defineProperty(f.HTMLElement.prototype, "constructor", { value: f.HTMLElement }); for (var h = "Button Canvas Data Head Mod TableCell TableCol Anchor Area Base Body BR DataList Details Dialog Div DList Embed FieldSet Form Heading HR Html IFrame Image Input Keygen Label Legend LI Link Map Media Menu MenuItem Meta Meter Object OList OptGroup Option Output Paragraph Param Picture Pre Progress Quote Script Select Slot Source Span Style TableCaption Table TableRow TableSection Template TextArea Time Title Track UList Unknown".split(" "),
            k = 0; k < h.length; k++) { var n = window["HTML" + h[k] + "Element"]; n && (n.prototype.__proto__ = f.HTMLElement.prototype) } var t = g.createElement; g.b = function (a, b) { var c = f.customElements, d = t.call(g, a), e = c.a.get(a.toLowerCase()); e && c.u(d, e, b); c.g(d); return d }; g.createElement = function (a) { return g.b(a, !0) }; var u = g.createElementNS; g.createElementNS = function (a, b) { return "http://www.w3.org/1999/xhtml" === a ? g.createElement(b) : u.call(document, a, b) }; var p = Element.prototype.attachShadow; p && Object.defineProperty(Element.prototype,
              "attachShadow", { value: function (a) { a = p.call(this, a); f.customElements.g(a); return a } }); window.customElements = new e
      })();
    }).call(this)
  }

  // Remove check when https://github.com/webcomponents/webcomponentsjs/issues/548 is fixed.
  if (!!!window.customElements) {
    execPolyfill();
  }
  // 该脚本是用来兼容不支持window.customElements属性的脚本, 可以忽略.
</script>
<!-- ------------------------------------------------ ->
<style>
  a {
    background-color: rgb(190, 194, 193);
  }
</style>

<fancy-tabs background>

  <!-- 将这三个按钮放入一个具有name='title'的slot元素中 -->
  <button slot="title" selected>Tab 1</button>
  <button slot="title">Tab 2</button>
  <button slot="title">Tab 3</button>

  <!-- 将这三个章节的引用放入不存在name属性的slot元素中 -->
  <section>content panel 1</section>
  <section>content panel 2</section>
  <section>content panel 3</section>
</fancy-tabs>

<!-- Using <a> instead of h2 still works! -->
<!-- <fancy-tabs background>
  <a slot="title">Title 1</a>
  <a slot="title" selected>Title 2</a>
  <a slot="title">Title 3</a>
  <section>content panel 1</section>
  <section>content panel 2</section>
  <section>content panel 3</section>
</fancy-tabs> -->

<script>
  // 立即执行函数
  (function () {
    'use strict';

    // Feature detect 特征检测,也是兼容性判断,可以暂不考虑
    if (!(window.customElements && document.body.attachShadow)) {
      document.querySelector('fancy-tabs').innerHTML = "<b>Your browser doesn't support Shadow DOM and Custom Elements v1.</b>";
      return;
    }

    let selected_ = null;

    // See https://www.w3.org/TR/wai-aria-practices-1.1/#tabpanel

    customElements.define('fancy-tabs', class extends HTMLElement {

      constructor() {
        super();

        // Create shadow DOM for the component.
        let shadowRoot = this.attachShadow({ mode: 'open' });
        // 为shadow DOM添加style
        shadowRoot.innerHTML =
          `
          <style>
            /** 选择当前 shadow host */
            :host {
              display: inline-block;
              width: 650px;
              font-family: 'Roboto Slab';
              contain: content;
            }
            /** 选择具有background属性的 shadow host */
            :host([background]) {
              background-color: var(--background-color, #9E9E9E);
              border-radius: 10px;
              padding: 10px;
            }
            #panels {
              box-shadow: 0 2px 2px rgba(0, 0, 0, .3);
              background: white;
              border-radius: 3px;
              padding: 16px;
              height: 250px;
              overflow: auto;
            }
            #tabs {
              display: inline-flex;
              -webkit-user-select: none;
              user-select: none;
            }
            #tabs slot {
              display: inline-flex; /* Safari bug. Treats <slot> as a parent */
            }

            /** 
              当前shadow host: 选择id=tabs的元素下的 slot元素中所有的子项
                Safari不支持::sloted上的#id前缀
                See https://bugs.webkit.org/show_bug.cgi?id=160538 
            */
            #tabs ::slotted(*) {
              font: 400 16px/22px 'Roboto';
              padding: 16px 8px;
              margin: 0;
              text-align: center;
              width: 100px;
              text-overflow: ellipsis;
              white-space: nowrap;
              overflow: hidden;
              cursor: pointer;
              border-top-left-radius: 3px;
              border-top-right-radius: 3px;
              background: linear-gradient(#fafafa, #eee);
              border: none; /* if the user users a <button> */
            }

            /** 当前shadow host: 选择id=tabs的元素下的 slot元素中 具有aria-selected="true" 的元素 */
            #tabs ::slotted([aria-selected="true"]) {
              font-weight: 600;
              background: #eefae7;
              box-shadow: none;
            }

            /** 当前shadow host: 选择id=tabs的元素下的 slot元素中 具有focus伪类 的元素 */
            #tabs ::slotted(:focus) {
              /* 确保选中的button元素不会被覆盖 */
              z-index: 1; /* make sure focus ring doesn't get buried */
            }

            /** 当前shadow host: 选择id=panels的元素下的 slot元素中 具有aria-hidden="true" 的元素 */
            #panels ::slotted([aria-hidden="true"]) {
              /* 
                在id=panels的元素下的 slot元素中,将具有 aria-hidden="true"属性和值的 元素的display设置为none
                即让它们不显示.
                没有被选中的section元素,则display为默认值(通常是block)
              */
              display: none;
            }
          </style>


          <div id="tabs">
            <slot id="tabsSlot" name="title"></slot>
          </div>

          <div id="panels">
            <slot id="panelsSlot"></slot>
          </div>
      `;
      }

      get selected() {
        return selected_;
      }
      set selected(idx) {
        // selected_ 默认值为null;
        // idx是当前用户单击的button按钮的索引(每个button元素都存与tabs数组中)
        selected_ = idx;

        // 调用当前节点对象的_selectTab方法
        this._selectTab(idx);

        // Updated the element's selected attribute value when
        // backing property changes.
        // 设置当前节点对象的selected,值未idx
        // PS:由于selected支持的是一个布尔值,所以只要idx(数字)非0,那么就设置当前元素具有selected属性.
        this.setAttribute('selected', idx);
      }

      // 存放于Prototype中的connectedCallback() 连接的回调
      // 该函数是一个生命周期钩子函数,当一个自定义元素被插入文档(DOM)时,该回调函数就会(准备)执行,因为还要执行constructor.
      connectedCallback() {
        // 设置当前节点对象的属性
        this.setAttribute('role', 'tablist');

        // 查找当前节点对象(自定义元素)的shadowRoot中,id为tabsSlot和panelsSlot的元素.
        const tabsSlot = this.shadowRoot.querySelector('#tabsSlot');
        const panelsSlot = this.shadowRoot.querySelector('#panelsSlot');

        /** 
        返回分配给插槽的节点序列数组,且任何其他插槽的分配节点都会是这个插槽的后代。
          即将指定的slot元素中的所有light DOM元素 (如果没有light DOM,则返回slot元素中的备用内容)
          的名称依次放入一个新数组最后返回这个数组
        */
        this.tabs = tabsSlot.assignedNodes({ flatten: true });
        // 将存放light DOM元素名称的数组每个索引值放入指定函数运行,
        // 最后将所有通过检测的索引值依次存放进一个新数组,并返回该数组.
        this.panels = panelsSlot.assignedNodes({ flatten: true }).filter(el => {
          // 如果当前light DOM节点的类型 是一个元素节点,如<div>,<p>这种的,就将该索引值放入新数组
          return el.nodeType === Node.ELEMENT_NODE;
        });

        /** 
          将aria role="tabpanel"添加到每个内容面板。
          返回panels数组的迭代器对象,包含数组中每个索引的 键/值对
          为每个section元素都添加role和tabindex属性 
        */
        for (let [i, panel] of this.panels.entries()) {
          panel.setAttribute('role', 'tabpanel');
          panel.setAttribute('tabindex', 0);
        }

        // 克隆_onTitleClick和_onKeyDown函数,并将克隆的函数中的this指向改为指定的this(fancy-tabs)
        this._boundOnTitleClick = this._onTitleClick.bind(this);
        this._boundOnKeyDown = this._onKeyDown.bind(this);
        /** 
          监听shadow DOM中,id=tabSlot的slot元素的 click事件和keydown事件
          当这两个事件被触发时,就调用_boundOnTitleClick()和_boundOnKeyDown函数.
        */
        tabsSlot.addEventListener('click', this._boundOnTitleClick);
        tabsSlot.addEventListener('keydown', this._boundOnKeyDown);

        /** 
        先调用_findFirstSelectedTab()方法获取其返回值, 如果为true该语句的值就是它,反之是0;
        再调用selected对象访问器,并将右边的值作为参数传递给selected伪属性
          PS:对象访问器是一伪属性,需要用属性的调用方式去调用它,如果要为set传值,也仍然是以属性的方式,即以下的方式.
        */
        this.selected = this._findFirstSelectedTab() || 0;
      }

      // 自定义元素被删除时,执行该生命周期钩子函数. 
      // 它在这这里的作用移除事件监听器,防止handler占用内存
      disconnectedCallback() {
        // 查找当前节点对象的shadowRoot中,id为tabsSlot的元素并移除它的click和keydown监听器和对应的函数
        const tabsSlot = this.shadowRoot.querySelector('#tabsSlot');
        tabsSlot.removeEventListener('click', this._boundOnTitleClick);
        tabsSlot.removeEventListener('keydown', this._boundOnKeyDown);
      }

      // 点击tabsSlot元素中的button时,会触发click事件,而click事件会执行该函数
      _onTitleClick(e) {
        /**
        意思为:当前触发事件的DOM元素,它的slots属性 是否 === title
          e.target: 返回触发当前事件e的 DOM元素的引用(可以认为就是DOM节点对象本身)
          elements.slot: 返回指定的元素的slot属性的值
        这个目的是为了防止在事件冒泡过程中,导致e.target的父元素又执行一遍if语句里面的操作(如果没有这个if语句的话,就可能会发生这种事)
          
        */
        if (e.target.slot === 'title') {
          /**  
          在tabs数组中查找当前触发事件的DOM元素的引用第一次出现的索引位置 
          并将索引值作为参数传递给selected伪属性(并调用该伪属性)
            tabs:一个数组,其值为: id=tabsSlot的slot元素中的每个light DOM引用 对应的名称
          */
          this.selected = this.tabs.indexOf(e.target);
          /** 
          使当前触发事件的DOM元素的引用获得焦点(); 
            HTMLElement.focus()方法可以设置指定元素获取焦点。
          */
          e.target.focus();
        }
      }

      // 按下键 上下左右键\
      _onKeyDown(e) {
        // 返回一个键盘上的物理键,与按键生成的字符相对(coede是一个DOM接口:KeyboardEvent.code)
        switch (e.code) {
          // 按上 == 按左
          case 'ArrowUp':
          case 'ArrowLeft':
            // 移除当前ArrowLeft事件的默认行为
            e.preventDefault();
            // 调用selected伪属性(getter),得到selected_的值 -1 =>
            // 当前被选中的button在tabs数组(存放所有button元素引用的数组,从左→右,依次存放)中的索引值
            var idx = this.selected - 1;

            // 如果当前被选中的button是第1个,则用户按下左键时,就将当前选中的button的索引设置为 最后一个.(在这里是第三个)
            // 反之仍然是this.selected - 1;
            // 即用户按下左键,第三个button就会跳转到第二个, 第2个->第1个,第1个->第3个
            idx = idx < 0 ? this.tabs.length - 1 : idx;
            // 为已经跳转后的button模拟一个单击事件,即用户按下左键如同触发idx索引值对应的button的click事件
            this.tabs[idx].click();
            break;
          // 按下 == 按右  
          case 'ArrowDown':
          case 'ArrowRight':
            e.preventDefault();
            // 获取当前被选中的button在tabs数组中的索引,并+1
            // 这样,当按下右键上,当前button在第1个位置上=> idx=0+1,第2个位置=>1+1,第3个位置=>2+1
            var idx = this.selected + 1;
            console.log(idx)
            // 当前button的索引值为0(第一个按钮),则用户按下右键时,就选中0+1%3=1,即第2个按钮(数组下标从0开始)
            // 当前button的索引值为1(第二个按钮),则用户按下右键时,就选中1+1%3=2,即第3个按钮(数组下标从0开始)
            // 当前button的索引值为2(第三个按钮),则用户按下右键时,就选中2+1%3=0,即第1个按钮(数组下标从0开始)
            // 且每一次按下右键时,都如同单击一次idx值对应的button
            this.tabs[idx % this.tabs.length].click();
            break;
          // 其他情况由浏览器自行决定
          default:
            break;
        }
      }

      // 私有方法:查找第一个选定的制表符
      _findFirstSelectedTab() {
        let selectedIdx;

        /** 
        this.tabs.entries()
          tabs:id=tabsSlot的slot元素中 所有的light DOM节点名称 组成的一个数组.
          =>返回tabs数组的一个迭代器

        整个语句的意思
          迭代tabs数组的迭代器对象,将数组的key和value分别赋值给i和tab变量
        */
        for (let [i, tab] of this.tabs.entries()) {
          /** 
            为 [id=tabsSlot的]slot元素中的每个light DOM元素添加role属性,值为tab
              PS:role属性对屏幕阅读器这种是友好的,它是帮助视力障碍的人和浏览器理解该元素的作用的
              具有role属性的元素必须具有该角色(role=tab)的所有必需属性,如tablist,否则role属性就没有意义了
              参见:https://juejin.im/entry/59edc54a5188255d910ca4f4
          */
          tab.setAttribute('role', 'tab');

          /** 
            若当前元素具有selected属性,则将当前元素所在的tabs数组中对应的索引值赋值给selectedIdx变量
            i = 0,1,2
            
          */
          if (tab.hasAttribute('selected')) {
            selectedIdx = i;
          }
        }
        return selectedIdx;
      }

      // 接收一个值idx,并设置在它的值===undefined时的默认值为null
      _selectTab(idx = null) {
        /** 
        该for循环用来判断当前选中第几个按钮,并将未选中的按钮 对应的section元素(面板)的aria-hidden设置为ture,
        即:隐藏未选中的button按钮 对应的面板(这个效果是通过预设元素的CSS样式实现的)
        => 若[aria-hidden=ture],那么display:none,反之display:block;
          定义两个变量:i和tab;
          tabs数组里面存放的是3个button按钮
          将tabs数组(id=tabsSlot的slot元素中的每个light DOM元素名称所组成的一个数组)的第i个值赋值给tab变量
        */
        for (let i = 0, tab; tab = this.tabs[i]; ++i) {
          /** 
          若当前在id=tabsSlot的slot元素的light DOM元素的名称组成的数组中的 
          元素具有selected属性,将该元素的索引和i变量去比较是否严格相等,
          若严格相等,则返回true赋值给select,否则返回false赋值给 select
            idx: 在id=tabsSlot的slot元素中的 light DOM元素的名称组成的数组中 具有selected属性的(button)元素的 索引值
              详见: _findFirstSelectedTab()方法中的if (tab.hasAttribute('selected')) 语句.
              就是因为该if语句判断当前button元素是否具有selected属性,然后会将具有selected属性的button元素在数组
              中的对应索引赋值给selectedIdx,而这个selectedIdx的值就是这里的idx值
              其调用链为:
                this.selected=selectedIdx -> set select(idx) ->  _selectTab(idx=null)
                                         idx参数接受selectedIdx   idx参数接受set select(idx)中的idx参数
                                                                 _selectTab()就是本函数了,而idx 也就等于 selectedIdx
                                                                  即:idx= 当前具有selected属性的button元素在 数组中的索引
          */
          let select = i === idx;
          /** 
          设置当前元素的属性:tabindex; tabindex的值: 若select为true则值为0, select为false则值为-1
            0:表示元素应通过顺序键盘导航可聚焦和可到达，但其相对顺序由平台约定定义;
            -1:表示该元素应该是可聚焦的，但不应通过顺序键盘导航到达;
            正值意味着元素应该可以通过顺序键盘导航进行聚焦和访问;元素聚焦的顺序是tabindex的增加值+
            +如果多个元素共享相同的tabindex，则它们的相对顺序遵循它们在文档中的相对位置。
          */
          tab.setAttribute('tabindex', select ? 0 : -1);
          // 为当前元素设置aria-selected属性,其值为:true/false
          tab.setAttribute('aria-selected', select);
          // 为 id=panelsSlot的 slot元素中的第i个light DOM元素设置aria-hidden属性,其值为!true / !false
          // panels[]: 一个数组. id=panelsSlot的 slot元素中的 light DOM 元素名称经过 过滤之后 组成的一个数组
          this.panels[i].setAttribute('aria-hidden', !select);
        }
      }

    });

  })();
</script>
```

