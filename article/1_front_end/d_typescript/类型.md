# [基础类型](https://www.tslang.cn/docs/handbook/basic-types.html)

## 概念

为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。

 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型（和其他类型，如：void、never、any 等）方便我们使用。

以下的基础类型（除 enum，类型断言）都是用来对 JavaScript 代码进行一种限制，即：对变量、方法、对象等进行限制。

当开发者使用限制类型限制一个变量、方法、对象（等）时，如果开发者赋予的**不是限制类型 限制的值的类型**，则使用后缀名 .ts 的文件会在编译时就报错误。

这是 TypeScirpt 提供的**静态分析**分析功能，如同在常规 JS 文件书写了一个语法错误，然后编译器提示错误这样的功能。

注：TypeScript 提供的语法分析功能检查到的错误并不影响开发者使用 `tsc fileName.ts` 命令去编译 fileName.ts 为 fileName.js，即使它的错误是语法错误，`tsc` 命令的编译功能也会强行的将 fileName.ts 文件编译成 fileName.js 文件，只不过编译后的 fileName.js 文件还是会报错。

## 基础类型

### 布尔值 boolean

最基本的数据类型就是简单的 true/false 值，在 JavaScript 和 TypeScript 里叫做`boolean`（其它语言中也一样）。

```typescript
// 为 isDone 变量限制类型只能为：boolean 类型
let isDone: boolean = false;
```

### 数字 number

和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 

这些浮点数的类型是 `number`。 

且 TypeSCript 除了支持十进制和十六进制字面量，还支持 ECMAScript 2015 中引入的二进制和八进制字面量。

```typescript
// 为以下变量限制类型只能为：number
let decLiteral: number = 6;、
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
```

### 字符串 string

JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 

像其它语言里一样，我们使用 `string`表示文本数据类型。 

和 JavaScript 一样，可以使用双引号（ ""）或单引号（''）表示字符串，也能使用模板字符串为限制类型为 string 的变量赋值。

```typescript
// 限制 name 变量类型只能为：string
let name: string = 'Yomua'
let age: number = 21
let sentence: string;
// 使用模板字符串的方式为限制 string 类型的变量赋值
sentence = `I'll be ${ age + 1 } years old next month.`
```

### 数组 Array\<指定的类型> | 指定的类型[ ]

TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数

**两种方式可以定义数组**。 

1. 第一种，可以在**元素类型**（如：number、boolean、string 等）**后面接上** `[]`，表示由此限制类型组成的一个数组：

   ```ts
   // 限制 list 变量只能是一个数组，且索引值必为 number
   let list: number[] = [1,2,3]
   ```

2. 第二种方式是使用**数组泛型**，`Array<元素类型>`：

   ```ts
   // 限制 list 只能是一个数组，且索引值必为 number
   let list: Array<number> = [1,2,3]
   ```

### [元组 Tuple [tʌpl]](https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple)

元组类型是用来**表示一个**已知【**元素数量**】和【**索引值类型**】，以及【**长度固定**】（TS 2.7（含）版本之后有的规则）的**数组**，其中索引值的类型不必全部相同，可以不同。

如，你可以定一个数组，并逐个限制该数组中的每个索引值的类型是什么：

```ts
let list:[string, number, boolean];
list[0] = 'yomua';
list[1] = 1;
// list[2] = 'name' // error，索引2的值的类型只能为 boolean 
list[2] = true;
```

并且，当你使用元组限制数组中索引值的类型，并且访问其中索引值对应的元素时，会得到正确的类型，即：**索引值对应的元素的类型是什么，那么你只能使用那个类型的属性/方法，而不能使用其他属性/方法**，如：

```js
// okay，输出：yomua
list[0].substring(0,5); 
// Error, 'number' does not have 'substring'
list[1].substring(1); 
```

注：[TypeScript 2.7](https://www.tslang.cn/docs/release-notes/typescript-2.7.html)（固定长度元组 一节中） **以后的版本中，元组将变成固定长度**，所以我们**无法**再利用联合类型去访问一个越界的元组元素，如以下在 TS 的语法分析中是错误的：

```ts
/**
 * 在 2.7 之前，元组并非固定长度，以下的赋值是正确的，因为 'yomua' 可以赋值给 (string|number|boolean) 其中一个类型。
 * 但在 2.7（及）之后，元组是固定长度，你创一个多大的元组，那么它就是多大，无法再进行越界赋值，即使联合类型中有存在你赋的值的类型也是一样
 */
list[3] = 'yomua'
```

注：在 JS 中，数组并不存在什么越界赋值，所以 TS 2.7（及）版本后的元组，相当于必 2.6（及）版本之后的元组多了一个限制：固定长度。

 2.7（及）版本后的元素有三个限制：**表示已知【元素数量】和【索引值类型】，且【长度固定】的数组。**

你可以参见：***[英文文档](https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple)***

```js
// JS 中的数组赋值时，通常不存在越界
let arr = [];
arr[999] = 1000
/**
[
    empty,
    ...,
    empty,
    999:1000
]
 */
console.log(arr); // 
```

### [文字类型](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)

类型可以是 '文字'。

```typescript
const constantString = "Hello World"; 
type constantString = 'Hello World'

let changingString = "Hello World";
type changingString = string
```

### any

限制类型：any。

有时候，我们会想要为那些在编程阶段还**不清楚类型的变量指定一个类型**，二这些变量可能来自于动态的内容，比如来自用户输入或第三方代码库。 

这种情况下，我们不希望类型检查器对这些值进行检查而是**直接让它们通过编译阶段的检查**，否则 TS 的语法分析可能会直接进行报错，所以我们可以使用 `any`类型来标记这些变量：

```ts
// 将 otherVariable 变量限制为 any 类型
let otherVariable: any = 4
otherVariable = "maybe a string instead"; // okay
otherVariable = false; // okay
```

any 类型的变量可以被赋予任何类型的值，这样一看，好像 Object 类型也有类似作用，但是 **`Object` 类型*（注意：Object 限制类型和 object 限制类型是不同的，详见：Object 和 object 一节）*的变量只是允许你给它赋任意类型的值，却不能够在它上面调用任意的方法**，即便它真的有这些方法：

```js
let prettySure: Object = 4;
// Error: Property 'toFixed' doesn't exist on type 'Object'.
prettySure.toFixed(); 
```

以下是 any 类型的特点：

1. any 类型变量可以**被赋值**为任何类型数据

2. any 类型数据可以**赋值给**除 never 类型之外的任何数据类型变量：

   ```ts
   let anyValue: any = 8;
   let str:string;
   // 将 any 类型的变量赋值给 string 类型的变量
   str = anyValue;
   ```

   ```ts
   // any 类型的变量赋值给 never 类型的变量会提示错误
   let any: any = 6
   let never: never;
   never = any;
   ```

   ![](/picture/any 类型的变量可以赋值给除 never 之外的任何数据类型.png)

   （any 类型的变量可以赋值给除 never 之外的任何数据类型）

3. 如果数据是 any 类型，那么可以访问它的任意属性（即便是不存在）:

   ```ts
   let list: any[] = [1, true, "free"];
   list[1] = 100;
   list[1].dd() // 不会报错，但是若是Object[]则会报错
   ```

   以下的提示框的 `any` 指的是 dd() 方法属于 any 类型的数据。

   ![](/picture/可以访问 any 类型的数据的任意属性或方法，即便它不存在.png)

   （可以访问 any 类型的数据的任意属性或方法，即便它不存在）

4. **any 类型对象任意属性值都是 any 类型，即使其属性不存在也是。**

   ```ts
   interface T {
       a: boolean,
       b: string,
       /**
        * 字符串索引签名，
        在 接口（interface） 一节中会讲到。
        * 目的是：使得使用该接口作为限制类型的变量可以使用任意数量的其他属性，其属性值也是任意类型。
        */
       [propName: string]: any,

   }

   let obj: T = {
       a: true,
       b: "yomua",
       func: function () { }
   }
   /**
    * 一开始 obj 限制为 T 的类型，
      但是这里我们断言为 any 类型，
      那么 obj中的 a、b、func 属性将也成为 any 类型
      即使访问 obj 中不存在的属性也是 any 类型
    */
   (obj as any).a // a 为 any 类型
   (obj as any).b // b 为 any 类型
   (obj as any).func // func 为 any 类型
   (obj as any).xxxxx // xxxxx 为 any 类型
   ```

5. **any 类型数据可以当做函数或者构造函数调用**，**可以有任意参数**（只要不超过最大的 255 个参数即可）

   ```ts
   let anyValue: any = 8;
   anyValue(1,2,3,4,...,255);
   ```

6. 若**没有明确限制变量的数据类型且 TS 的编译器无法推断，则变量将被视为 any 类型**。

   ```ts
   // 限制 obj 的数据类型为 {a,b}
   let obj: { a,b }

   /** 等同于下面的代码 */
   let obj: { 
     a:any,
     b:any
   }
   ```

   成员变量 a 隐式具有 any 类型，但可以从用法推断出更好的类型。

   ![](/picture/若没有明确限制变量的数据类型且 TS 的编译器无法推断，则变量将被视为 any 类型.png)

   （若没有明确限制变量的数据类型且 TS 的编译器无法推断，则变量将被视为 any 类型）

### 未知 unknown

#### 概念

在 <a href='#any'>any</a> 一节中，我们讲到了 any 类型，该类型有许多特点，在本节中，我们准备要说到的 unknown 类型和 any 类型有些相似，也有些不同。

可以这么说：unknown 类型是 any 类型的安全版，每当你想用any时，不妨试着先用 unknown。

这是因为它们二者的性质所定的：使用 unknown 可以保证类型安全，使用 any 则彻底放弃了类型检查，你可以点这看看  <a href='#any'>any</a>  特性。

那么 unknown 什么时候使用呢，这也和 any 类似，即：我们在编写程序时需要描述某些不知道的变量类型，这些值可能来自动态内容（例如，来自用户），或者我们可能希望有意接受 API 中的所有值，

所以此时我们需要有一个类型来告诉编译器和将来的开发者这个变量可以是任何类型，因此我们为变量限制为： `unknown` 类型；虽然 any 类型也能做到如此，但是就如同我刚才说的那样：限制类型为 any 的变量代表彻底放弃了类型检查。

而使用 unknown 去限制某个变量的类型，我们可以通过特殊的方式，去约束 unknown，使得 TS 知道 unknown 在某种情况下是什么类型，***详见：<a href='#约束 unknown 类型的变量'>约束 unknown 类型的变量</a>***

#### any 和 unknown

any 和 unknown 在 TypeScript 中是所谓的“顶部类型”，即：any 和 unknown 是包含所有值的类型。

以下文字引用自 Wikipedia：

> *top type* [...]是 *通用（universal）* 类型，有时也称为 *通用超类型*，因为在任何给定类型系统中，所有其他类型都是子类型[...]。
>
> 通常，类型是包含了其相关类型系统中所有可能的[值]的类型。

也就是说，当把类型看作是值的集合时，any 和 unknown 是包含所有值的集合。顺便说一句，TypeScript 还有 *bottom type（底部类型)：* <a href='#never'>never</a>，它是空集。

那么 any 和 unknown 类型的区别是什么呢？即：any 会完全放弃 TS 的类型检查，而 unknown 可以通过特殊的方式去约束使用 unknown 作为类型的变量的类型，使得 unknown 类型在某种情况下是已知。

所以，在使用 any 类型前，不妨先试试 unknown.

#### 示例

##### 限制类型为 unknown 的变量可以赋予任何类型的值

```ts
let notSure: unknown = 4;
notSure = "maybe a string instead"; // okay
notSure = false; // okay
```

##### 约束 unknown 类型的变量

```ts
let notSure: unknown = 4;
if (notSure === true) {
    //这个作用域中，typescript 知道 notSure 变量为 true
    const aBoolean: boolean = notSure; // okay
    // 所以，我们不能将 notSure 赋值给一个非 boolean 类型的值
    const aString: string = notSure; // error
}
```

注：约束 unknown 类型的变量有很多种方式，这只是其中之一罢了。

### Object&any 和 object

#### Obejct & any

在 <a href='#any'>any</a> 一小节中我们说过：any 类型和 Object 类型有些相似，但是又有不同

- **any 类型的变量可以赋给任何除 never 以外的其他类型**的变量

  也可以将**其他类型的值（包括 never）赋值给 any 类型**的变量

  且开发者**可以访问 any 类型的值的任意方法/属性，即使它不存在也一样可以访问**（ts 编译器并不会提示错误，但运行时可能会报错）

  ```ts
  let anyVar: any, str: string;
  str = anyVar // okay
  anyVar = string | number | boolean | never ...
  anyVar.a | .func // okay，不存在 TS 编译器也不报错
  ```

- Object 类型的变量只可以**接受任何其他类型的值（包括 never）**

  但并不能将 Object 类型的变量赋值给除 Object 类型的变量，这是因为其他类型的变量通常只能接受属于自己类型的值（除了 any）

  **Object 类型的变量不能在它上面调用任意方法，只能调用 Object.prototype 上的方法/属性**（any 类型可以）

  ```ts
  let objVar: Object , str: string
  ObjVar = string | number | boolean | never ...
  ObjVar = str // okay
  str = ObjVar // 类型 Object 不能分配给类型 string

  Objvar = 1;
  Objvar.toFixed(); // Property 'toFixed' does not exist on type 'Object'
  ```

#### object

请注意：这里的 object 是小写的 object。

object 表示：非原始类型，也就是除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型

使用`object`类型，就可以更好的表示像`Object.create`这样的API。例如：

```ts
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

#### Object 和 object 类型的区别

使用限制类型 Object 和 object 是不一样的，它们限制的类型也不同：

```ts
let Obj:Object,obj:object,str:string
Obj = str; // okay
obj = str; // error，string 类型无法分配给 object 类型
```

也就是说，你可以认为 object 可以翻译为：限制变量的类型只能为对象，如：

```ts
// obj 变量只能为对象类型
let obj:object;
obj = {} // ok
obj = new Object() // ok
obj = 1 // error
obj = "string" // error
```

而 Object 则是表示对象类型为 Object，由于 Object 是所有类型原型链上的一层，所以开发者可以为限制类型为 Object 变量，赋任何值（包括 never 类型）

```ts
// Obj 变量可以赋任何值（包括 never 类型）
let Obj:Object, never:never
Obj = {} // ok
Obj = 1 // ok
Obj = "string" // ok
Obj = never // ok
```

### never

#### 概念

`never` 类型表示的是那些永不存在的值的类型，如：`never` 类型那些总是会【抛出异常】或根本就【不会有返回值】的**函数表达式或箭头函数表达式**的返回值类型。

never 类型是任何类型的子类型，即：你可以将 never 类型的变量赋值给任何类型。但是有意思的是：没有类型（除了 never 类型）可以赋值给 never，即使是 any 类型也是一样，并且 never 类型不存在子类型。

以下是一些属于 never 类型的变量：

```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message); // 抛出异常
}

// 推断的返回值类型为 never，因为这就像抛出异常一样，是错误，无结果
function fail() {
    return error("Something failed"); // 返回错误
}

// 返回 never 的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) { // 永真（不存在结果）
    }
}
```

#### 作用

##### [可以用来确保函数对某个变量的结果已经做好了所有处理](https://www.zhihu.com/question/354601204/answer/888551021)

```ts
interface Foo {
  type: 'foo'
}

interface Bar {
  type: 'bar'
}

interface Baz {
    type: 'baz'
}

type All = Foo | Bar

function handleValue(val: All) {
  switch (val.type) {
    case 'foo':
      // 这里 val 被收窄为 Foo
      break
    case 'bar':
      // val 在这里是 Bar
      break
    default:
      // val 在这里是 never
      const exhaustiveCheck: never = val // 编译通过
      break
  }
}
```

- switch (val.type) {...}

  这里直接预测 val.type 的值可能是 'foo' 还是 'bar'

  注意：default 中的 val 的类型被 ts 编译器推断为 never，因为如果 defalut 中的 ` const exhaustiveCheck: never = val` 要**预编译通过的前提**是：

  ​    val.type 的值只可能为 'foo' 或 'bar'，但是前面两个 case 语句已经包揽了所有可能性，

  ​    所以 default 语句是永远不可能达到的，那么里面的 val 自然的被推断为 never 类型，也自然的能赋值给一个类型为 never 的变量

- default 语句

  那 default 语句既然不可能被执行，那么它的有什么作用呢？

  即：它是用来产生一个编译错误，你可以确保 **handleValue 函数总是穷尽 (exhaust) 了所有 All 的可能类型**。

  如：某天某人将 type All 的值更改为：Foo | Bar | Baz，但是没有更改 handleValue() 中的逻辑，ts 的语法分析就会在编译时，` const exhaustiveCheck: never = val` 语句就会报错。

  详见以下一点。

- type All = Foo | Bar 如果更改为，type All = Foo | Bar | Baz，`const exhaustiveCheck: never = val` 就会报错

  这是因为： 

  如果存在 Baz，但未更改 handleValue() 中的逻辑，则 handleValue() 中的 default 语句会被执行，

  但是由于我们已经**推断 default 语句是不可能被执行的** => **将 val 形参显式赋值给了一个 never 类型（只有不被执行的变量才会是 never 类型）**，所以将 val 赋值给一个 never 类型时，就会报错。

##### [写出类型绝对安全的代码](https://www.zhihu.com/question/354601204/answer/888668879)

其是以上的作用：*可以用来确保函数对某个变量的结果已经做好了所有处理* 和以下的用法是类似的，目的都是用来将类型做出所有处理，保证类型安全，不在后期被乱修改。

```ts
function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}
```

### null 和 undefined

TypeScript里，`undefined`和`null`两者各自有自己的类型分别叫做`undefined`和`null`。 和 `void`相似，它们的本身的类型用处不是很大：

```ts
// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
```

默认情况下 `null` 和 `undefined` 是所有类型的子类型，就是说你可以把 `null`和 `undefined` 赋值给除 never 类型之外的任何类型的变量。

然而，当你指定了`--strictNullChecks`标记，`null` 和 `undefined ` 只能赋值给 `void` 和它们各自。 

这能避免很多常见的问题。 也许在某处你想传入一个  `string`或 `null`或`undefined`，你可以使用联合类型 `string | null | undefined`。 

注：稍后我们会介绍联合类型。

> 注意：我们鼓励尽可能地使用 `--strictNullChecks`，但在本手册里我们假设这个标记是关闭的。

### void

某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。

 当一个函数没有返回值时（注：never 类型表示函数是不存在结果，即：压根没有返回值，连 void 返回值类型都无），你通常会见到其返回值类型是 `void`：

```ts
function warnUser(): void {
    console.log("This is my warning message");
}
```

声明一个`void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined`和 `null` 以及 void 类型的变量：

```ts
let unusable: void = undefined;
```

### 枚举 enum

`enum `类型是对 JavaScript 标准数据类型的一个补充，像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字，如：

```ts
// 创建一个 Color 对象作为枚举类型
enum Color {Red, Green, Blue}
// 并可以为 Color 对象中的属性赋予一个好听的名字
let c: Color = Color.Green;

/** 以上代码经过编译后的代码如下：*/
var Color;
(function (Color) {
    Color[Color["Red"] = 0] = "Red";
    Color[Color["Green"] = 1] = "Green";
    Color[Color["Pink"] = 2] = "Pink";
})(Color || (Color = {}));
var color = Color.Red;
```

显然的，我们可以通过查看经过编译后的枚举对象，发现：`enum Color {Red, Green, Blue}` 就相当于创建一个 Color 对象，然后为你在 Color 对象中写的属性分配值，默认是从 0 开始，依次往后排序。

并且同时进行双向分配，使得 Color 对象中存在使用你写的属性的【值作为的属性】，并且将【你写的属性的名字】作为值赋值给【你写的属性的值作为的属性】，如：`Color[0] = "Red";Color[1] = "Green" `

- ***Color[Color["Red"] = 0] = "Red"***

  为 Color 对象添加 【Color["Red"] = 0】 这个属性，并且值为 Red。

  Color["Red"] = 0 => 若 Color["Red"] === undefined，则为它赋予默认值 0，即，最后结果为：Color[0] = "Red"

  又由于 Color["Red"] = 0 是为 Color 对象创建了 Red 属性，且值为 0

   所以当运行以下第一行代码时，Color{} 中存在的值为：

  ```ts
  Color {
      0: Red,
      Red: 0,
  }
  ```

虽然默认情况下，枚举对象从 `0` 开始为元素编号，但是你也可以手动的为元素指定数值，例如：我们将上面的例子改成从 `1` 开始编号：

```ts
enum Color {Red = 1, Green, Blue}ts
let c: Color = Color.Green; // 2
let b: Color = Color.Blue; // 3

// 或者，全部都采用手动赋值：
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green; // 2
let b: Color = Color.Blue; // 4
```

枚举类型提供的另一个便利是你可以**由枚举的属性的值得到它的名字**：

 例如，我们知道枚举类型对象中的某个值的数值为 2，但是不确定它映射到 Color 里的哪个名字，那么我们可以通过使用 `对象名[数值（索引）]` 这种方式 找相应的名字：

```ts
enum Color {Red = 1, Green, Blue}
// 通过枚举对象中的属性的数值，查找对应的属性名
let colorName: string = Color[2];
console.log(colorName);  // 显示'Green'，因为上面代码里它的值是2
```

## 类型断言

有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。

此时，你可以通过**类型断言**这种方式可以告诉编译器：“相信我，我知道自己在干什么”。 

类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 

它没有运行时的影响，只是在编译阶段起作用，TypeScript 会假设你——程序员已经进行了必须的检查。

而类型断言通常用在：当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，开发者此时只能访问此联合类型的所有类型里共有的属性或方法，否则就会报错：

```ts
function GETLENGTH(something: string | number): number {
    // ERROR，这是因为 number 并不存在 length 属性。
    return something.length; 
}
```

但是有时，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法那么就需要使用类型断言，

即：断定某个联合类型的变量是哪个类型，这样 TypeScript 就会默认你已经做好了完全的准备，TypeScript 也会默认该联合类型的变量是你断言的那个类型，

下面让我们改一下以上的示例，让它通过 TypeScript 静态的语法分析：

```ts
function GETLENGTH(something: string | number): number {
    // okay，不会报错，断定 something 变量为 string 类型。
    return (something as string).length; 
}
```

类型断言有两种书写方式

1. 使用 `<>` 尖括号的语法

   ```ts
   let someValue: any = "this is a string";
   // 断言 someValue 为 string 类型
   let strLength: number = 
       (<string>someValue).length;
   ```

2. 使用 `as` 语法

   ```ts
   let someValue: any = "this is a string";
   // 断言 someValue 为 string 类型
   let strLength: number = 
       (someValue as string).length;
   ```

以上两种语法的形式是等价的，至于使用哪个大多数情况下是凭个人喜好。

但是**请注意**：当你在 TypeScript 里使用 [JSX](https://baike.baidu.com/item/JSX/1686693?fr=aladdin)（[JSX-React](https://react.docschina.org/docs/introducing-jsx.html)） 时，只有 `as `语法断言是被允许的。

# [EN](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types)-[CN](https://www.tslang.cn/docs/handbook/advanced-types.html)-联合类型 和 [EN](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types)-[CN](https://www.tslang.cn/docs/handbook/advanced-types.html)-交叉类型

## 联合类型

联合类型（Union Types）表示取值可以为多种类型中的一种：

```ts
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven'; // okay
myFavoriteNumber = 7; // okay
myFavoriteNumber = true; // error Type 'boolean' is not assignable to type 'string | number'
```

注意：使用联合类型去限制某个变量时，该变量至少要满足联合类型中的一种，**但是当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，TypeScript只能访问此联合类型的所有类型里共有的属性或方法，**

也就是说：如果 1 个变量属于联合类中的某 1 个，但是不属于另 1 个，此时 TypeScript 将报错：

```js
const getLength = (something: string| number): number => something.lenght // error
// string 类型中不存在 length 属性
```

在以上这个示例中，由于 TS 不确定 something 属于哪个类型，所以 TypeScript 将访问 string 和 number 类型，判断它们是否都有 length 属性，如果其中 1 个没有，则直接报错。

## 交叉类型

交叉类型是将多个类型合并为一个类型。

这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。

 例如， `Person & Serializable & Loggable`同时是 `Person` 和 `Serializable` 和 `Loggable`，就是说这个类型的对象同时拥有了这三种类型的成员。

我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：

```tsx
type A = {name: string}
type B = {age: number}
type C = A & B
let yomua: C = {name: 'Yomua',age: 18,}
// 或以下做法
let yomua: A & B = {name: 'Yomua',age: 18,}
// 以下是错误的！
let yomua: A & B = {name: 'Yomua',} // 在 B 中必须存在 age，但是这里没有
```

# 函数

# 泛型

# [类型操作](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)

## [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)

取出指定类型的 key。

keyof Type 将是一个联合类型（`a | b`）

```typescript
type Point = { x: number; y: number };
type P = keyof Point;
// type P = 'x' | 'y'
```

## [typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)

在 TS 中，使用 typeof 引用变量/属性的名称将得到它们的类型。

```typescript
const s = "hello";
let n: typeof s;
// let n: string
```

NOTICE: 对于 TS 的 typeof 来说，仅在变量名上使用是合法的，这表明以下 typeof 的使用是错误的：

```typescript
let shouldContinue: typeof msgbox("Are you sure you want to continue?"); // ❌
```

## [索引访问类型](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

### 正常使用

你可以通过类似获取对象的值的方式，用在类型上，从而得到指定类型键的类型：

```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
// type Age = number
```

### 使用关键字 `number` 访问类型

关键字 number 用于获取数组中每个项的类型，它会取出数组中每一个值的类型，用 | 分隔(即把它们认为是联合类型)，取出每个值类型时存在两种情况。

1. 如果数组中值的类型一模一样，那么就认为是一个类型。

```typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
];
// 使用关键字 number
type Person = typeof MyArray[number];
/**
  type Person = {
      name: string;
      age: number;
  }
*/
```

1. 如果有多个属于同一个类型的值，但它们子项的类型不同，则使它们的类型趋于一致，并用 `|` 分割。

   即：将它们所有的类型整合，并合并到每个项，合并时，将当前子类型中**不存在的类型认作是可选类型**。

   如下所示：

```typescript
const MyArray = [
  666, // number
  'yomua' // string
  [], // any[]
  { love:'yhw' }, // object{love: stirng}
  { name: "Eve", age: 38 }, // object{name: string, age: number}
];
type Person = typeof MyArray[number];
/**
  type Person = number | string | any[] 
    | {love:string, name?:string, age?:number} 
    | {name:string, age:number, love?:string}
*/
```

- `{ love:'yhw' }` 和 `{ name: "Eve", age: 38 }` 是属于一个类型：object，但它们的子类型不同。

  所以 `number`  访问数组类型时，将让它们趋于一致，并以 `|` 分割 -> 

  `{love:string, name?:string, age?:number} ` 和 `{name:string, age:number, love?:string}`

## [映射类型](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

### 概念

映射类型是一种泛型。

我们可以将之理解为：**让指定 key 转成指定类型。 key 只能 number | string | symbol（一个确定的唯一值）** 

映射类型使用关键字 `in` ，基于【索引签名】，并且只能使用于 `type` 声明的类型中。

```typescript
// 将字符串索引签名匹配的值转为 boolean 类型。
type Yomua = {
  // AnyName 相当于一个临时变量，它代表 Info 中的每一个 key
  [AnyName in string]: boolean // 匹配 key 类型是 string 的值，将之转为 boolean 
                                                           // 这其实等同于：[key:string]: boolean
}

let data: Yomua
data = [] // ERROR 这里的是字符串索引签名, key 只能是 string，而不能是 number
data = {
  a: true, 
  b: false,
  c: 'yhw', // ERROR, 只允许 boolean 值
}
```

通常情况下，映射类型和 `keyof` + `泛型	` 一起使用：

```typescript
type Options<Info> = {
  // 遍历 Info 的每个 key, 并用 value 本身的类型作为类型。
  // e.g. [Property in name]: string； 即：匹配 key 类型是 name 或 hobby（此处 name, hobby 指的是 key，即：用 key 作为类型），并将值的类型转为其值本身类型
  // 即：也就是使用 【索引访问类型】获取到 指定类型的 键的类型。
  [Property in keyof Info]: Info[Property]
}

interface MyInfo{
  name: string, 
  hobby:{
    one: string
  } 
}

let data: Options<MyInfo>
type data = {
  name: string
  hobby: {
    one: string
  }
}
```

`in` 关键字后面只能是 `string | number | symbol`，否则该接口报错：

```typescript
type CreateMutable<Type> = {
    [Property in Type]: any // ERROR, Type 'Info' is not assignable to type 'symbol'.
}

type CreateMutable<Info> = {
      // ERROR, Type 'boolean' is not assignable to type 'string | number | symbol'
    [Property in boolean]: any 
}
```

### [映射修饰符](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)

在使用映射类型期间，可以使用两个修饰符，`-`  和 `+` （默认），修饰符能删除只读`readonly`和可选性`?`。

```typescript
type Modifiers<Type> = {
  // 删除 key 的只读性
  -readonly [Property in keyof Type]: Type[Property];
};

type Modifiers<Type> = {
  // 删除 key 的可选性
  [Property in keyof Type]-?: Type[Property];
};

type Info = {
  readonly id: string;
  readonly name: string;
  age?: number;
};

type A = Modifiers<Info>;
type A = {
    id: string;
    name: string;
    age: number
}
```

### [使用 as 重新映射 映射类型的 key](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

能改变 key 的名字。

```typescript
type Getters<Type> = {
    // 正式书写时没有 \。
      // 这里添加 \ 是因为不添加这个 md 的样式就有问题
    [Property in keyof Type as `get\${Capitalize<string & Property>}`]: () => Type[Property]
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters<Person>;
// 得到类型 => 
type LazyPerson = {
    getName: () => string;
    getAge: () => number;
    getLocation: () => string;
}
```

## [条件类型](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

### 语法

`SomeType extends OtherType ? TrueType : FalseType;`

如果` SomeType` 可以分配给 `OtherType`，则应用类型 `TrueType`，反之应用类型 `FalseType`

### 示例

```tsx
type ConditionType<Type> = Type extends string ? string : number;

let data: ConditionType<number>;
data = '1'; // error - Type 'string' is not assignable to type 'number'
data = 1; // correct
```

# Reference

- [公用类型 - 官网](https://www.typescriptlang.org/docs/handbook/utility-types.html) 