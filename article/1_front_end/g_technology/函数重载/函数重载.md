# 通过形参个数实现重载，遇到函数默认值失效

```js
function addMethod(obj, key, fn) {
  const old = obj[key];
  obj[key] = function (...args) {
    console.log(fn);
    if (args.length === fn.length) {
      fn.apply(this, args);
    } else if (typeof old === "function") {
      // 这里相当于一个闭包，用到了 old, 所以只要 obj[key] 没被销毁，那么 old 就会永远存在内存中，且每一个 old 都是不会相互影响的。
      old.apply(this, args);
    }
  };
}

const obj = {};

// 当连续多次调用 addMethod 时， obj 会保留最后一次调用 addMethod 存入的值， 即： 打印 obj 时，只会有一个 getUser
// 所以当直接调用 obj.getUser(1, 2) 时，args.length === fn.length 将直接为 true，因为 obj 当前存储的 getUser 的函数版本就是形参是 2 个的，
// 如果是直接调用 obj.getUser(1)，那么第一次 args.length === fn.length 是 false，这样就会执行 else if (typeof old === "function") ，
// 然后执行里面的 old.apply(this, args)， 由于闭包的原因，此时的 old 指的就是上一次（第 2 次）调用 addMethod 时存储的 obj[key]，
// 而上一次（第 2 次）存储的 obj[key] 里面的 fn 对应的形参个数，就是上一次（第 2 次） 调用 addMethod 时传入的 fn 的形参个数，
// 所以执行 old.apply(this, args) 时，就会执行第 2 次调用 addMethod 传入的方法。
// 那么以此类推，当我们多次调用 addMethod ，然后使用 obj.getUser(n 个形参) 时，就会通过闭包形成一种类似递归的方式，找到对应的形参个数相同的 obj[key]，
// 从而执行对应的 fn。
// 最后效果就是：通过 addMethod 和闭包的使用，存储了多个不同版本的 fn

// 注意：addMethod 有缺陷，函数形参若有默认值，那么 fn.length 是不会计算默认的，并且 addMethod 也只能适配函数形参个数，不能适配类型。
addMethod(obj, "getUser", () => {
  console.log("0");
});

addMethod(obj, "getUser", (name) => {
  console.log("1");
});

addMethod(obj, "getUser", (a, b) => {
  console.log("2");
});

// 这里说的 "递归" 指的是通过闭包存储了一个函数，然后调用函数时可能会调用上一次闭包存储的函数的情况。
// 这样可能会反复调用上一次闭包存储的函数，我在这里把它称之为递归，更好立理解。

// obj.getUser(); // 会 "递归" 寻找 2 次
obj.getUser(1); // 会 "递归" 寻找 1 次
// obj.getUser(1,2); // 不会 "递归" 寻找； 因为 Obj 存储的函数刚好就是形参个数为 2 个的版本的函数

```

# 区分形参个数、类型、函数默认值实现函数重载

```js
// 区分形参类型，个数实现函数重载。
// 认为调用 addImpl 的最后一个参数必是处理函数，前面的形参都是类型，
// 然后将描述类型和个数的形参转为字符串作为标识，设置为 Map 的 key
// 当调用 createOverload 返回的函数时，从 Map 中找到对应的 key，并执行对应的函数，从而实现函数重载
function createOverload() {
  const map = new Map();

  const EMPTY_ARGS = "emptyArgs";

  function overload(...args) {
    const argsType = args.map((arg) => typeof arg).join(","); // 'string,number'

    // 当实现的函数没有参数
    if (!argsType) {
      return map.get(EMPTY_ARGS).apply(this, args);
    }

    const fn = map.get(argsType);

    if (!fn) {
      throw new Error("No matching Function");
    }

    return fn.apply(this, args);
  }

  overload.addImpl = function (...args) {
    const fn = args.pop();

    if (typeof fn !== "function") {
      throw new TypeError("Not a Function");
    }

    const argsType = args.join(","); // 'string,number'

    // 调用 addImpl 时，不需要任何参数，就手动添加一个标识
    if (!argsType) {
      map.set(EMPTY_ARGS, fn);
      return;
    }

    map.set(argsType, fn); // [ ['string', ()=>{}], ['number', ()=>{}]  ]
  };

  return overload;
}

const getUser = createOverload();

getUser.addImpl(() => {
  console.log("空参数");
});

getUser.addImpl("number", (num) => {
  console.log("num", num);
});

getUser.addImpl("string", (str) => {
  console.log("str", str);
});

getUser.addImpl("number", "string", function (num, str) {
  console.log("num, string", num, str);
});

// getUser.addImpl("number", "string"); // TypeError: Not a Function

getUser();
getUser(1);
getUser("str");
getUser(1, "str");
// getUser(1, "str", ""); // error: No matching Function

```

