# 斐波那契

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    // 此函数参见: <大数字相加.md>
    function addUseFor(n1, n2) {
      let intN1 = `${n1}`.split(".")[0];
      let intN2 = `${n2}`.split(".")[0];
      let n1Decimals = `${n1}`.split(".")[1];
      let n2Decimals = `${n2}`.split(".")[1];

      let result = "";

      let intResult = "";
      let decimalsResult = "";

      // 将整数的长度补到相等
      if (intN1.length < intN2.length) {
        intN1 = intN1.padStart(intN2.length, "0");
      }

      if (intN2.length < intN1.length) {
        intN2 = intN2.padStart(intN1.length, "0");
      }

      // 如果小数不存在，就认为是空字符串, 空字符串长度为 0
      if (!n1Decimals) {
        n1Decimals = "";
      }

      if (!n2Decimals) {
        n2Decimals = "";
      }

      // 将小数的长度补到相等
      if (n1Decimals.length < n2Decimals.length) {
        n1Decimals = n1Decimals.padStart(n2Decimals.length, "0");
      }
      if (n2Decimals.length < n1Decimals.length) {
        n2Decimals = n2Decimals.padStart(n1Decimals.length, "0");
      }

      // 整数进位
      let intCarry = 0;

      // 从整数最后开始，一个个取字符，然后相加
      // TIP: 因为已经补齐了长度，所以任意选择一个数字的长度遍历即可。
      for (let i = intN1.length - 1; i >= 0; i--) {
        const n1Value = intN1[i];
        const n2Value = intN2[i];

        let value = +n1Value + +n2Value;

        // 判断是否有进位, 如果有, 则值加上进位 (就如同自己演算一样)
        if (intCarry === 1) {
          value = value + 1;
        }

        // 是否进位
        intCarry = value > 9 ? 1 : 0;

        // 已经遍历到第一位，直接加上进位
        if (i === 0) {
          intResult = `${value}${intResult}`;
        } else {
          // 否则得到进位后, 剩下的值, 如: 9 + 9 进位 1, 剩 8; 即: 18 & 10 = 8
          intResult = `${value % 10}${intResult}`;
        }
      }

      let decimalCarry = 0;

      for (let i = n1Decimals.length - 1; i >= 0; i--) {
        const n1DecimalsValue = n1Decimals[i];
        const n2DecimalsValue = n2Decimals[i];

        let value = +n1DecimalsValue + +n2DecimalsValue;

        // 判断是否有进位, 如果有, 则值加上进位 (就如同自己演算一样)
        if (decimalCarry === 1) {
          value = value + 1;
        }

        // 是否进位
        decimalCarry = value > 9 ? 1 : 0;

        if (i === 0) {
          decimalsResult = `${value}${decimalsResult}`;
        } else {
          decimalsResult = `${value % 10}${decimalsResult}`;
        }
      }

      result = intResult;

      if (decimalsResult) {
        result = `${intResult}.${decimalsResult}`;
      }

      return result;
    }
  </script>

  <script>
    const memo = [];

    // 递归求解斐波那契数
    // 其实就相当于一开始通过最前面的 2 个数的值 (固定值: 1) 开始求后面的值,
    // 一旦得到后面某个 n 的值就将它缓存起来, 并用作下一次求 n 之后的基础值.
    function feibonaqi(n) {
      if (memo[n]) {
        return memo[n];
      }

      if (n === 1 || n === 2) {
        memo[n] = "1";

        return "1";
      }

      // 前面第 1 个数的索引
      const n1 = n - 1;
      // 得到前面第 1 个数的值
      const n1Value = feibonaqi(n1);

      const n2 = n - 2;
      const n2Value = feibonaqi(n2);

      // 得到指定 n 的值后, 对 n 值进行缓存
      memo[n] = addUseFor(n1Value, n2Value);

      return memo[n];
    }

    console.log("第 20 个斐波那契数:", feibonaqi(20));
    console.log("截止到到第 20 个斐波那契数，结果为:", memo);
  </script>
</html>

```



