# 概念

一种将数组进行递归**二分分组**, 分到**不可再分**后, 对相邻两个分组进行**比较**, 每次比较后就将元素放入**新数组**, 比较到最后若还有**剩余元素**, 则将剩余元素直接按顺序放入新数组.

接着再将新数组和它相邻的数组进行比较, 又得到新数组, 如此反复...

再最后一轮比较时, 则比较的是**数组左边部分和右边部分**, 最后比较后得到的新数组将是最终排序成功的有序数组.

- 二分分组

  每次划分公式为: `index=数组长度/2, 再向下取整,` 

  左边则是`[0, index)`, 右边则是: `[index, 数组末尾]`

- 不可再分

  每个分组只有一个元素

- 比较

  根据需求从小到大, 或 从大到小

- 新数组

  此时的新数组是一个有序数组.

- 剩余元素

  若是从小到大比较: 分组 A 和分组 B 从第一个元素比较时, 如果 `A[0] < B[0]`, 且后续 A 的每个元素都小于 B, 

  那么 A 的元素将被取完, 全部放入新数组, B 分组则还有剩下来的元素, 这些剩下来的元素叫做剩余元素.

- 数组左边部分和右边部分

  不一定是先比较左再比较右，可能是反过来的，根据先访问左数组，还是先访问右数组不同，而有所不同。

  ```js
  初始数组 = [32, 12, 56, 78, 76, 45, 36]
  左边部分 = [12, 32, 56]
  右边部分 = [36, 45, 76, 78]
  ```

  此时这两部分已经是有序数组了,




# 示例

```js
function mergeSort(arr) {
  if (arr.length === 1) return arr;

  // 二分数组
  const midIdx = Math.floor(arr.length / 2);

  // 对左数组进行递归二分, 直到只有一个元素, 才会执行下一条语句.
  const leftArr = arr.slice(0, midIdx);
  const left = mergeSort(leftArr);

  // 对右数组进行递归二分, 直到只有一个元素, 才会执行下一条语句.
  const rightArr = arr.slice(midIdx);
  const right = mergeSort(rightArr);

  // 对两个数组进行归并 (比较 + 排序 + 合并)
  return merge(left, right);
}

// 从小到大比较.
// 归并排序相当于对每一个数组都已经排好了序
// => 对两个数组从第一个元素开始比较,以此决定谁最小, 最小的元素放入新数组, 最后剩余元素依次放入新数组.
function merge(leftArr, rightArr) {
  const newArr = [];

  // 对左数组和右数组从小到大进行依次比较
  // 每次比较得到较小的元素, 从源数组弹出, 并放入新数组
  // 如此反复, 直到某个源数组为空或比较到最后一个元素, 再剩余元素依次放入新数组, 最后返回新数组
  while (leftArr.length > 0 && rightArr.length > 0) {
    if (leftArr[0] < rightArr[0]) {
      newArr.push(leftArr.shift());
    } else {
      newArr.push(rightArr.shift());
    }
  }
  return newArr.concat(leftArr, rightArr);
}

const sourceArr = [32, 12, 56, 78, 76, 45, 36];
const result = mergeSort(sourceArr);

console.log(result); // [12, 32, 36, 45, 56, 76, 78]
```










