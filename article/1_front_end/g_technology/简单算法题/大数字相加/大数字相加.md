以下只是粗略版本，可以优化，但是思路是类似的, 即: 

对于需要相加的两个数，都要从右到左取它们的字符，分别取一个，然后相加，添加到结果，最后返回结果即可。

以下两个方法分别用 for 和 while 循环，其中的一些细节，可能 for 有，但是 while 没有的，这是因为懒得搞，需要就自己合并一下。



```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    const n1For = "111111111111111111111111.11111111111";
    const n2For = "11111111111111.1111111111111111";

    const n1While = "$$$$";
    const n2While = "11$1";

    // 必须保证 n1, n2 都是有效字符
    function addUseFor(n1, n2) {
      let intN1 = `${n1}`.split(".")[0];
      let intN2 = `${n2}`.split(".")[0];
      let n1Decimals = `${n1}`.split(".")[1];
      let n2Decimals = `${n2}`.split(".")[1];

      let result = "";

      let intResult = "";
      let decimalsResult = "";

      // 将整数的长度补到相等
      if (intN1.length < intN2.length) {
        intN1 = intN1.padStart(intN2.length, "0");
      }

      if (intN2.length < intN1.length) {
        intN2 = intN2.padStart(intN1.length, "0");
      }

      // 如果小数不存在，就认为是空字符串, 空字符串长度为 0
      if (!n1Decimals) {
        n1Decimals = "";
      }

      if (!n2Decimals) {
        n2Decimals = "";
      }

      // 将小数的长度补到相等
      if (n1Decimals.length < n2Decimals.length) {
        n1Decimals = n1Decimals.padStart(n2Decimals.length, "0");
      }
      if (n2Decimals.length < n1Decimals.length) {
        n2Decimals = n2Decimals.padStart(n1Decimals.length, "0");
      }

      // 从它们一个个取字符，然后相加
      // TIP: 因为已经补齐了长度，所以任意选择一个数字的长度遍历即可。
      for (let i = intN1.length - 1; i >= 0; i--) {
        const n1Value = intN1[i];
        const n2Value = intN2[i];

        intResult = `${+n1Value + +n2Value}${intResult}`;
      }

      for (let i = n1Decimals.length - 1; i >= 0; i--) {
        const n1DecimalsValue = n1Decimals[i];
        const n2DecimalsValue = n2Decimals[i];

        decimalsResult = `${
          +n1DecimalsValue + +n2DecimalsValue
        }${decimalsResult}`;
      }

      result = intResult;

      if (decimalsResult) {
        result = `${intResult}.${decimalsResult}`;
      }

      return result;
    }

    // 如果传入的 n1, n2 含有无效字符，则只加有效字符
    function addUseWhile(n1, n2) {
      let intN1 = `${n1}`.split(".")[0];
      let intN2 = `${n2}`.split(".")[0];

      // 将它们的长度补到相等
      if (intN1.length < intN2.length) {
        intN1 = intN1.padStart(intN2.length, "0");
      }

      if (intN2.length < intN1.length) {
        intN2 = intN2.padStart(intN1.length, "0");
      }

      // 定义它们的指针, 目的是从最右边开始向左边移动
      let n1Pointer = intN1.length - 1;
      let n2Pointer = intN2.length - 1;

      let result = "";

      // 直到 n1 和 n2 都遍历完才跳出循环。
      while (n1Pointer >= 0 || n2Pointer >= 0) {
        let n1Value = intN1[n1Pointer];
        let n2Value = intN2[n2Pointer];

        // 即: 如果 n1 = "$$$$"; n2 = "11$1";
        // 就会导致 n1Pointer < 0, 从而获取到 n1Value = undefined
        // 因为 n1 直到最左边（第 0 位）都是无效字符, 所以 Number.isNaN(+n1Value) 会执行, 从而 n1Pointer-- => 0-- 就是 -1
        // 那么这样，就认为 n1Value 是 0
        if (n1Value === undefined) {
          n1Value = 0;
        }
        if (n2Value === undefined) {
          n2Value = 0;
        }

        // 如果取出无效字符, 就移动指针，重新取下一个字符。
        if (Number.isNaN(+n1Value)) {
          n1Pointer--;
          continue;
        }

        if (Number.isNaN(+n2Value)) {
          n2Pointer--;
          continue;
        }

        // 都是数字，就移动指针，往下一步走
        n1Pointer--;

        n2Pointer--;

        result = `${+n1Value + +n2Value}${result}`;
        // 12
      }

      return result;
    }

    console.log(addUseFor(n1For, n2For));
    console.log(addUseWhile(n1While, n2While));
  </script>
</html>

```



其他示例

这里不支持小数点相加

```js
// 大数字相加
function add(a, b) {
  // 初始化结果字符串和进位变量
  let res = "";
  // 用来判断是否有进位; 有 -> 1; 没有 -> 0
  let temp = 0; 

  // 将输入字符串转换为数组，方便逐位相加
  a = a.split("");
  b = b.split("");

  // 当两个输入数组或进位变量仍存在时进行循环
  while (a.length || b.length || temp) {
    // 将当前位置的数字相加并加上之前的进位 (0 或 1)
    // ~~a.pop() 相当于 +a.split('.')[0]
    // => 转为数字, 再直接去掉小数部分
    // 对于此特定场景, 没有小数点的字符串数字来说, ~~ 和 + 是等价的
    // TIP: 此时会被转为数字类型相加
    temp += ~~a.pop() + ~~b.pop();

    // 将当前位置的结果放在结果字符串的最前面
    // 如果 temp 为 10, 则此时 0 + res; 
    // 然后 temp 就会被进位, 设置为 1
    res = (temp % 10) + res;

    // 判断是否有进位，如果有，temp 为 true，
    // temp = temp + ~~a.pop() + ~~b.pop(); 
    // => temp = true + ~~a.pop() + ~~b.pop();
    // => temp = 1 + ~~a.pop() + ~~b.pop(); 
    // 从而进位, 所以这里也可以写为: temp = temp > 9 ? 1 : 0;
    temp = temp > 9;
  }
  
  // 移除结果字符串前面的多余零
  return res.replace(/^0+/, "");
}

console.log(
  add(
    "111111111111111111111111111111111111111111111111111",
    "999999999999999999999999999999999999999999999999999"
  )
);
```





