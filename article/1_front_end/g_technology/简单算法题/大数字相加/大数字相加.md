以下只是粗略版本，可以优化，但是思路是类似的, 即: 

对于需要相加的两个数，都要从右到左取它们的字符，分别取一个，然后相加，添加到结果，最后返回结果即可。

以下两个方法分别用 for 和 while 循环，其中的一些细节，可能 for 有，但是 while 没有的，这是因为懒得搞，需要就自己合并一下。



```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    const n1For = "235.11";
    const n2For = "359.99";

    const n1While = "$$$99";
    const n2While = "#####11";

    // 必须保证 n1, n2 都是有效字符
    function addUseFor(n1, n2) {
      let intN1 = `${n1}`.split(".")[0];
      let intN2 = `${n2}`.split(".")[0];
      let n1Decimals = `${n1}`.split(".")[1];
      let n2Decimals = `${n2}`.split(".")[1];

      let result = "";

      let intResult = "";
      let decimalsResult = "";

      // 将整数的长度补到相等
      if (intN1.length < intN2.length) {
        intN1 = intN1.padStart(intN2.length, "0");
      }

      if (intN2.length < intN1.length) {
        intN2 = intN2.padStart(intN1.length, "0");
      }

      // 如果小数不存在，就认为是空字符串, 空字符串长度为 0
      if (!n1Decimals) {
        n1Decimals = "";
      }

      if (!n2Decimals) {
        n2Decimals = "";
      }

      // 将小数的长度补到相等
      if (n1Decimals.length < n2Decimals.length) {
        n1Decimals = n1Decimals.padStart(n2Decimals.length, "0");
      }
      if (n2Decimals.length < n1Decimals.length) {
        n2Decimals = n2Decimals.padStart(n1Decimals.length, "0");
      }

      // 整数进位
      let intCarry = 0;

      // 从整数最后开始，一个个取字符，然后相加
      // TIP: 因为已经补齐了长度，所以任意选择一个数字的长度遍历即可。
      for (let i = intN1.length - 1; i >= 0; i--) {
        const n1Value = intN1[i];
        const n2Value = intN2[i];

        let value = +n1Value + +n2Value;

        // 判断是否有进位, 如果有, 则值加上进位 (就如同自己演算一样)
        if (intCarry === 1) {
          value = value + 1;
        }

        // 是否进位
        intCarry = value > 9 ? 1 : 0;

        // 已经遍历到第一位，直接加上进位
        if (i === 0) {
          intResult = `${value}${intResult}`;
        } else {
          // 否则得到进位后, 剩下的值, 如: 9 + 9 进位 1, 剩 8; 即: 18 & 10 = 8
          intResult = `${value % 10}${intResult}`;
        }
      }

      let decimalCarry = 0;

      for (let i = n1Decimals.length - 1; i >= 0; i--) {
        const n1DecimalsValue = n1Decimals[i];
        const n2DecimalsValue = n2Decimals[i];

        let value = +n1DecimalsValue + +n2DecimalsValue;

        // 判断是否有进位, 如果有, 则值加上进位 (就如同自己演算一样)
        if (decimalCarry === 1) {
          value = value + 1;
        }

        // 是否进位
        decimalCarry = value > 9 ? 1 : 0;

        if (i === 0) {
          decimalsResult = `${value}${decimalsResult}`;
        } else {
          decimalsResult = `${value % 10}${decimalsResult}`;
        }
      }

      result = intResult;

      if (decimalsResult) {
        result = `${intResult}.${decimalsResult}`;
      }

      return result;
    }

    // 如果传入的 n1, n2 含有无效字符，则只加有效字符;
    // 目前不支持小数, 差不多和 addUseFor 那样, 跟着写就行.
    function addUseWhile(n1, n2) {
      let intN1 = `${n1}`.split(".")[0];
      let intN2 = `${n2}`.split(".")[0];

      // 将它们的长度补到相等
      // debugger;
      if (intN1.length < intN2.length) {
        intN1 = intN1.padStart(intN2.length, "0");
      }

      if (intN2.length < intN1.length) {
        intN2 = intN2.padStart(intN1.length, "0");
      }

      // 定义它们的指针, 目的是从最右边开始向左边移动
      let n1Pointer = intN1.length - 1;
      let n2Pointer = intN2.length - 1;

      let result = "";

      // 整数进位
      let intCarry = 0;

      // 直到 n1 和 n2 都遍历完才跳出循环。
      while (n1Pointer >= 0 || n2Pointer >= 0) {
        let n1Value = intN1[n1Pointer];
        let n2Value = intN2[n2Pointer];

        // 即: 如果 n1 = "$$$$"; n2 = "11$1";
        // 就会导致 n1Pointer < 0, 从而获取到 n1Value = undefined
        // 因为 n1 直到最左边（第 0 位）都是无效字符, 所以 Number.isNaN(+n1Value) 会执行, 从而 n1Pointer-- => 0-- 就是 -1
        // 那么这样，就认为 n1Value 是 0
        if (n1Value === undefined) {
          n1Value = 0;
        }
        if (n2Value === undefined) {
          n2Value = 0;
        }

        // 如果取出无效字符, 就移动指针，重新取下一个字符。
        if (Number.isNaN(+n1Value)) {
          n1Pointer--;

          continue;
        }

        if (Number.isNaN(+n2Value)) {
          n2Pointer--;

          continue;
        }

        // 都是数字, 且可以继续往下移 (即: 大于等于 0), 就移动指针，往下一步走
        if (!Number.isNaN(+n1Value) && n1Pointer >= 0) {
          n1Pointer--;
        }

        if (!Number.isNaN(+n2Value) && n2Pointer >= 0) {
          n2Pointer--;
        }

        let value = +n1Value + +n2Value;

        // 判断是否有进位, 如果有, 则值加上进位 (就如同自己演算一样)
        if (intCarry === 1) {
          value = value + 1;
        }

        // 是否进位
        intCarry = value > 9 ? 1 : 0;

        // 这里始终取余, 此示例中, 使用 while 的形式无法判断此次是否是最后一次循环 (因为可能还有无效字符等等)
        result = `${value % 10}${result}`;
      }

      // 跳出循环后，如果还有进位，就补上进位
      result = intCarry ? `${intCarry}${result}` : result;

      // n1 = '000', n2 = '000', 则会得到 '000', 所以这里就是统一归为一个 0
      result = parseInt(result, 10) === 0 ? "0" : result;

      // 删除前导 0, 即 n1 = "$$$99"; n2 = "#####11"; 得到: 0110
      result = result.length > 1 ? result.replace(/^0+/, "") : result;

      return result;
    }

    console.log(addUseFor(n1For, n2For));
    console.log(addUseWhile(n1While, n2While));
  </script>
</html>

```



其他示例

这里不支持小数点相加，可以写，但是这里懒得写。

```js
// 大数字相加
function add(a, b) {
  // 初始化结果字符串和进位变量
  let res = "";
  // 用来判断是否有进位; 有 -> 1; 没有 -> 0
  let temp = 0; 

  // 将输入字符串转换为数组，方便逐位相加
  a = a.split("");
  b = b.split("");

  // 当两个输入数组或进位变量仍存在时进行循环
  while (a.length || b.length || temp) {
    // 将当前位置的数字相加并加上之前的进位 (0 或 1)
    // ~~a.pop() 相当于 +a.split('.')[0]
    // => 转为数字, 再直接去掉小数部分
    // 对于此特定场景, 没有小数点的字符串数字来说, ~~ 和 + 是等价的
    // TIP: 此时会被转为数字类型相加
    temp += ~~a.pop() + ~~b.pop();

    // 将当前位置的结果放在结果字符串的最前面
    // 如果 temp 为 10, 则此时 0 + res; 
    // 然后 temp 就会被进位, 设置为 1
    res = (temp % 10) + res;

    // 判断是否有进位，如果有，temp 为 true，
    // temp = temp + ~~a.pop() + ~~b.pop(); 
    // => temp = true + ~~a.pop() + ~~b.pop();
    // => temp = 1 + ~~a.pop() + ~~b.pop(); 
    // 从而进位, 所以这里也可以写为: temp = temp > 9 ? 1 : 0;
    temp = temp > 9;
  }
  
  // 移除结果字符串前面的多余零
  return res.replace(/^0+/, "");
}

console.log(
  add(
    "111111111111111111111111111111111111111111111111111",
    "999999999999999999999999999999999999999999999999999"
  )
);
```





