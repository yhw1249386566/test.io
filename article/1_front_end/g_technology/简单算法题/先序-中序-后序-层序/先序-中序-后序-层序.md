# 名词注解

- 根节点
  此处的根节点表示, 当前正在进行操作的节点;

  比如正在便利的节点是 A, `A.left 是 B` , `A.right 是 C`, 那么 A 称之为根节点.
  如果继续递归, 往下访问 A.left B, 那么 B 就称之为根节点.

# 概念

遍历方式的命名，源于其访问节点的顺序, 最简单的划分: 

深度优先可进一步按照根节点相对于左右子节点的访问先后来划分。

如果把左节点和右节点的位置固定不动

- 根节点放在左节点的左边，称为前序（pre-order）、
- 根节点放在左节点和右节点的中间，称为中序（in-order）、
- 根节点放在右节点的右边，称为后序（post-order）。

对广度优先而言，遍历没有前序中序后序之分：给定一组已排序的子节点，其“广度优先”的遍历只有一种**唯一**的结果。

TIP:  若尝试将左右节点遍历顺序互换, 则会先遍历右节点, 在遍历左节点.

# 对树进行遍历的思维方式

常见的做法是采用[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（LIFO）或[队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)（FIFO）。

由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)方式，或者更准确地说，用[共递归](https://zh.wikipedia.org/wiki/%E5%85%B1%E9%80%92%E5%BD%92)，来实现延迟节点的保存。

这时（采用递归的情况）这些节点被保存在[调用堆栈](https://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A)中。

# 示例 - 前中后序(递归) - 层序(队列)

对树进行先、中、后、层四种遍历都很简单;

其中先, 中, 后序用的都是深度优先搜索思想 - 此处采用递归做法; 

层序则用的是广度优先搜索思想 - 此处采用队列.

示例

```js
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

//     1
//    / \
//   2   3
//  / \ / \
// 4  5 6  7

// 深度优先搜索
// 先序遍历（Preorder Traversal）：根-左-右;
// 结果：1, 2, 4, 5, 3, 6, 7

// 中序遍历（Inorder Traversal）：左-根-右
// 结果：4, 2, 5, 1, 6, 3, 7

// 后序遍历（Postorder Traversal）：左-右-根
// 结果：4, 5, 2, 6, 7, 3, 1

// 广度优先搜索
// 层序遍历（Level Order Traversal）：从上到下，从左到右
// 结果：1, 2, 3, 4, 5, 6, 7

// 构建树
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.left = new TreeNode(6);
root.right.right = new TreeNode(7);

// 先序遍历
function preorderTraversal(node) {
  if (node) {
    console.log(node.value);
    preorderTraversal(node.left);
    preorderTraversal(node.right);
  }
}

// 中序遍历
function inorderTraversal(node) {
  if (node) {
    inorderTraversal(node.left);
    console.log(node.value);
    inorderTraversal(node.right);
  }
}

// 后序遍历
function postorderTraversal(node) {
  if (node) {
    postorderTraversal(node.left);
    postorderTraversal(node.right);
    console.log(node.value);
  }
}

// 层序遍历
function levelOrderTraversal(root) {
  const queue = [root];

  while (queue.length > 0) {
    const current = queue.shift();
    if (current) {
      console.log(current.value);
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    }
  }
}

// 测试
console.log("先序遍历：");
preorderTraversal(root);

console.log("\n中序遍历: ");
inorderTraversal(root);

console.log("\n后序遍历: ");
postorderTraversal(root);

console.log("\n层序遍历: ");
levelOrderTraversal(root);
```

参见以上示例

不难发现, `先, 中, 后序`遍历它们的区别点就是: 

对树进行遍历过程中, 对树当前遍历到的 `(根)节点` 进行操作(也称为 "访问" )的时机不同而已.

- TIP: 根节点在此处不是指最初的节点(比如: 1), 而是每次遍历时的节点称之为根节点;
  比如: 遍历节点 1, 1 称之为根节点;  遍历 `1.left`  时, 那么 `1.left`  被开始遍历, 此时 `1.left`  就称之为根节点.
- 你可以不使用 `递归` 来对树进行 `先, 中, 后序` 遍历, 而是类似使用 层序 的方法, 使用 `Stack(栈)` 的思维来进行遍历.

层序遍历就是广度优先深度



# Reference

- [WIKI](https://zh.wikipedia.org/zh-cn/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#:~:text=%E5%A6%82%E6%9E%9C%E6%8A%8A%E5%B7%A6%E8%8A%82%E7%82%B9%E5%92%8C,%E5%BA%8F%EF%BC%88post%2Dorder%EF%BC%89%E3%80%82) 