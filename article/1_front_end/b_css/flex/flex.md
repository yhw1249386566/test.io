[TOC]

# 基础

## 概念

弹性盒:Flexible Box Module Level 1,其简称为:FlexBox.

弹性盒把以外间距的布局任务变得极为简单,例如很多类型的页面,小组件,应用和图库.

有了弹性盒,通常不再需要CSS框架. P564

- 弹性盒是一种布局方式,其**使用display:flex 或 display:inline-flex**就激活了弹性盒布局. P565

- display:flex和display:inline-flex只有一个区别:
  
  ​    即使用d**isplay:flex布局的元素生成的是块级框,**弹性元素在其中布局.
  
  ​    使用**display:inline-flex布局的元素生成的是行内块级框**,弹性元素在其中布局. P566
  
  ​    而**行内块级框**则是: 
  
  ​        对该元素以外的元素表现得如同行内框,但是元素以内的元素默认会被格式化成块级框,例如行内块级元素和以内的所有元素都可以设置width和height且不会被忽略.
  
  ​        详情请看:<置换_非置换_块级_行内_行内块级元素.md>

- 我们可以通过**弹性盒指明空间的分布方式,内容的针对方式和元素的视觉顺序,**把不同的组件放置在页面中.
  
  **弹性盒中的内容可以轻易横向/纵向排布,还可以沿一个轴(x,y轴等)布局,或折断成多行**等等. P564

- 使用弹性盒,可以让**弹性盒中的内容的呈现顺序不再受源码顺序的限制,**但是,通常来说,这只是一种视觉上的调整,因为弹性盒相关的属性不会改变屏幕阅读器对内容的读取顺序.
  
  当然了,虽然**规范提出浏览器(屏幕阅读器)应该采用源码顺序,**但是**有些**浏览器渲染样式目前采用的是视觉顺序,例如:Firefox. P564

- 顾名思义,**弹性盒特点就是**:弹性. 即弹性盒布局能让元素对不同的屏幕尺寸和不同的显示设备做好适应准备,
  
  所以**弹性盒布局在响应式网站中表现极好**,因为其弹性盒中的内容可以根据可用空间的大小自动增减尺寸. P565

- **激活弹性盒的元素变成了弹性盒容器,其所有直接子元素变成了弹性元素,也就是这些直接子元素使用弹性盒进行布局**,注意:是所有直接子元素,也包括**匿名的子元素**,而子元素的子元素并不会变成弹性元素,
  
  但是我们可以设置更多的后代元素变成弹性元素,实现更复杂的布局.P566
  
  ​    即:将弹性元素变成弹性盒,也就是说嵌套的弹性盒,这样就相当于对最外边的弹性盒来说,其子元素是弹性盒的元素,
  
  ​    它的子元素也是弹性元素,简略的说:**子元素的子元素依然是弹性元素,前提是第一个子元素为弹性盒.**

- 成为弹性容器的元素,可以控制其直接子元素的布局(直接子弹性元素)P565

- 在成为**弹性盒的元素中**,其**各个直接子元素(弹性元素)在主轴上排列,**而主轴可以是横线的,纵向的,所以这些弹性元素能被布置为行或列布局. P566

- 弹性盒容器中的弹性元素都是块级元素,无论它曾经是什么类型,都会变成块级元素.

- 如果**弹性容器中的弹性元素没有占满容器的整个主轴**(这里指宽度),则**将会出现一些空白,也就是间**隙. 而这些空白的处理方式可**以由几个相关属性控制**.P566 (深入 - justify-content)

- **弹性元素**可以相对于弹性容器**全部靠左,靠右,居中分布,**也可以全部相对于弹性容器**均匀分布**,即把多出的空间平均分配在各个弹性元素之间或四周. (justify-content)
  
  除了均匀分布空白之外,我们还**可以增加部分弹性元素的尺寸**,也**可以把多出来的空间分给一个/全部弹性元素.**
  
  如果弹性盒容器不足放下所有弹性元素,**可以通过相关属性指明缩减弹性元素的尺寸或者允许换行.**P566

- 弹性子元素可以**相对容器**或**其他子元素对齐**,比如:能靠弹性盒容器底部,顶部对齐,也能在容器中居中对齐,此外我们**还可以拉伸弹性子元素,**使它[加上其他弹性元素]占满整个容器. (深入 - align-items)
  
  不管同辈弹性元素之间的内容长度(应该指内容区宽度)差距多少,使用**一个声明就可以让所有同辈弹性元素具有相同的尺寸.** P567

- 虽然可以使用以前的CSS技术实现弹性盒中的大部分内容,但是最终你会发现,**弹性盒布局方式更为简洁,明了,轻松**. P568

- **在设计上,弹性盒对方向使没有认识的**. 块级/行内元素则不同,块级/行内元素是纵向/横向移动.  P568

- **弹性盒的目的是实现一种特定的布局,即一维内容分布,也就是说,弹性盒最适合沿一个方向/轴布置内容.**
  
  注意:弹性盒虽然可以使用它实现栅格布局(二维排列布局),但这并不是弹性盒最初的目的,如果**想要使用栅格布局(二维布局),请使用栅格布局.**
  
  P570

- 我们并**不需要使用CSS框架**,如Bootstrap,YUI grids, Foundation,960 grid等,**也能让布局更加简单,明了.**
  
  因为如果不使用弹性盒布局,或许会造成一些非常难实现的效果,例如:使某几个单独的元素标签完全等高等. P570

- **弹性元素生成的弹性块级框(包括外边距)是相对于弹性盒的内容区进行布局的.**亲测

- **默认情况下,相邻的弹性元素的最外边那条边会会互相紧紧贴在一起,且弹性元素的外边距不会被折叠.**在布局时弹性元素的外边距也会被计算进去,如同定位元素相对于容纳块的样子(<定位.md>)亲测

## 弹性容器

- 弹性盒就是弹性容器,也叫做容器框,使用display:flex或display:inline-flex属性激活.
  
  以这两个属性声明的元素变成弹性容器,弹性盒, 其弹性盒中的直接子元素统统变成弹性元素,且是块级元素block,**为这些子元素生成弹性格式化上下文,也就是弹性容器(的内容区)是这些弹性元素的容纳快**. P570

- 弹性盒的直接子元素**,不论是DOM节点,文本节点,还是生成的内容亦或者是匿名子元素都被称为弹性元素.**
  
  处于弹性盒中的**绝对定位元素,也是弹性元素**,不过**确定**这绝对定位元素的尺寸和位置时,**将其视作弹性容器中唯一的弹性元素**.P570

## flex-direction弹性盒布局方向

- 该属性用来确定弹性盒中的弹性元素如何摆放.其取值又4种:
  
  ​    row | row-reverse | colum | colum-reverse
  
  ​    其默认值为row.不存在继承和动画性. P571

- flex-direction属性值效果
  
  **以下的语言都默认为从左→右书写.**
  
  **row**:默认值,即让弹性盒中的元素沿着x轴(横向)从左→右摆放,
  
  **row-reverse**:让弹性盒中的元素沿着x方向从右→左摆放,即开头变结尾,结尾变开头.
  
  **colum**:让弹性盒中的元素沿着y轴从上→下摆放,即变成如同块级元素的那种摆放模式.
  
  **colum-reverse**:让弹性盒中的元素沿着y轴从下→上摆放,即开头结尾,结尾变开头.
  
  ​    PS:row-**reverse**和colum-**reverse**属性值**只颠倒外观,**也就是说只改变视觉效果,但是**不会改变源代码顺序,同时也不会改变如tab键顺序和渲染顺序等.**
  
  ​            例如: row: a b c d e **,tab键顺序从a→e,即从左→右**.
  
  ​                row-reverse: e d c b a,**tab键顺序从a→e,即从右→左.**
  
  ​        P573

- 我们现在并不会讨论从右→左书写模式的语言. P572,警告或提醒.
  
  **注意:当你使用类如writing-mode属性修改其书写模式时,弹性盒布局能自动转换弹性方向.** P576

- 一个flex-direction示例 P574

## 自思考

通过以上的概念,弹性容器,弹性盒布局方向我们现在应该非常清楚,弹性盒是如何布局的,即通过x和y轴(主轴和垂轴)进行布局,

 让弹性盒中的弹性元素沿着x轴或y轴进行横向/横向相反, 纵向/纵向相反进行排列布局.

同时弹性盒可以处在另一个弹性盒中, 绝对定位元素又可以处于弹性盒中变成绝对定位之弹性元素,不过在确定绝对定位的尺寸和位置时,UserAgent将会把它当作弹性盒中的唯一弹性元素

**在默认情况下,弹性盒中的弹性元素是不可能超过其弹性盒大小的,因为弹性元素一旦多的/大的会超过弹性盒元素就会被UserAgent强制缩减,除非内容区太大,且弹性盒不允许换行,此时就会超过弹性盒大小.**

## flex-wrap弹性盒换行

- flex-wrap取值有4种:nowrap | wrap | wrap-reverse
  
  **nowrap**: 默认值,不换行/换列
  
  **wrap**:换行/换列显示
  
  **wrap-reverse**:换行/换列显示,且使换行/换列时添加的元素相反添加,    即例如:x轴排列的弹性元素,在添加下一个元素要换行时,是以垂轴的方向(从左→右)添加,
  
  ​    所以此时会添加到当前行的下方,但是使用了wrap-reverse值,就会把下一个需要添加的元素添加到当前行的上方,列也是类似的效果.
  
  ​    但是这只是视觉效果,同样不会改变渲染顺序和tab键等的顺序,请看 flex-direction. P578

- **如果弹性元素在弹性容器的主轴(x/y轴)上放不下**,默认情况下,此时的弹性元素并不会被换行,也不会自行调整尺寸,
  
  ​    除非flex属性设定**允许弹性元素缩减尺寸**,那么此时弹性元素就会主动缩减尺寸以求不超过弹性容器,除非**没有办法**,例如:
  
  ​    主轴上排布的弹性元素太多个,导致**内容区太大**,那么此时缩减尺寸也没有任何办法,因为内容区是无法被缩减的,
  
  ​    即弹性元素**不会主动去缩减字体大小**以求不超过弹性盒的大小,所以此时弹性元素会溢出弹性盒,
  
  ​    但是**如果弹性盒允许换行**,那么在弹性盒的height/width没有设置/为**auto时**,弹性盒**可以装下所有的弹性元素**,
  
  ​    首先是因为一个web网页的纵**轴近乎是可以无限延申的**,其次是因为当下一个弹性元素要超过弹性盒时,此时这个弹性元素就会被换行/换列.
  
  **PS: 弹性盒的主轴为x轴(row/row-reverse),则换行就是换到下一行.**
  
  **弹性盒的主轴为y轴(colum/colum-reverse),则"换行"则是换到下一列**
  
  ​    还有需要注意的是,如果**height为auto,则沿y轴排列的弹性元素是不可能换行的**,因为我们说过,web网页是**可以无限的纵向延申**,除非指定其弹性盒的height值,则 此时沿y轴排列的弹性元素就会换.    P577

## flex-flow弹性流

在知道flex-direction和flex-wrap两个属性后,现在让我们来讲讲它们的简写形式.

- flex-flow是道flex-direction和flex-wrap的简写形式,它的取值为:
  
  ​    \<flex-direction> || \<flex-wrap>
  
  即flex-flow属性的取值是flex-direction和flex-wrap属性的取值,且它们的顺序任意,也不需要都写出来.
  
  例如:
  
   `flex-flow : row;`
  
   `fleox-flow:row nowrap;`
  
  ` flex-flow:nowrap row;`
  
  以上三个属性是等同的,一摸一样的. P580-P581

所以我们完全可以用flex-flow代替flex-direction和flex-wrap,那CSS为什么不直接出flex-flow属性, 把flex-direction和flex-wrap两个属性取代呢?

这是因为这两个属性先于flex-flow出现,应用在web网页上颇多,不可能取代,因为一旦取代,有许多依赖于flex-direction和flex-wrap属性的网页将出现重大事故,会给互联网带来危机.

所以并不会取代. 且现在开始使用flex-flow也不迟不是吗?方便快捷.

# 深入

## 深入理解各种轴 P581

- #### **弹性元素沿主轴排布,沿垂轴方向添加.**
  
  **主轴: x或y轴.** 
  
  **垂轴:垂直于主轴的轴.** 
  
  ​    即 `主轴x,垂轴就是y;` `主轴y,垂轴就是x.`  P581

注意: 一列存在3个元素,则代表:3行一列 ; 一行存在3个元素,代表一行三列.

1. ​    **三个弹性元素沿着x轴排布,那么就是沿着y轴添加,** 即此时如果准备添加第四个弹性元素,
   
   ​    那么这第四个弹性元素应该会添加到**第三个弹性元素的下边.**

2. ​    **三个弹性元素沿着y轴排布,那么就是沿着x轴添加**, 即此时如果准备添加第四个弹性元素,
   
   ​    那么这第四个弹性元素应该会添加到**第三个弹性元素的右边.**

以上两个小例子就是所谓的弹性元素**沿主轴排布,沿垂轴方向添加**. P582

## 布置弹性元素 P587

以上的概念中,**并没有任何一个概念提到如何确定弹性元素的位置**,沿着x轴排布和y轴排布的弹性元素,似乎横向展开/纵向展开,且每个弹性元素的外边距(或者说最外面那条边)都紧紧贴在一起都是**理所当然**的,

我们并不知道其中的原因,甚至当多个弹性元素沿着主轴排列,但是其**弹性元素的总宽度<弹性盒的内容区宽度时,即弹性元素不能填满整个弹性盒**,

从而导致会让**主轴终边和垂轴终边的那个方向**处于空白的状态,我们就不能通过改变弹性元素的大小,让其布满整个可用的空间呢? 

为什么不让弹性元素在主轴上均匀分布,而一定要让它们紧紧贴在一起呢?

是的,我们可以做到,CSS属性(justify-content)能控制这样的行为. P587- P588

## justify-content P588

- 该属性和align-items属性类似,只不过此属性影响弹性元素在主轴方向的对齐,align-items影响的是垂轴方向的对齐. 
  
  它们都只能用于弹性盒上.

- 该属性在取值和相关概念上与align-content属性一致.
  
  只不过align-content属性控制的是其所有弹性元素在垂轴方向上的对齐方式,而该属性控制的是主轴方向上的对齐方式.

justify-content属性能**指明弹性元素在弹性盒的主轴上如何进行分布,如何相对于弹性盒的内容区进行对齐**这个属性应用于弹性盒上,无法用于弹性元素.

​    (或者可以说**,改变弹性盒中的余下空白在弹性元素中的分布方式**)

改变了阅读顺序并不会影响其主轴/垂轴的起边和终边,也就不会影响此属性.

- 改变阅读顺序: row-reverse /  colum-reverse 
  
  以上的就是改变了阅读顺序,但是对于justify-content属性来说,改变它们的对齐方式和row / colum并没有区别.

改变了书写方向会使justify-content属性也相对的改变,其表现为: 原本的主轴/垂轴起边/终边变成了 终边/起边.

它有六个取值: 

flex-start | flex-end | center | space-between | space-around | space-evenly

- 这里先说明一点,沿x轴进行排布的弹性元素,换行了就是每行.

- 沿y轴进行排布的弹性元素,"换行"了,也就是换列添加元素,即每列.

- 每行/每列: 沿着x轴进行排布的弹性元素,包括换行了的弹性元素
  
  沿着y轴进行排布的弹性元素,包括换列了的弹性元素

**flex-start:**默认值,让每行/每列的弹性元素紧靠主轴起边,且每个相邻的弹性元素最外边的那条边(包括外边距(不会被折叠))也仅仅贴在一起.

**flex-end**:和flex-start相反的一个属性值,让所有弹性元素紧靠主轴终边,弹性元素紧贴一起.

**center**:把所有弹性元素作为一个整体,居中显示在主轴尺寸的终点,弹性元素依然紧贴**在一起**.

**space-between**:让主轴上的每行/每列的第一个元素的最外边(包括外边距)紧靠主轴起边,最后一个元素的最外边(包括外边距)紧靠主轴终边,最后将余下的空白等量的放在相邻的两个弹性元素之间.

**space-around:**将余下的空间,均匀的分配给弹性元素的左右/上下两边,这会导致主轴起点和第一个元素之间的距离以及主轴终点和最后一个元素之间的距离是其他相邻的两个弹性元素之间的1/2.

​    这是因为这个属性值是分配到每个弹性元素左右/上下两边,且又不会被折叠,而主轴起边或终边只有一个弹性元素,所以自然会比相邻的两个元素之间的距离少一半.

- 左右/上下两边: 即沿着x轴排布的弹性元素,此值分配的空间是左右两边.
  
  左右/上下两边: 即沿着y轴排布的弹性元素,此值分配的空间是上下两边.

**space-evenly:**将余下的空间,均匀的分配在每行/每列中,这意味着不会和space-around属性值那样,导致主轴起边和主轴终边到第一个/最后一个弹性元素之间的距离比相邻的两个元素之间的距离少一半.

​    即主轴起边和主轴终边到第一个/最后一个弹性元素之间的距离和相邻的两个元素之间的距离是一样的.

P589

## align-items P596

align-items属性和justify-content属性有些类似,**只不过align-items属性影响的是垂轴,justify-content影响的是主轴.**

**align-items 属性对齐的是弹性盒中的全部弹性元素,align-content对齐的是弹性盒中的弹性框,如同栅格布局中的这些属性一样.**

*详情请看<栅格布局.md>*

- align-items属性可以把**所有**弹性元素(包括匿名的弹性元素)都沿**垂轴**的起边,终边或中线对齐,也可以把所有弹性元素与基线对齐.

- align-items属性**只能用于弹性盒**上,不能用于单个弹性元素.P596

- align-items属性的取值有五种,
  
  ​    flex-start | flex-end | center | baseline | stretch默认值
  
  - **stretch**:默认值,
  
  ​    可拉伸的弹性元素,在弹性元素**不存在垂轴方向上的尺寸**时(即不存在height/width/min-height/max-height/min-width/max-width等),**弹性元素是可以拉伸的**,否则此属性值对弹性元素没有任何效果.
  
  ​    在**弹性盒没有设置垂轴尺寸**时,能应用stretch的弹性元素的垂轴方向的尺寸**会默认与当前主轴上最宽/最高的那个弹性元素一样宽/高.**如果当前主轴上的行/列弹性元素都可以应用stretch,则此时弹性元素的宽/高度为其内容区宽/高度.
  
  ​    在弹性盒**设置了垂轴尺寸**,则能应用stretch的弹性元素的垂轴方向尺寸将**默认是整个弹性盒的内容区的宽/高度**.
  
  ​    PS:弹性元素的**外边距也会被计算进去**,只不过不会被显示而已.就和其他的定位元素一样,外边距会被计算.<定位.md>>
  
  - **flex-start**:
  
  即把所有弹性元素向垂轴的起边对齐.(会计算外边距)
  
  - **flex-end**
  
  把所有弹性元素向垂轴终边对齐.(会计算外边距)
  
  - **center**:
  
  把所有弹性元素沿着垂轴居中对齐.(会计算外边距)
  
  - **baseline**
  
  基线对齐(大概):主轴上的某个弹性元素: 离垂轴起边之间的距离最远的那个弹性元素(会计算外边距),会和垂轴起边对齐,其他同行/同列的弹性元素则与它基线对齐(即内容区中的内容的基线对齐)P603 - P604
  
  - **stretch**续
  
  **默认值,**应用于垂轴上,即: 在没有设置其弹性元素任何垂轴尺寸时,弹性元素将自动占满整个垂轴空间,而主轴尺寸却可以设置,它不会受到stretch属性影响.

## align-self P606

- 针对单个弹性元素

翻译为:个人对齐,顾名思义,就是能控制弹性盒中**单个弹性元素**沿垂轴的对齐方式,此属性用于单个弹性元素上,可以覆盖弹性盒的align-items属性.

其取值和aligh-items属性一模一样,意思也一模一样,它们之间的唯一区别则是:**一个用于弹性盒控制所有弹性元素的垂轴对齐方式**;

**一个用于弹性元素控制单个弹性元素的垂轴对齐方式.**

## align-content P607

- 用在弹性容器上,针对的是弹性元素,即弹性盒中的弹性元素

- **此属性对齐的是弹性盒中的弹性框,align-items对齐的是弹性盒中的全部弹性元素,如同栅格布局中的这些属性一样.**
  
  *详情请看<栅格布局.md>*

该属性与前文讲到的justify-content属性在取值和相关概念上一致的.只不过align-content属性控制的是其所有弹性元素在垂轴方向上的对齐方式,而后者控制的是主轴方向上的对齐方式.

由于其相关概念和justify-content一样,这里我就不在讲属其属性值的用处了.P607-P612

这个属性咋一看可能会和align-item属性搞混,但是其实很容易区分:

- align-item属性控制的弹性元素是以行/列为整体,操作对齐方式的,且对一行或禁止换行的 弹性元素也有影响.
  
  align-content属性对一行或禁止换行的元素没有影响,且是以所有弹性元素为整体进行操作的.

- 例如: align-item:flex-start;  align-content:start;
  
  它们两个表现的形式为:
  
   **align-content:start;**
  
  ![](../CSS之保存图片\align-items和align-content的区别.png)

  **align-item:flex-start;** 

![](../CSS之保存图片\align-items和align-content的区别2.png)

## flex 属性 P616

- 以下三个属性的简写属性，从左->右分别为：flex-grow flex-shrink flex-basics

### flex-grow P618

- flex-grow 属性定义：当弹性容器存在多余空间时，是否允许设置了该属性的弹性元素增大；以及当弹性容器允许增大时，相对其他同辈弹性元素以什么比例增大。
  
  即：决定弹性元素在弹性容器存在多余空间时是否可以增大，且相对于同辈弹性元素来说，以什么比例增大（根据该属性的值进行弹性容器的多余空间分配）

- flex-grow 属性的值只能为数字，且 >=0 即可，可以为小数。

- flex-grow 的默认值为 0.

- flex-grow 属性无论设置的多大，都不会超过弹性容器的大小，但是设置该属性的弹性元素可能会使得弹性容器的主轴上被占满。

### flex-shrink P625

- flex-shrink 属性定义：弹性缩减因子，当弹性容器的空间不足以放下所有弹性元素时，当前设定 flex-shrink 属性的弹性元素将相对于其他同辈弹性元素缩小多少。
- 若 flex 和 flex-shrink 属性都未设定弹性缩减因子，则所有弹性元素的缩减因子默认为 1

### flex-basics P635

- felx-basics 属性定义：弹性元素的初始或默认尺寸。
  
  即：在根据 flex-grow 属性和 flex-shrink 属性分配多余或缺少的空间之前，设置弹性元素的初始或默认尺寸。

# 略过的

## P590 - P596略过

- justify-content的详细举例

## P612 - P656略过

- 关键是flex属性以及一些其他属性