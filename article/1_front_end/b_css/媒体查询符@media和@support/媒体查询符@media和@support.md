[TOC]



# media(媒体)查询P28-36,P998-1023

## 描述

创作人员通过媒体查询(media query)定义浏览器在何种媒体环境中使用指定的样式表.

过去,实现这一机制的方法是通过\<link>元素或\<style>元素的media属性设定媒体类型,或者为@import/@media指定提供媒体描述符.

现在,我们可以使用媒体查询,允许创作人员通过媒体描述符根据指定媒体类型的特性选择样式表.



## 大概用法

### 简介

媒体查询能在以下几个地方使用

- link元素的media属性
- style元素的media属性
- @import声明的媒体描述符部分
- @media声明的媒体描述符部分

媒体查询可以是简单的媒体类型,也可以是复杂的媒体类型和特性的组合.

## 必知道的基础知识

### 媒体类型

媒体查询最基本的形式是媒体类型,即当前浏览网页的是何种媒介(媒体),如:screen媒体, print媒体等.

**其中常用的有:**

- all 用于所有媒体类型
- screen 用于屏幕媒体类型,如电脑显示器,手持设备,
- print	用于打印机(非盲人).
- speech 语音合成器,屏幕媒体,或其他音频渲染设备.

**不常用的有**:不常用的都被弃用了.

**已经被弃用有:**

-  aural 用于语音和音频合成器.
- handheld 用于小的手持设备
- braille	用于 盲人用点字法触觉回馈设备.
- embossed	用于分页的盲人用点字法打印机.
- tty	用于使用固定密度字母栅格的媒介,比如电传打字机和终端.
- tv	用于电视机类型的设备.

### 媒体描述符和逻辑关键字

#### 描述

一个媒体描述符,由一个媒体类型 + 0个/多个特性描述符构成,其中特性描述符要写在圆括号中,且如果有多个媒体类型,则要使用逗号分割.

如果未指定媒体类型,而直接写了媒体特性描述符,则会默认媒体类型为all.

- 媒体描述符可以分为

  ​	**媒体类型描述 1个**

  ​    媒体(类型和特性)描述符指的是:当前的媒体类型是否为指定的类型,如果是则应用内部样式,反之不应用.

  ​	**媒体特性描述 1个/多个**

  ​		指定的某个/多个特性是否存在于当前媒体类型,如果条件为true,则应用里面的样式,反之不应用.

- 逻辑关键字

  ​	逻辑关键字则是: 当使用多个媒体(特性和类型)描述符时,不仅需要使用园括号将特性描述符括起来,

  ​		还要使用逻辑关键字:and 连接,同时也存在 not  / only关键字执行一些特殊的行为.(请看:逻辑关键字)

且对于媒体描述符来说,如果想写多个媒体类型描述,需要使用逗号隔开*(两个满足一个就应用)*; 

而以下的特性查询则不能使用逗号,要使用or.*(如果想同时满足多个特性,则要使用and)*

即媒体描述符中的逗号 和 特性查询中的or效果是一样的,代表或者;而and都是代表两个条件都要为真

注意:媒体特性描述符是有取值的,我们无法杜撰一个,这不像特性查询那样,可使用CSS属性来判断.

#### 媒体描述符

##### 描述

媒体描述符可以分为

1. **媒体类型描述**

   ​	如screen,prinit这样的媒体类型

2. **媒体特性描述**

   ​	即某个媒体类型它的特性是什么,或者说它的参数是什么,例如:gird:1 / 0,

   ​	即当前媒体类型是否是基于栅格的设备,如果是,则应用里面的样式,反之不应用.

##### 媒体类型描述符

当前媒体类型是否为指定的类型,它是否存在某个/多个指定的媒体特性(不是CSS属性),如果条件为true则应用内部样式,反之不应用.

```css
@media screen {
	color:red;
    height:600px;
}
```

当前的媒体类型为screen就应用内部样式

##### 媒体特性描述符

以下为使用了一个媒体描述符的情况:

```css
@meida screen and (orientation:landscape) {
	display:grid;
	grid: 
		"1 1 1" 1fr
		"2 2 2" 1fr / 30% 40% 30%
}
```

如果当前媒体类型为screen类型,且此类型存在orientation:landscape特性,即该媒体类型如果宽度比高度大, 则应用display 和 grid属性样式,否则不应用.

#### 逻辑关键字

连接媒体多个[特性]描述符的逻辑关键字,有三种

1. **and**

   ​	判断当前媒体类型是否存在支持多个特性描述符,每个特性描述符之间使用and连接.

   ​	`@meida screen (max-width:400px) and (orientation:landscape and ...{...}`

   ​	其意为: 当前的screen媒体类型,它的最大宽度是否为400px,且宽度是否比高度大,

   ​	如果同时满足以上两个条件,则应用内部样式,否则不应用.

2. **not**

   ​    只能使用在最开头,即只能紧跟着媒体查询(@media)/ url()的后面/link元素的那里(可以自己了解一下),无法使用于特性描述符之间.

   ​	其意为:如果not后面的所有特性描述符为真,则不应用内部样式,为假才应用.

   ​	`@media not screen (min-color-index:64) and (grid:1)`

   ​	在screen媒体类型中,如果该类型的色彩搜寻列表中存在64位颜色及以上, 且是基于栅格的输出设备,则不会应用内部样式,反之则应用.

   ​	`@import url(xx.xx) not screen and (grid:1);`

   ​	导入的样式不在screen媒体类型上且不是基于栅格的输出设备,才会应用此样式,否则不应用.

3. **only** P31, P1003

   ​	此关键字存在的唯一目的即:保证向后兼容.

   ​	与not关键字一样,只能紧跟着媒体查询(@media)/ url()的后面,无法使用于特性描述符之间.

   ​	其意为:在不支持媒体查询的旧浏览器中隐藏样式内容.如果支持,则所有的样式会被应用,且only关键字会被忽略

   ​	` @media only screen and (grid:1) {}`

   ​	`@import url() only screen and (grid:1);`

   ​	如果在screen媒体类型中的浏览器中打开有关于此样式的网页,如果该UserAgent支持这种媒体查询方法,则应用内部样式,

   ​	且忽略only关键字,如果不支持这种媒体查询,则忽略整个媒体查询包括里面的样式.

#### 总结

请注意媒体查询中的媒体特性描述符和特性查询中的CSS样式的区别,它们并不是同一种东西.

- **媒体特性描述符**: 指的是当前媒体存在某个/多个特性,例如当前媒体的宽度,高度,是否基于栅格布局的设备,又或者有关媒体的其他特性.
- **特性查询**:指的是当前媒体类型中,使用浏览器打开有关的网页时,该浏览器的UserAgent是否支持某个/多个CSS的样式(特性).

### 特性查询

#### 描述

特性查询即使用**@supports**关键字,作为其基石.

其功能为:**根据用户代理是否支持特定的CSS属性及其值来应用一段样式,**该能是2015-2016年之间新增的一个功能,我们将之命名为: 特性查询(feature query).

特性查询可以和媒体查询**相互嵌套**,是的,相互! 特性查询能嵌套媒体查询,媒体查询也能嵌套特性查询, 只有满足了它们各自的条件才会应用内部样式.

且对于多个的特性查询来说,不是使用逗号分割,而是要使用**or关键字 / and关键字**分割多个特性查询, 以上的媒体描述符,如果想写多个媒体类型描述,则需要使用逗号隔开,这两种者的区别要注意.

**即媒体描述符中的逗号 和 特性查询中的or效果是一样的,代表或者,而and都是代表两个条件都要为真**

#### 注意

这是特性查询,不是正确性查询,浏览器可能支持所测试的特性,但在实现时可能有缺陷.

所以我们无法确保浏览器对特性的支持是否正确,特性查询的结果很简单,即:如果为真,表示浏览器支持你指定的特性,而且以某种方式实现了. (但可能不是你想要的那种)

且**（浏览器）特性查询和媒体特性查询是不一样的**，@supports 指的是当前浏览器是否支持某个属性；而媒体特性描述符（(max-width:375px)）指的是当前媒体是否满足某个条件。

#### 语法

`@supports(color:black) {CSS样式}`

注意,color:black;中的black和color都不能省略,或许你想问为什么无法省略black属性值,

这是因为有些浏览器或许支持color这个属性,但不一定支持里面的全部属性值,所以在定CSS规范是,注明了无法省略属性值.

#### 实例

##### 特性查询

```css
@supports (display:grid) {
    display:grid;
    color:red;
}
```

当前的User Agent是否支持display:grid这样的属性(包括该属性),如果支持,则应用内部样式,反之则不应用,即整段代码都会跳过.

##### 相互嵌套的特性查询和媒体查询

```css
/* 特性查询嵌套媒体查询 */
@supports(display:grid) {
    @media screen and (max-width:375px) {
		colro:red;
    }
}
/****** 等效于 ******?
/* 媒体查询嵌套特性查询 */
@media screen and (max-width:375px) {
    @supports(display:grid) {
        color:red;
    }
}
```

上面的两段代码是等效的目的,即: 当前的媒体类型是否为screen类型,其最大宽度是否为375px,

且当前打开此网页的浏览器的User Agent是否支持display:grid这样的属性;

如果以上条件都为true,则应用内部样式,反之不应用.

##### 多个特性查询使用or和and关键字分割

```css
@supports(color:red)and(display:grid)or(display:flex) {
    display:grid;
    height:600px;
}
```

即如果User Agent支持color:red和display:grid 或是 display:flex这样的属性,就应用内部样式,反之则不行.

## 详细用法

### @media声明的媒体描述符部分



@media声明的媒体描述符可用于内嵌的\<style>标签中,也可以用于外部关联样式表中.

不论是用于外部样式表还是内嵌在\<style>样式表中,@media可以在任意地方使用,

**注意,这里的任意地方指的是**: 不嵌套在任何选择器内部,即@media媒体描述符的父元素只能为\<style>元素,或没有,除此之外,都无法被识别.

### 用于\<sytle>标签的@media

#### 语法

```css
/* 直接用于<style>元素中. */
<style>
    @media 媒体类型 {
        应用的样式...
    }
</style>
```

如果当前媒体类型为XXX,则应用以下样式.

需要注意的是:@media块中的规则可以不缩进,如果你觉得缩进更易于阅读,那就缩进.

#### 实例

```css
<style>
    @media screen {
        color:red;
    }
</style>
```

如果当前媒体类型是屏幕媒体(如桌面电脑的显示器),则应用color:red样式及这里面的所有样式

### 用于外部样式表的@media

#### 语法

```css
@media 媒体类型 {
	应用的样式...
}
```

#### 实例

```css
@media screen {
	color:red;
}
```

### @import和link元素中使用媒体查询

#### link元素中使用

`<link rel="" type="" href="xx.xx" media="print and (color)"/>`

#### @import中的使用

注意:@import只能用于style元素标签中,其他地方无法使用

`@import url(xx.xx)print and (color),screen and (color-depth:8);`

## 详解媒体特性描述符P1004 - P1006

### 基于视区/屏幕大小的特性描述

#### 以下二者的取值

\<length>,即只能为长度单位.

#### 基于用户代理显示区域的宽/高的特性描述

##### 描述

这和下面的基于输出屏幕的宽/高度有什么区别呢?

即一个移动设备中,用户代理所在的浏览器的显示区域可能只有屏幕大小的2/3,而这个特性就是基于这个2/3来添加/改变样式的.

##### width/min-width/max-width

**指用户代理显示区域的宽度.**

- 对屏幕screen媒体来说,指Web浏览器中视区+滚动条的宽度.

  ​    对于用户代理显示区域的宽度来说,滚动条的宽度是对显示区域的宽度是有影响的,因为滚动条会占据一定的显示区域宽度.*(此时的内容区宽度 = width值 + 滚动条宽度.)*

  ​	比如:(min-width:500px)这个特性描述符指的是: 在屏幕媒体中,如果视区宽度大于或等于500px时,内部的样式就会被应用.

  ​	这里之所以和下面的height不一样,是因为因为500px指的是显示区域的宽度,而显示区域的宽度 = 内容区宽度 + 滚动条宽度.

- 对分页媒体来说,指页面框的宽度.

##### height/min-height/max-height

**指用户代理显示区域的高度**

- 对屏幕screen媒体来说,指Web浏览器中视区+滚动条的高度.

  ​    对于用户代理显示区域的高度来说,滚动条的高度是对显示区域的高度没有影响的,因为滚动条是内嵌在显示区域中的.

  ​	比如:(min-height:500px)这个特性描述符指的是: 在屏幕媒体中,如果视区高度正好等于500px时,内部的样式就会被应用.

  ​	并不是宽度的大于或等于.

- 对分页媒体来说,指页面框的宽度.

#### 基于输出设备屏幕的宽/高的特性描述

##### 描述

(这里指屏幕媒体) 什么是基于输出设备屏幕的宽/高呢?即就是指当前设备屏幕的宽度和高度,这通常是固定值(除非有一些BT的折叠设备),

不像上面基于用户代理显示区域的宽/高是个动态的(会根据浏览器的显示区域摇摆不定,很显然,一个设备中,存在多个浏览器是很正常的)

##### device-width/min-device-width/max-device-width

**指输出设备中整个渲染区域的宽度.**

- 对于屏幕screen媒体来说,指屏幕的宽度,即手持设备的屏幕或桌面显示器的横向尺寸.

  ​    如:(max-device-width:1200px)指的是,在设备屏幕的宽度小于或等于1200px时应用内部样式.

- 对分页媒体来说,指页面自身的宽度

##### device-height/min-device-height/max-device-height

**指输出设备的屏幕的高度.**

- 对于屏幕screen媒体来说,指屏幕的高度,即手持设备的屏幕或桌面显示器的纵向尺寸.

  ​    如:(max-device-height:400px)指的是,在设备屏幕的高度小于或等于400px时应用内部样式.

- 对分页媒体来说,指页面自身的高度

### 基于视区/屏幕大小的宽高比值

#### 以下二者的取值

<ratio> 比值. 即值的是视区/屏幕大小宽度和高度的比值,用斜杠分割,前面为宽度,后面为高度,通常为正整数.

#### 基于用户代理显示区域的宽高比值

##### aspect-ratio/min-aspect-ratio/max-aspect-ratio

**指媒体特性width与媒体特性height的比值.**

如:(min-aspect-ratio:2/1),指的是: 当前的媒体类型中,其浏览器的视区宽度和高度的比值**至少**为2:1时才应用内部样式.

#### 基于输出设备屏幕的宽高比值

##### device-aspect-ratio/min-device-aspect-ratio/max-device-aspect-ratio

**指媒体特性device-width与媒体特性devic-height的比值.**

如:(device-aspect-ratio:16/9), 即: 当前屏幕的显示区域宽度和高度比值**正好**为16:9时才应用内部样式.

### 有关颜色特性的描述符

#### 以下三者的取值

<integer>,即只能为正整数.

#### color/min-color/max-color

**判断是出设备是否支持彩色显示,可选的数值表示每个色彩分量使用的位数**

因为只要设备有色彩深度,则(color)特性描述符在没有取值的前提下就会起作用,如果赋予了值,其意义就变了,如:

(min-color:4)的意思是:每个色彩分量至少有4位,不支持彩色的设备返回0.

注意:min-color/max-color这连个特性描述符必须赋值才会有用.

#### color-index/min-color-index/max-color-index

**指输出设备的色彩搜寻列表中共有多少颜色.**不适用色彩搜寻列表的设备返回0

因此,(min-color-index:256)指的是: 在至少有256个颜色可用的设备中起作用.

#### monochrome/min-monochrome/max-monochrome

**判断当前设备的显示屏是不是单色的,可选的数值表示在输出设备的帧缓冲器中每像素有多少位.非单色设备返回0.**

即只要是单色设备(monochrome)特性描述符就起作用,

而(min-monochrome:2)的意思为:输出设备的帧缓冲器中每像素至少有2位.

### 用户代理的显示区域的放置方向

#### orientation 方向

##### 描述

**指用户代理的显示区域的放置方向,即用户代理的显示区域此时是横向放置还是纵向放置的.**

当用户代理的显示区域的height值大于或等于width时,返回portrait,只要当height小于width时,才返回landscape.

##### 取值

portrait | landscape

- portrait 纵向
- landscape 横向

### 输出设备的扫描方式的特性描述符

#### scan

##### 取值

progressive | interlace

##### 描述	

**指输出设备使用的扫描方式.**

大多数现在设备的显示屏都成采用progressive,而CRT和某些等离子显示屏一般才使用interlace.

### 判断是否为基于栅格的输出设备

#### grid

##### 取值

0 | 1

##### 描述

**判断当前设备是否为基于栅格的输出设备.**

基于栅格的设备取值为1,不基于栅格的设备取值为0.该特性描述符可用于代替旧的tty媒体描述符.

### 关于分辨率resolution/min-resolution/max-resolution

P1005

## 注解

媒体查询是(2020/3/29)响应式Web设计的基础,*而特性查询是判断某个User Agent支不支持某个属性的关键用法.*

根据媒体类型(显示环境)的不同应用不同的规则,从而让我们能将针对"移动设备"和"桌面系统"的样式写在一个样式表中.

"移动设备"和"桌面系统"打引号的原因是因为,2020年时,这两者之间的界限越来越模糊了,比如:一台带有触摸屏的笔记本, 一个可以折叠的手机等.

------

所以基于这个而言,现在的响应式布局只是靠猜,只不过通常情况下猜对的概率是很大的,至于为什么说是猜呢?例如:

​	iPhone6plus的分辨率为1242 × 2208,降低采用后为1080 × 1920,那么以此作为基础让媒体特性描述符去判断是否应该为此应用样式,是完全合理的.

​	但是,iPhone6plus还维护者一个内部点数坐标系,尺寸为414 × 736,那么以此作为基础让媒体特性描述符去判断是否应该为此应用样式,也是完全合理的.

​	那么问题来了,到底该应用哪个呢? 在预期情况下,我们只想使一类设备对应一个媒体类型和其特性, 但是iPhone6plus可以对应两个,并且都能被应用样式,

所以现在应该根据样式优先级去判断谁覆盖谁,其中的哪些属性不会被另一个内部样式的属性覆盖,而这就造成了,后期极难维护,以及可能会造成意料之外的样式.

---

而除了这种情况之外,还有许多会导致特性描述符和媒体查询无法准确识别在它目前在哪个媒体上显示,所以我才说,响应式布局是靠猜的.

但是我们却可以运用CSS自身良好的属性去让这猜的结果更加准确,比如:使用相对单位去应用在媒体特性描述符上,不束缚于固定的值(如px等).

```css
/* 以下媒体查询通常支持小屏设备 */
@media (max-width:20em) {
	some style...
}
```

以这样的方式,或许能让我们猜的结果更加准确,但是这并不是一定的,因为这个媒体查询会受限于当前设备的尺寸的限制,

这个实例的意为: 当前所在的任何媒体类型,其宽度小于或等于20em大小时,就应用内部样式.

但是设备的大小不可能是不变的,而你永远不知道下一个新出来的设备会不会超出你的预料.

----

而且如果你想使用orientation这个媒体特性描述符,其实可能会导致意外地后果:

```css
/* 横向应用此样式 */
@media (orientation:landscape){
	当浏览器的显示区域宽度 > 高度时,应用此样式
}
/* 纵向应用此样式 */
@media (orientation:portrait){
	当浏览器的显示区域宽大 <= 高度时,应用此样式
}
```

以上示例,看似非常简单,而且这样使用特性描述符来判断是不是智能手机似乎也挺不错的,但是却可能会造成意外地后果,因为orientation描述符太依赖于视区的height和width值了.

所以这就会造成如果一个桌面浏览器窗口的显示区域的width和height刚好一样大又或者高度>宽度,则使用以上实例,此桌面浏览器窗口的样式将会应用竖屏样式

这显然是不对的,所以我们刚才猜的(假定)"竖着放的就是智能手机",桌面用户显然不可能同意,他们甚至想打人!

-----

而我们说了这么多,只是想表明一点: 响应式设计很强大,但是与其他任何强大的工具一样,使用时要深思熟虑,格外谨慎. 

请仔细考虑每个特性查询的影响,因为这是成功运用响应式设计的最低要求.

## 分页媒体 P1008 - P1023



# 设计稿尺寸

设计稿的目的,就是如同让你照着一个页面"抄".

浏览器默认字体大小是16px,所以此时1rem=16px,但是如果我们想让1rem=10px,则: x * 16px = 10 =>0.625=62.5%,

这样做的目的是让浏览器默认的字体大小等于10px,并让1rem=10px.这是为了子元素的相关尺寸计算方便,

**理由:**

​	*比如,移动端由于设备有各种大小,所以我们得使用相对长度单位把,em也可以用,但是它相对于父元素大小计算的,而每个父元素的大小都可能不同,总不能每个都计算一遍吧?* 

​	*所以使用rem最好,它相对于根元素大小,而根元素每只有1个,不用费心费力考虑每个父元素的大小了.* 

​	*但是我们知道User Agent默认的根元素大小为16px,这就造成了一个问题,不好进行计算,比如,1.5rem = 1.5*16,口算不好的同学,还可能是用计算器,极大的浪费了时间,是不.*

​	 *所以我们为什么不让根元素大小的font-size变成10或者100或者1000这些好计算的数值呢?* 

所以才有了将根元素的font-size属性值改为10px和62.5%的需求出现. 但是10px这种固定单位限制比62.5%来得大,所以我们采用了62.5%, 可是62.5%又可能会造成一些User Agent适配的问题(看下面), 

​	*例如:谷歌浏览器的某个版本,其font-size:62.5%为10像素时,而谷歌是不支持小于12像素的字体的,所以,谷歌会无形当中强制将所有的rem全部变大了(因为不支持,所以强制拉大至少等于12px).*

​	*所以现在所有的地方都错位了,chrome在字体小于12px时都当12px 处理,也就是设置62.5%相当于设置成了75.0%.*

​	*但是在在做除法的时候又是除的10得到的rem值,那么就会导致用rem作为单位去作为元素的大小,则实际上会被chrome自动变得更加大一号,这样子当然会错位.*

​	*针对这个现象,可以尝试设置html字体为625%,即1rem = 16 乘625% = 100px,此时再把rem的计算除10就能得到 : 0.1rem =10px,*

​	*然后再将body 修正为16px,就相当于body的字体仍然是默认大小,不影响未设置大小的元素的默认字体的大小.通过以上的做法,就不担心有出现chrome这样的情况了.*

所以我们又使用625%, 至于为什么不适用6250%,这是因为没必要,1是数值太大也不好,二是很大概率用不上.

且极少的用户代理的默认值在少部分情况下(用户自己改了)默认值可能不等于16px,又可能会有用户自己改变了分辨率,字体大小等这些情况发生,如果始终默认为10px,则可能会造成页面的"垮掉",

所以我建议使用625%这样的属性值,这样更符合绝大多数用户的需求,也可以稍微自适应被改变的分辨率或者默认字体大小等.



less:

```less
//变量
@baseFont: 100px; //定义基础字体 ; 可能定义的是rem的字体大小, 相当于625%

@psdWidth: 640px; //设计稿尺寸

@deviceWidth: 320px, 360px, 375px, 411px, 414px, 520px, 640px, 1024px; //常见的设备的尺寸数组,需要适配的设备屏幕?宽度

@len: length(@deviceWidth); //数组长度 得到上面的长度

@unit: 1rem / @baseFont; //单位 即参见<页面的适配.md>,相当于0.1rem = 10px,即只要使用这个变量就能获取正常的rem大小.

@mainColor: #03f00f; //主颜色

```

正常情况下,浏览器的认的字体大小:16px,

但是,这是任何的终端的浏览器都是16px,比如我电脑中的浏览器,移动设备中的浏览器都是16px,这就造成了一个问题: 

由于电脑显示屏较大,显示16px大小的字体或许刚刚好能让人很舒服,但是手持设备呢?它们的显示屏通常比电脑小很多,此时,如果在让浏览器的默认字体大小为16px,这就有点不太好了,可能会让字体显示较大.

所以在基于用户的体验上,我们需要考虑设备的宽度去改变浏览器的默认字体大小,除此之外,还要根据设计师(根据屏幕大小)设计出来的设计稿尺寸去改变默认字体大小,从而让元素中的字体大小在各个终端中表现良好.



# meta

```html
<meta name="viewport" content="width=device-width,initial-scale=1" />
```


这段代码是适配移动端时非常重要的一段代码.

- **name="viewport"**

  指浏览器的视区

- **content="width=device-width"**

  将设备的宽度 赋值给浏览器视区宽度. 此时就相当于浏览器视区宽度等于设备宽度

- **initial-scale=1"**

  初始化缩放比例,将当前的浏览器布局窗口认为是已经缩放过后的,并让这缩放过后的视区宽度等于设备宽度

  相当于width=device-width











