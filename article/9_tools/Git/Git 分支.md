# Git 分支

PS：在看本节时，请和[原文](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B)（Git 官网的文档）一起看。

## [分支简介](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B)

几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。

Git 的分支模型可以称为它的“必杀技特性”，因为 Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 

与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。

也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。

为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。或许你还记得 [起步](https://git-scm.com/book/zh/v2/ch00/ch01-getting-started)***（详见：What is the Git）***的内容， Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 **快照** 。

下面让我们来了解一下一些关键概念：

**暂存操作：**会为每个需要暂存的文件计算校验和（*使用我们在 [起步](https://git-scm.com/book/zh/v2/ch00/ch01-getting-started) 中提到的 SHA-1 哈希算法）*，然后还会把当前 Repository 的当前版本在暂存区中的文件快照*（暂存区的文件）*保存到 Git 仓库中，最终将校验和加入到暂存区域等待提交。

**blob 对象：**Git 会使用 blob 对象保存一个因暂存操作从而生成的文件快照，其中 blob 对象和生成的文件快照是一一对应关系。

**树对象：** Git 计算的当前版本的 Repository 的每一个子目录的[文件]校验和，树对象记录着目录结构和 blob 对象索引。

**提交对象：**在进行提交操作时，Git 会保存一个提交对象（commit object），知道了 Git 保存数据的方式，我们可以很自然的想到——提交对象包含一个指向暂存区文件快照的指针*（指的是 blob 对象）*、作者的姓名和邮箱、提交时输入的信息、指向它的父对象的指针*（首次提交时不存在，因为首次提交没有父对象：指上一次提交时所生成的提交对象*）以及指向树对象的指针。

**父对象：**当前提交对象的上一次提交的对象，称之为父对象。

通过提交对象，Git 就可以在需要的时候重现此次保存的快照，因为提交对象包含所有 Repository 中某个提交的版本的信息*（[使用git commit  生成的快照](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F#_%E7%9B%B4%E6%8E%A5%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7%E8%80%8C%E9%9D%9E%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83)，**详见：What is the Git - 直接记录快照，而非差异比较**）*。

![](.//picture/Git 分支-首次提交对象及其树结构.png)

（Git 分支-首次提交对象及其树结构）

通过以上图图片，我们可以发现：98aca9(第1次提交)没有父对象，92ec2(第2次提交）的父对象为 98ca9；

且每个提交对象都存在上面 *提交对象* 概念中所说到的信息，至于这里的第1次的提交产生的提交对象不存在 blob 对象，是因为这次提交并没有任何暂存区中的文件

做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针，如：98ca9 提交对象实际上是 92ec2 的父对象，或如下的 34ac2 提交对象是 f30ab 提交对象的父对象。

![](.//picture/Git 分支-提交对象及其父对象.png)

## 什么是 Git 分支？

**校验和**：***详见：Git 保证完整性（有关校验和）***

**Git 分支：**本质上仅仅是指向提交对象的可变指针。

在当前某个版本（某次提交[对象] / 某个分支）A 上，基于该版本创建的一个分支，该分支是从版本 A 派生出来的，

可以认为该分支是版本 A 的另一个版本，你可以使用 `git checkout <branchname>` 命令使得当前版本更改到 \<branchname> （切换到该版本)。

此时，Git Repository 中的文件也会跟着改变到 \<branchname> 的内容，即：一个分支，就相当于 Git Repository 的“平行宇宙”，虽然在基于某个提交对象 X（含）刚创建出来一个分支时，

该分支的所有信息会等于该提交对象 X，但是随着时间的增加，开发者更改该分支的信息（进行 git commit），该分支就开始和 X 提交对象分化出不同的信息，这种情况称之为分支（虽然叫做“平行宇宙”也挺好）

- 注：只要使用 `git checkout` 命令使得当前分支/校验和（提交对象）改变，则 Git Repository 中的内容也会跟着改变到指定的分支/提交。

也就是说：**一个新分支总是基于某个分支派生出来，从而可以使得新分支能在旧分支的基础上演变为不同方向的内容。**

一旦在当前所处的分支 A 中使用提交操作*（git commit，假设这次提交是最新的提交）*，则分支 A 会自动的移动到最新版本的提交*（分支中最后一次的提交）*。

且本次[提交时创建的项目快照](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F#_%E7%9B%B4%E6%8E%A5%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7%E8%80%8C%E9%9D%9E%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83)***（详见：What is the Git - 直接记录快照，而非差异比较）***就属于分支 A 的这次提交，其他分支则没有该次提交所创建的项目快照。

笔者注：每个分支默认情况下都存在于最新的提交中，但是你可以使某个分支移动到指定的历史提交中。

Note：Git 的 `master` 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。

## 指向相同提交历史的分支

若有两个分支都基于某个提交对象进行派生而来的，那么它们以该提交对象为分界线（含），则所有的父提交对象都是一样的。

![](.//picture/Git 分支-两个指向相同提交历史的分支.png)

（两个指向相同提交历史的分支）

master 分支和 testing 分支都是基于 f30ab 提交对象派生而来的，同时这两个分支此时都拥有相同的父提交对象：98ca9 和 34ac2。

对于 master 和 testing 两个基于相同的提交对象的分支来说，它们在今后进行提交时，将分裂出两个分支，除了 98ca9、34ac2、f30ab 提交对象相同，其他都会不同。

注意：分支之间是可以进行合并的（这点要知道，稍后会讲到），所以这会让我们可以灵活地使用分支，而不必担心某个分支对主线开发或其他分支有用，无法进行合并使用。

## 创建、重命名和删除分支

### 创建

`git branch <branchname>`：在当前所在的**提交对象**上创建一个分支（未 commit 的文件是不会存在于新分支的），但是并不会自动切换过去，而是停留在原分支。

`git checkout -b <newbranchname>`：该命令创建一个新分支，并立即切换过去。通常来说，使用这个命令创建新分支并切换过去，工作更具有效率。

`git checkout -b <newbranchname> <tagname/远程仓库分支/本地分支>`：

该命令可以使得创建的新分支的项目版本基于指定的 \<tagname/远程跟踪的分支/本地分支> 选项创建，

并且当指定的分支是某个远程仓库的分支时，创建的分支还会跟踪远程仓库的分支，最后 Git 会切换到新创建的分支*（详见：同级目录 - 远程分支）*

`git checkout <branchname>`：在当前 Repository 中，切换为指定的分支。

### 删除

`git branch -d <branchname>`：删除指定分支。

### 重命名

- **重命名本地分支**
  
  `git branch -m <oldbranchname> <newbranchname>`

- **远程分支重命名**
  
  1. 删除远程分支
     
     `git push origin :远程分支名(你要删除的远程分支名)`
  
  2. 将本地分支推送到远程分支上，如果远程分支不存在，则创建此远程分支
     
     `git push origin 本地分支名:远程分支名`

## HEAD 特殊指针

若一个 Repository 中，存在多个分支，那么 Git 是怎么知道当前在哪一个分支上呢？很简单，这个问题交给：HEAD 指针。

`HEAD 指针`：在 Git 中，它是一个特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。

![](.//picture/Git 分支-HEAD 特殊指针.png)

（HEAD 特殊指针）

从上图中我们可以发现，HEAD 指针指向 master 分支，这代表着现在 Git 处于 master 分支上，Repository 中的内容也是 master 分支的。

如果使用 git checkout testing 命令，切换分支到 testing 分支上：

![](.//picture/Git 分支-切换分支，移动 HEAD 指针.png)

（切换分支，移动 HEAD 指针）

在 *同级目录-什么是 Git 分支* 一节中有说过：在当前所在的分支中，更新版本后（git commit），当前所在分支会自动移动到最新版本，而做到这种操作的就是通过 HEAD 指针，如下：

下面我们不妨使得 testing 分支中的内容改变，并提交：

```bash
$ vim test.rb
$ git commit -a -m 'made a change'
```

![](.//picture/Git 分支-HEAD 分支随着提交操作自动向前移动.png)

（HEAD 分支随着提交操作自动向前移动）

如上图，我们可以发现：testing 分支自动移动到最新（最后）一次的提交对象，而 master 分支仍然停留在原地，我们当前所处的分支也仍然是 testing 分支。

现在让我们使用 git checkout master 命令使得当前所在分支切换到 master 分支，看看会有什么变化吧：

![](.//picture/Git 分支-切换分支时，HEAD 指针随之移动.png)

（切换分支时，HEAD 指针随之移动）

如上图，我们可以发现：HEAD 指针指向了 master分支，这也就代表我们当前所处的分支从 testing 移动到了 master；

那么 git checkout master 命令做了什么事情呢？

1. 使 HEAD 指回 master 分支
2. 将工作目录恢复成 master 分支所指向的快照内容

这也就代表着：你处于 master 分支上所做的修改，实际上项目会将始于一个较旧的版本（新版本是：testing 分支）。

本质上来说：这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。

现在，如果你更新了 master 分支的内容，又会发生什么变换呢？

```bash
# HEAD -> master 分支
$ vim test.txt
$ git commit -a -m "made a change"
```

![](.//picture/Git 分支-基于同一个提交对象所产生的不同分支.png)

（基于同一个提交对象所产生的不同分支）

如上图，我们可以发现：master 分支自动移动到了最新一次的提交中（48ue2）且 HEAD 指针也随着 master 移动，始终指向了 master 分支，这代表我们当前所处的分支仍然在 master 分支上。

也正是通过这个图，我们也可以清楚的知道：分支就是“平行宇宙”*（详见：同级目录：什么是 Git 分支）*，基于某个提交对象*（或者说基于某个版本，含这版本之前的所有信息，如：父对象，作者信息等）*所产生的不同方向的结果。

你可以通过 `git checkout` 命令 + 一些配置选项就可以在不同分支之间来回进行切换，当然了，除了能在分支之间进行切换以外，还可以使用每个提交对象的校验和 或 \<tagname> 进行切换到不同的版本（提交）中。

当然了，这种切换会使得 HEAD 指向执行一个没有分支名字的项目提交的历史版本，也就会让当前的 Repository 的状态处于：“分离头指针”状态。*（详见：同级目录 - 打标签 - 检出（切换）标签（有关分离头指针状态））*

## 查看项目分叉历史

创建了分支之后，Repository 的提交历史已经产生了分叉，项目就并不在是只存在一条主线，而是可以多个主线，多个支线。

如：创建了一个新分支后，开发者切换过去进行了一些工作，随后又切换回另一个分支进行了另外一些工作（在它们都有 git commit 下），这就导致刚才所说的：项目的提交历史已经产生了分叉。

我们可以通过 `git log` 命令查看分叉历史，如运行：`git log --oneline --decorate --graph --all` ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。

```bash
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
```

如果你对 `git log` 命令非常熟悉，你完全可以定制自己的输出结构，输出内容等，让查看项目的提交历史更为清晰，甚至你可以用一些外部工具做到这一点。

## 为什么创建和销毁 Git 分支如此快捷

在 *同级目录 - 分支简介* 一节中，我们有讲过创建和销毁 Git 分支快捷是很快捷的，但是并不知道为什么，现在可以稍微提一下大致概念。

因为 Git 的分支实质上仅是包含所指对象校验和*（长度为 40 的 SHA-1 值字符串）*的文件，所以它的创建和销毁都异常高效。 

创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单当然会非常的快。

这与过去大多数版本控制系统形成了鲜明的g比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完

成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。

 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。

## [分支合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

**git merge \<branchname>**：把 \<branchname> 合并到当前分支，\<branchname> 分支并不会自动删除。

分支合并：使用 `git merge` 命令的分支合并存在两种合并的方式：

### 快进（fast-forward）

当你指定的分支是当前分支的前继，或者说当前分支是指定分支的后继，那么 Git 会把你指定的分支合并到当前分支时，

也就是说：**若顺着当前分支（后继）一直往下走，能够到达指定的想要合并的分支（前继），那么 Git 会简单的将当前分支的 指针 向前推进到指定的分支，**

因为这种情况下的**合并操作没有需要解决的分歧**——这就叫做 “**快进（fast-forward）**”。

最后 Git 会在 Bash 中给你提示，让你知道你删除几行，添加了几行

如下图，使用如下命令：

```bash
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
```

![](.//picture/Git 分支-git merge 命令 fast-forward 分支合并.png)

（git merge 命令 fast-forward 分支合并）

其中 'Fast-forward' 指的就是 ‘快进’，即：由于 master 分支能顺着 hotfix 分支一直往下走且能到达 hotfix 分支，

所以这种情况下，Git 只会将 master 分支的指针简单的移动到 `C4`，而这并不会造成 `2（下面的第2点）`中的合并冲突，这种情况称之为：‘fast-forward’。

![](.//picture/Git 分支-git merge 命令 fast-forward 分支合并 成功.png)

（git merge 命令 fast-forward 分支合并 成功）

### 三方合并

指定想要合并的分支不是当前分支的前继，或当前分支不是指指定想要合并的分支的后继，

也就是说：**若顺着当前分支（后继）一直往下走，不能够到达指定的想要合并的分支（前继），那么 Git  不得不做一些额外的工作。**

即：**Git 会将当前分支和指定分支以及它们两个分支的公共祖先做一个简单的三方合并。**

如下图，我们使用以下命令：

```bash
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```

![](.//picture/Git 分支-git merge 命令 三方合并.png)

（git merge 命令 三方合并.png）

由于当前分支（master）一直往下走，无法到达指定分支（iss53）

所以 Git 会将当前分支 master 和指定分支 iss53 以及它们两个的共同祖先 C2（一个完整的项目版本），做一个简单的三方合并。

### [合并冲突](https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344)

当进行三方合并的时候，非常有可能因为两个分支的提交有所区别，导致合并时的冲突，这是很正常的事。

> 比如：一篇文章，我该开头，他也改开头，此时，Git 就会不知道如何合并，只好将冲突的地方进行标识，让你手动选择该保留哪个或重构等。

当遇到合并冲突时，Git 将会明确提示我们，你遇到了合并冲突：

```bash
Auto-merging readme.txt（准备合并的文件的名字）
CONFLICT (content): Merge conflict in readme.txt（在哪里冲突）
Automatic merge failed; fix conflicts and then commit the result.
```

同时，你还能在 Git 显示的分支名中看到是哪个分支和当前分支造成的冲突，其显示格式为：

```bash
XXXX ~/目录 (master|MERGING) # 左边是当前分支，右边是冲突分支
```

此时，你可以使用 `git status` 查看冲突的文件：

```bash
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   readme.txt # 冲突的文件
```

如果你想解决冲突，你只需要去到冲突的文件（在这里是 readme.txt），Git 会贴心到将你所冲突的代码完整的标识出来。即：Git 会把你准备合并到当前分支的冲突代码和被冲突代码进行标记，让你手动解决冲突。

**当你手动解决完冲突之后，请在当前再一次 `add` 和 `commit` 即可，这样分支就和并完成了。**

当然，你可能会有些担心你还没有准备好如何解决冲突，那么你可以按照提示输入：`git merge --abort`，就可以中止本次合并，使得你本次的合并操作跟完全没有做一样。

下面让我们来看看 Git 是如何标识文件中的冲突代码的吧：

```js
<<<<<<< HEAD(current change) # 表示当前分支的改变
我是当前分支
master
======= # 截止线，即：上面的是当前分支的 commit，下面的是即将合并分支的 commit
我是即将合并的分支
test
>>>>>>> test(imminent chagne) # 表示冲突分支的改变
```

圆括号中的内容，在 vsCode 中将会表现，其他位置可能不会表现出来。

### Notice

在进行分支合并-快进时，可能并不是你想象中的那样。

- 当一个分支 B 落后一个分支 A 时：
  
  你想要让 B 更新到 A，通常的操作是：将 A 合并到 B，这样 Git 就会判断 => A 领先于 B，故使 B 直接进行快进到 A。
  
  这样确实没问题，但是存在一个容易让人忽视的点：
  
  如果 B 中的当前提交对象存在一些 A 当前提交对象中【没有的但有用】的文件，则 **B 分支在被 Git 快进到 A 时，将会损失这部分文件**，总之：**B 分支一旦快进到 A，则就相当于另一个 A**，除了分支名不同行，里面的当前提交对象的文件都是一样的。

有时候这并不是你想要的，你可能想要的是：使得 B 存在 A 的文件，但是 B 自身独立的文件也仍然存在，而不是消失。

针对这种情况，你可以让“快进"变成“三方合并”，如：你基于 B 创建一个新分支 C，让 C 进行一次提交，这样 C 就不会在 A 的后面，而是类似于下图这种"二叉树"的模样：

![](.//picture/Git 分支-分支合并-快进时保留落后分支自身的文件.png)

​                                                                            （快进时保留落后分支自身的文件）

然后我们让 A 分支合并到 C 分支，这样由于 C 一直往下走无法到 A，Git 就会判断此时的合并属于三方合并，即：让 A、C、B 分支进行合并，这样即保留了 B 自身的文件，同时也存在了 A 的文件，最后用图表示如下：

![](.//picture/Git 分支-分支合并-解决快进时保留落后分支自身的文件的问题.png)

                                                                     （解决快进时保留落后分支自身的文件的问题）

当然，这会创建一个多余的新分支和一个 commit，不过你可以使用 rebase 解决这个多于新分支的问题，我们做同样的步骤流程，只需要把 merge 命令改成 rebase 命令即可：

那么（快进时保留落后分支自身的文件）这个图通过 rebase 将变成如以下图所示：

![](/picture/Git 分支-分支合并-使用变基解决快进时保留落后分支自身的文件的问题.png)

​                                        （Git 分支-分支合并-使用变基解决快进时保留落后分支自身的文件的问题）

使用变基在进行”三方合并“时，Git 会找到当前分支和指定分支（需要变基的分支）最近共同祖先，然后将该祖先到当前分支的所有提交中的不同之处提取出来并存储为一个临时文件，并使当前分支指向指定分支，再将该临时文件应用在指定分支上，同时抛弃当前分支

这样指定分支就拥有了祖先分支到当前分支的所有不同之处，且当前分支也消失了，同时也会产生一个新的提交，在祖先分支和指定分支的前面：C'（PS：图上的 C 非（快进时保留落后分支自身的文件）该图的 C.

更具体的了解变基，详见：上级目录-变基 rebase.

## [查看已合并或未合并到当前分支的分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86)

`git branch`：得到一个当前所有分支的列表。

`git branch -v/--verbose`：    在列表模式下，显示每一个分支和与之对应的最后一次提交。

`git branch -vv`：在列表模式下，显示每一个分支和与之对应的最后一次提交，以及显示每一个分支跟踪的上游分支（通常指远程仓库的分支）

`git branch -a`：查看所有本地分支和其对应的远程分支（若该本地分支有跟踪远程分支的话）；全红色代表该远程分支尚未和本地分支同步；若非全红，则代表本地分支和远程分支已同步。

` git branch --merged`：查看已经合并到当前分支的分支，合并到当前分支的分支会出现在列表中，注：这个列表中分支名字前没有 `*` 号（\* 代表当前分支）的分支通常可以使用 `git branch -d <branch>` 删除掉，因为你已经将它们的工作整合到了当前分支，所以并不会失去任何东西。

`git branch --no-merged`：查看未合并到当前分支的分支，未合并到当前分支的分支会出现在列表中，注：因为这个列表中的分支都是未合并到当前分支的分支，所以使用 `git branch -d <branch>` 命令删除列表中的未合并分支时会失败，但是你可以强制删除：`git branch -D <branch>` 

## [分支开发工作流程](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81)

下面是一些常见的利用分支进行开发的工作流程。

### [长期分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81#_%E9%95%BF%E6%9C%9F%E5%88%86%E6%94%AF)

使用 master（或者别的）分支作为主干分支，保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。

再使用如一些名为 `develop` 或者 `next` 的平行分支，用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 `master` 分支了。

这样，在确保这些主题分支（如用来做一些其他功能的分支等）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。

事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定（主干）分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。

![](.//picture/Git 分支-主干分支总是落后于其他分支.png)

（主干分支总是落后于其他分支）

通常把长期分支这种工作流程想象成流水线（work silos），这样子可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。

![](.//picture/Git 分支-趋于主干（稳定）分支的流水线（silo）视图.png)

（趋于主干（稳定）分支的流水线（silo）视图）

你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 `proposed`（建议） 或 `pu: proposed updates`（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 `next` 或者 `master` 分支。 

这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 

再次强调一下，使用多个长期分支的方法**并非必要**，但是这么做通常**很有帮助**，尤其是当你在一个非常庞大或者复杂的项目中工作时。

### [主题分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81#_topic_branch)

主题分支对任何规模的项目都适用，它是一种短期分支，用来实现单一特性或其相关工作。

即：利用 Git 的创建和销毁分支的快捷，从而使得一个新功能/新特性能使用创建一个分支的方式去实现它，实现完成后就可以将实现了该功能的分支合并到某个分支（如：主干分支或其他分支）上，最后再删除该分支。

 这项技术能使你快速并且完整地进行上下文切换（context-switch，即：某个版本完整的跳到另一个版本）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，

因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动；你完全可以把做出的改动在主题分支（拥有某个独立的功能，但主干分支没有的分支）中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。

### 总结

对于利用 Git 创建/销毁/合并 分支的快捷，使我们项目的开发工作流拥有了许多可能，值得一提的是：我们并非只能选择一种分支开发流程，你完全可以混合使用，选择一种或几种适合自己项目的开发流程。

注：当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并和创建分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。

## [远程分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF)

### 什么是远程引用

**远程引用：**对远程仓库（非本地 Git 仓库的仓库）的引用（指针）称之为远程引用，该远程引用包括但不限于：对远程仓库分支、标签等的引用。

可以使用 `git ls-remote <remote>` 命令来显式地获得指定的远程引用（即：当前本地 Git 仓库引用的远程仓库）的完整列表；或者通过 `git remote show <remote> `  命令获得远程分支的更多信息。

**远程跟踪分支：**远程跟踪分支是远程仓库中的分支状态的引用，所以也可以称之为远程分支引用，它们是你无法移动的本地引用（本地引用的远程分支），一旦你进行了网络通信， Git 就会为你移动这些远程引用以精确反映远程仓库中分支的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。

### 远程引用在本地仓库中的命名形式和使用 git fetch 命令

远程引用在本地仓库中以 `<remote>/<branch>` 的形式命名，如：你想要查看你最后一次与 origin 远程仓库通信时，该远程仓库的 master 分支的状态，则就是查看  `origin/master` 分支；

又或者如：你将一个本地分支 iss53 推送到了 origin 远程仓库上，则在本地仓库中，对 origin 远程仓库的 iss53 分支的引用的形式为：`origin/iss53`。

这可能有一点儿难以理解，让我们来看一个例子：假设你的网络里有一个在 `git.ourcompany.com` 的 Git 服务器。 

如果你克隆该服务器的 Git 仓库，Git 的 `clone` 命令会为你自动将该 Git 远程仓库命名为 `origin`，并拉取它的所有数据， 创建一个指向它的 `master` 分支的指针，并且在本地将其命名为 `origin/master`。 

同时，Git 也会给你一个与 origin 的 `master` 分支在指向同一个地方的本地 `master` 分支，这样你就有了工作的基础。

![](.//picture/Git 分支-克隆之后的服务器与本地仓库.png)

（克隆之后的服务器与本地仓库）

如果你在本地的 `master` 分支做了一些工作，在同一段时间内有其他人推送提交到 `git.ourcompany.com` 并且更新了它的 `master` 分支，这就是说你们的提交历史已走向不同的方向。 

即便这样，只要你保持**不与** `origin` 服务器连接（并拉取数据），你的 `origin/master` 指针就不会移动，因为此时你的本地 Git 仓库并不能知晓远程仓库所做的更改。

![](.//picture/Git 分支-本地与远程仓库的工作可以分叉.png)

（本地与远程仓库的工作可以分叉）

若你想要与指定的远程仓库同步数据，运行 `git fetch <远程仓库简写名> ` 命令*（在本例中为 git fetch origin）* （*详见：Git 远程仓库的基本使用 -从远程仓库中抓取与拉取）*即可。

该命令查找 \<远程仓库简写名> 是哪一个服务器*（在本例中，它是 git.ourcompany.com）*， 从中抓取本地没有的数据，并且更新本地数据库，最后移动 `origin/master` 指针到更新之后的位置。

![](.//picture/Git 分支-git fetch 命令更新远程跟踪分支.png)

（git fetch 命令更新远程跟踪分支）

### 推送本地分支到远程仓库上

`git push <远程仓库简写名> <需要推送的分支>` 该命令实际上是一个简写；
`<远程仓库简写名>`：使用远程仓库简写名来指代对应的完整的远程仓库的 URL，而其中的 `<需要推送的分支>` 

相当于，以下的命令：

`git push <远程仓库简写名> <本地分支:远程仓库分支>`：推送 \<本地分支> 到远程仓库上的 \<远程仓库分支>，也就是说使用`<本地分支:远程仓库分支>` 这样的方式，

可以推送本地分支到一个命名不相同的远程分支上，这样就不会受到第一个命令的限制：只能将本地分支推送到和本地分支名字相同的远程仓库的远程仓库分支上。

因为第一个命令的`<需要推送的分支>` 相当于：本地分支和远程仓库分支名是一样的。

 且注意：Git 将自动展开 `<需要推送的分支>`  为：
`refs/heads/需要推送的分支名:refs/heads/需要推送的分支`，这就意味着上面所说的意思：意味着，“推送本地的 `<需要推送的分支>` 分支来更新远程仓库上的 `<需要推送的分支>` 分支。”

我们将会详细学习 [Git 内部原理](https://git-scm.com/book/zh/v2/ch00/ch10-git-internals) 的 `refs/heads/` 部分， 但是现在可以先把它放在这儿。

Note：你在推送本地分支到远程仓库上时，Git 会提醒你输入 Github 账户和密码，那么如何避免每次输入密码呢？

如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。

如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 `git config --global credential.helper cache` 来设置它。

想要了解更多关于不同验证缓存的可用选项，查看 [凭证存储](https://git-scm.com/book/zh/v2/ch00/_credential_caching)。

### 从指定的远程仓库中删除指定分支

`git push <远程仓库服务器的简写名> --delete <branch>`：从指定的远程仓库服务器中，删除指定的分支。

注：这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。

### 跟踪分支和上游分支

**跟踪分支：** 跟踪分支是与远程分支有直接关系的本地分支；跟踪分支的目的就是跟踪上游分支（远程仓库的某个分支），即：跟踪该上游分支的变化（提交历史）；

如果在一个跟踪分支上输入 `git pull` 命令（*详见 Git 远程仓库的基本使用 -从远程仓库中抓取与拉取）*，Git 就能使该跟踪分支自动地识别去哪个服务器上抓取数据并将数据合并到当前分支 -> 也就是 Git 将自动使得跟踪分支跟踪的上游分支这个分支进行拉取数据并合并的操作。

**跟踪分支跟踪的分支叫做：**上游分支，通常指被跟踪分支跟踪的远程仓库的分支。

当克隆一个仓库时，它通常会自动地创建一个跟踪 `origin/master` 的 `master` 本地分支，当然，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 `master` 分支。

笔者注：`git push` 和 `git pull` 两个命令的英文单词有些类似，但是它们大相径庭，前一个是：更新远程引用以及相关对象（有关远程服务器的，推送数据到远程仓库这样子）；后一个是：从另一个存储库（可以是远程仓库）或本地分支获取内容并与当前分支合并。

### 创建自动跟踪远程仓库的分支的本地分支

使用 `git checkout -b <branch> <remote>/<branch>` 命令*（这里的 `<remote>/<branch>` 是一种书写形式，不是或者的意思）*可以创建一个跟踪 `<remote>/<branch>` 远程仓库分支的 `<branch>` 本地分支，并切换过去。

且新分支 \<branch> 的起始点位于 \<remote>/\<branch> 分支，并且新分支跟踪了远程仓库的对应分支。

例如以下例子：

```bash
$ git checkout -b serverfix origin/serverfix
```

创建一个基于 origin/serverfix 的新分支 serverfix，并且切换过去和跟踪远程分支 serverfix；

也就是说，创建的本地新分支 serverfix 的起始点位于 origin/serverfix 分支，并且本地分支 serverfix 跟踪 origin/serverfix 远程仓库的分支。

在 *打标签 - 检出（切换）标签（有关分离头指针状态）* 一节中，存在 
`git checkout -b <NewBrachname> <tagname> ` 命令：基于 \<tagname> 分支版本创建一个 \<NewBrachname>，并切换过去；当然了，由于这里是 \<tagname>，所以并不会跟踪 \<tagname> 对应的分支*（笔者并不知道这个意思对不对，应该对吧..）*。

### git checkout --track 命令跟踪指定远程仓库的分支

由于 `git checkout -b <branch> <remote>/<branch>` 命令是一个十分常用的操作，所以 Git 提供了 `--track` 快捷方式：

`git checkout --trach <remote/branch>`：

```bash
$ git checkout --track origin/serverfix
# 使本地 serverfix 分支跟踪 origin 的 serverfix 分支。
Branch serverfix set up to track remote branch serverfix from origin.

# Branch a set up to track remote branch b from <remote>：  使 a 分支跟踪 <remote> 远程仓库的 b 分支
```

### 设置当前分支跟踪指定的远程分支/修改当前分支跟踪的远程分支

 `git branch -u origin/serverfix`：设置或修改当前分支跟踪的远程分支（被跟踪的分支可以称之为上游分支：upstream）为：origin/serverfix。

```bash
$ git branch -u origin/serverfix
# 使当前分支 serverfix 跟踪 origin 的 serverfix 分支
Branch serverfix set up to track remote branch serverfix from origin.
```

上游分支的简写：当设置好跟踪分支（某个本地分支）后，可以通过简写 `@{upstream}` 或 `@{u}` 来引用它的上游分支。

所以在 `master` 分支时，且若它正在跟踪 `origin/master` ，则如果愿意的话可以使用 `git merge @{u}` 来取代 `git merge origin/master`：合并 origin/master 分支到当前分支。

### git checkout \<remote> 命令可能会自动创建一个跟踪分支

如果你尝试检出（切换）的分支 (a) 不存在且 (\<remote>/b) 刚好有一个名字与你切换的分支匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：

```bash
$ git checkout serverfix
Branch serverfix set up to track remote branch servegit checkout -brfix from origin.
Switched to a new branch 'serverfix'
```

也就是说：当你使用 `git checkout <branchname>` 命令切换到一个不存在的分支时，此时，若远程仓库的远程分支中存在一个名字和你指定的切换的分支名：\<branchname> 是一样的，则 Git 将会自动帮你创建一个基于 \<branchname> 的跟踪分支，而跟踪分支跟踪的分支就是：远程仓库名/\<branchname>。

### 查看设置的所有跟踪分支

`git branch -vv`：查看设置的所有跟踪分支，左边为本地分支名，本地分支的最后一次提交或可能包含该分支跟踪的远程分支，或与本地分支是否是领先、落后或是都有。

```bash
$ git branch -vv

# 这里的 * 代表当前所在的分支，如同 HEAD 指针一样。
iss53  7e424c3 [origin/iss53: ahead 2] forgot the brackets
master 1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
testing   5ea463a trying something new
```

这里可以看到 `iss53` 分支正在跟踪 `origin/iss53` 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 

也能看到 `master` 分支正在跟踪 `origin/master` 分支并且是最新的。

接下来可以看到 `serverfix` 分支（当前所处的分支）正在跟踪 `teamone` 服务器上的 `server-fix-good` 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并，同时本地有三次提交还没有推送。 

最后看到 `testing` 分支并没有跟踪任何远程分支。

注：这些数字的值来自于你从每个服务器上最后一次抓取的数据， 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。

 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：

```bash
$ git fetch --all; git branch -vv
```

### 删除本地不再引用的远程分支

参见：[stackOverFlow](https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune) 

使用以下命令能查看所有分支，包括正在或不在引用的远程分支 -> 通常标红色， 名字为：`remotes/remoteName/branchName` 

```bash
$ git branch -a
```

我们可以使用命令：`git remote prune remoteName` 删除所有不再引用的远程分支（删除标红色的部分）。

TIP：这将摆脱任何未被远程跟踪的分支，无论它是否被合并。

此命令不会影响你已经 checkout 的分支，即：标白色的分支。

## [变基 rebase](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)

前文中，我们已讲到可以使用 `git merge <targetbranch>` 命令将目标分支合并到当前分支，其中使用该命令可能产生两种合并方式*（详见：同级目录 - 分支合并）*：

1. fast-forward 快进
2. 简单的三方合并

在该章节 [变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA) 中，我们将讲另一个合并分支的方法：rebase 变基。

先让笔者做一个简单的介绍，所谓的变基操作也就是：**提取一个分支的所有修改，将其应用到另一个分支上**，就好像“重新播放”，或者说“重新应用修改”一样。

### [使用例子讲变基原理](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_%E5%8F%98%E5%9F%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)

下面让笔者使用一个例子（来自[此处](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)）来讲变基的基本原理：

首先存在一个项目，它具有一个分叉的提交历史：

![](.//picture/Git 分支-变基 分叉的提交历史.png)

（分叉的提交历史）

通过上图（分叉的提交历史）我们可以发现：该项目具有一个分叉的提交历史，并且每个分叉的最后一次提交都具有分支名，分别为：experiment 和 master，其中 C2 提交对象是该分叉分支的最近共同祖先。

虽然我们可以通过 `git merge` 命令进行一次简单的三方合并，使得 C3 和 C4 以及 C2 提交对象进行三方合并，但是这里主要讲的是变基操作，所以这里使用 `git rebase <targetbranch>`  命令进行变基操作，从而使得 C3 和 C4 “合并”，这里的合并之所以打引号，是因为可能不像你想象的那样子的合并，而是另一种方式

```bash
# 检出（切换）到 master 分支
$ git checkout experiment
# 将当前分支变基到指定分支
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
```

以上的操作的原理是：

Git 会先找到当前分支（experiment）和需要变基到的目标分支（master）的最近的共同祖先（这里是 C2）；

找到之后，将该祖先和 该祖先到当前分支这一过程的[历次](https://baike.baidu.com/item/%E5%8E%86%E6%AC%A1/3096751?fr=aladdin)提交进行对比（这里只有 C4 和 C2 进行对比），提取出每一次祖先和这一过程的历史提交的不同之处（即：提取出该祖先到当前分支这一过程中，每一次的修改）并将之存储为临时文件；

然后使得当前分支的指针指向目标分支（即：抛弃当前分支，使得**这一时刻**的当前分支指针和目标分支指针 指向同一个分支）；

最后将存放所有修改的数据的临时文件应用到当前分支指针和目标分支指针指向的同一个分支（这里是 C3），

从而在 C3 提交对象的基础上产生了和 C4 提交对象（最初时，experiment 指向的提交对象）所做修改（C2 到 C4 这一过程中，每次的提交都和 C2 进行对比，从而找出的所有差异，就是所做修改）一样的 C4' 提交对象，并让当前分支指向 C4' 提交对象。

下图则是将上述所述操作完成之后的图形表示：

![](.//picture/Git 分支-变基 将当前分支变基到指定分支.png)

（将当前分支变基到指定分支）

现在，我们可以回到 master 分支，和 experiment 分支来一次 fast-forward*（详见：Git 分支 - 分支合并）*，然后可以再将 experience 或 master 分支删除一个（不删除也行）。

下面则是操作：

```bash
$ git checkout master 
$ git merge experiment
```

这样用变基操作所做的合并就会使得 Git 仓库的提交历史少一个分叉，因为当前分支所做的修改*（这个修改是当前分支 和 当前分支和目标分支的最近的共同祖先进行对比，从而产生的，前面也有提到）*，都已经应用到了目标分支上，所以 Git 会使得当前分支的这个分叉历史“消失”；

且你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。

下图可以清楚的看见这一点：

![](.//picture/Git 分支-变基 变基操作完成后的一次快进.png)

（变基操作完成后的一次快进）

对于上述所有操作，我们可以简单的称之为：重播，也就是说：将当前分支和目标分支的最近的共同祖先到当前分支这一过程所做的修改，重新应用到目标分支上，从而实现在目标分支上进行“重播”。

值得一提的是：在（分叉的提交历史）图中，若我们使用的是 `git merge` 命令进行的三方合并，则 C3、C4 和 C2 合并出来的一个新的提交对象与使用
`git rebase` 命令变基出来的新的提交对象，

它们整合的最终结果所指向的快照始终是一样的*（即：这两个新的提交对象实际上是等同的，除非发生了冲突，你手动进行了修改，这就有有可能造成内容不同）*，只不过提交历史不同罢了。

变基是将一系列提交*（祖先分支到当前分支这一过程的一系列提交所做的修改，每一个提交都与祖先分支进行对比，找出其中的修改并将所有的修改存入一个临时文件）*按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

### [变基可以用于目标分支以外的分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_%E6%9B%B4%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E5%9F%BA%E4%BE%8B%E5%AD%90)

 在 *使用例子讲变基原理* 一小节中，我们知道：可以在当前分支下，使用 `git rebase <targetbranch>` 命令指定目标分支，让当前分支变基到目标分支上，从而完成“重播”；

但是本节会告诉你，除了可以变基到目标分支上以外，Git 还支持变基到其他分支，即：**在对两个分支进行变基时，从当前分支提取出来的所修改的数据集合（一个临时文件），或者说所生成的“重播”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。**

下图存在三个分支，其中 server 分支是基于 master 分支的 C2 进行分叉的，client 则是基于 sever 分支的 C3 进行分叉。

其中，若我们希望将 client 分支中的所有修改应用到 master 分支上（C6 提交上），但是暂时并不想合并 server 分支中的修改（可能有各种原因，如：server 分支还需要进行一些审查等），这时，我们可以使用 `git rebase --onto` 命令来解决该问题。

- PS：使用以下命令，是无法做到不合并 server 分支的 C3 提交的。
  
  ```bash
  $ git checkout master
  $ git rebase client
  ```
  
  ​    以上命令：找到 master 分支和 client 分支的最近共同组先：C2；
  
  ​    将 C2 到 C9 这一系列过程中，所作的提交依次和祖先 C2 进行对比，取出每一次对比完成后的差异，将之存入一个临时文件，最后基于 master 分支的指针指向的 C6 提交对象应用；
  
  ​    但是很显然的是，C3 的修改也会被应用于 C6，这和我们的要求不符，我们要求的是 server 分支这一分叉历史的提交都先不准合并，而 C3 的修改却已经和 master 分支合并了，这是不应该的。
  
  ​    所以我们需要使用别的命令，即：`git rebase --onto`

![](.//picture/Git 分支-变基 指定目标分支以外的分支进行变基.png)

（指定目标分支以外的分支进行变基）

```bash
$ git rebase --onto master server client
```

以上命令的意思为：

找到 server 分支中分叉出来的 client 分支，然后再找到 client 分支基于 server 分支分叉时的源头：C3 *（即：client 分支在 server 分支上，从哪个提交对象进行分叉）*，

再取出该源头（C3）到 client 分支的最新提交这一系列提交中的所有修改：C8 和 C9 *（即：这一系列的每次提交都和该源头进行对比，取出差异，然后将每次提交都提取的差异整合成一个临时文件）*，

最后将这些修改*（临时文件，C8 和  C9）*在 master 分支上“重新播放”。

简单的说，就是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍。”

这样，以上的命令所做的操作，就会使得 Git 仓库的 client 分支看起来像是直接基于 master 分支修改一样；这理解起来可能有些困难，但是效果却非常炫酷。

下面是执行以上命令成功后的图形所示，可以很清楚的发现 client 分支中的 C8 和 C9 提交对象各自相较于 C3 所做的修改已经在 master 分支（C6）上进行了重新播放。

![](.//picture/Git 分支- 变基 指定目标分支以外的分支进行变基 成功.png)

（指定目标分支以外的分支进行变基 成功）

此时，我们现在只需要使得 master 分支快进到 client 分支，这样子， client 分支就真的是如同直接基于 master 分支修改了：

```bash
$ git checkout master
$ git merge client
```

下图是 master 分支快进到 client 分支的图形表示：![](.//picture/Git 分支-变基 指定目标分支以外的分支进行变基，成功后使得主分支快进到变基后的分支的最新提交.png)

（指定目标分支以外的分支进行变基，成功后使得主分支快进到变基后的分支的最新提交）

### 将一个分支变基到目标分支上的简写形式

- 该节紧接着 *[变基可以用于目标分支以外的分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_%E6%9B%B4%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E5%9F%BA%E4%BE%8B%E5%AD%90)* 一节

接下来，若你也想要将 server 分支的 C3、C4 和 C10 提交对象变基到 master 分支，则可以使用如下命令：

```bash
$ git checkout master server
# 以上命令是以下命令的简写
$ git checkout server
$ git rebase master
```

使用  `git rebase <basebranch> <topicbranch>` 命令，可以在不切换分支的情况下，将一个分支变基到另一个分支上，即：将 \<topicbranch> 分支变基到 \<basebranch> 分支上。

当你执行完成以上命令后，server 分支中的 C3、C4 和 C10 就会变基到 master 分支上，图形如下所示：

![](.//picture/Git 分支-变基 将一个分支变基到目标分支上的简写形式.png)

（将一个分支变基到目标分支上的简写形式）

这样子，你就可以对 master 分支再一次进行快进，快进完成之后再删除无用的分支，那么，该 Git 仓库的提交历史将会非常的整洁，因为三个分支被变基成了一个分支：

```bash
$ git checkout master
$ git merge server
# 删除 client 和 server 分支
$ git branch -d client
$ git branch -d server
```

最后，Git 仓库的历史提交的图形表示如下所示：

![](.//picture/Git 分支-变基 三个分叉历史通过变基成为一个分叉.png)

（ 三个分叉历史通过变基成为一个分叉）

### [变基的风险](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_rebase_peril)和[如何解决已经存在的变基风险](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_rebase_rebase)

是的，相较于 `git merge` 命令的合并来说，变基是有着一定的风险的，但是这个风险是完全可以规避的。

即，在使用变基时，谨记一条准则：**如果提交存在于你的仓库之外，而别人又可能基于这些提交进行开发，那么不用执行变基。**

如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。

因为变基实际上是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上是不同的提交。

比如：你将某次提交已推送到了远程仓库，而其他人也已经从该远程仓库中拉去了你这次的提交并进行了后续工作，但此时，若你使用 `git rebase` 命令重新将你已推送的提交进行了重新整理又再次将之推送，那么你的同伴不得不再次将他们手头的工作与你这次使用了 `git rebase` 命令整理后的提交进行整和，而且若你/其他人接下来还要拉取并整合他们修改过的提交，事情就会变得一团糟。

这个原因很简单，因为你使用 `git rebase` 命令将已推送的提交进行了重新整理又再次推送的提交，实际上这次推送的提交和你不使用 `git rebase` 命令进行整和的已推送提交的内容是一样的，只不过提交的校验和不一样。

并且你的同伴拉取了使用 `git rebase` 命令后的提交和没有使用该命令的提交，那么对于你来说使用变基操作导致消失的分支，对他们来说该分支并没有消失，因为他们早已经拉取到本地了，同样的，对于其他人来说也是这样子的。

所以，如果他们整合出了 [使用 `git rebase` 命令后的提交与没有使用该命令后的提交]的提交进行了推送到远程仓库，让其他人与你拉取，这时候其他人在检查历史提交时，就会很疑惑，疑惑的是怎么有内容重复的提交？而你本人则会疑惑，使用了 `git rebase` 命令后提交不是应该已经消失了吗，怎么还会被我拉取到本地仓库？

所以，千万不要在非本地的仓库，使用变基操作将提交进行整合，这是很愚蠢的行为！

但是，如果你真的做了这么愚蠢的事情，或遇到了类似的处境，别担心，Git 还有一些高级魔法可能帮助到你：[用变基解决变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_rebase_rebase)

这里我就不赘述解决方法了，你可以通过超链接去查看。

### [使用变基解决提交历史太多的问题](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)

- NOTICE: 这种方式很可能会让你所做的修改回滚，即：当前 reabse 提交历史后，git 不会保证你每一次提交的数据都存在，请慎用。
  
  若你想要解决提交历史过多的问题，直接创建新分支，然后覆盖是最好的。

```bash
~ git rebase -i HEAD~从当前提交历史开始计算，合并几个 commit
```

当执行该命令后，会进入一个编辑界面，在界面的最顶层，会显示出你想要变基的提交信息，在每行提交历史的最前面的单词，则是为该提交历史（包含提交内容）做的操作。

- 如：squash 命令，使用该命令，将会让指定的 commit 和上一个 commit 合并。
  
  fixup：与squash相同，但不会保存当前commit的提交信息

- TIP：[作者]在使用时，尝试使用了 fixup 去操作除第一行之外的所有 commit，若此若作，它并不能按照[作者]预期的行为去完成合并所有 commit 到第一个 commit。
  
  所以[作者]使用了 squash，则能成功保存。

当你确定完要为所有提交执行的操作后，按 esc -> :wq 进行保存即可。

进入变基编辑界面后，从上到下顺序依次为从旧->新，需要注意：如果使用 squash 命令则最旧的（最上面）那个提交历史无法使用 squash 命令，这是因为：最旧（最上）的提交已经没有前一个提交了，所以无法和上一个提交进行合并，当强制为最旧的提交使用 squash 时，则会报错。

```bash
~ %s/old/new/g 
```

以上命令全局替换文本

### [变基 VS 合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_%E5%8F%98%E5%9F%BA_vs_%E5%90%88%E5%B9%B6)

现在你已经知道了存在两种可以合并分支的方法：

1. git merge
2. git rebase

那么，你肯定想知道，这两种方法哪种更好？在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。

通常来说，对于提交历史，存在两种观点：

1. 仓库的提交历史即是 **记录实际发生过什么。**
2. 提交历史是 **项目过程中发生的事**。

第一种观点的意思就是：它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 *谎言* 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。

第二种观点的意思就是： 提交历史是 **项目过程中发生的事**。没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 `rebase` 及 `filter-branch` 等工具来编写故事，怎么方便后来的读者就怎么写。

现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 

Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。

总的原则是，**只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，**这样，你才能享受到两种方式带来的便利。
