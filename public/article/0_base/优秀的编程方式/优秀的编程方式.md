# 优秀的编程方式

- 在什么情况下会执行什么代码，这就是高级语言执行的本质。

- 逻辑复用 > 代码复用
  
  一个良好的逻辑通常是保证你代码质量的前提（先逻辑后代码）

- 嵌套数组遍历，有时外层的 index 可以使用于内层循环的数组，如：内层循环数组[外层循环 index]，从而使得在内层循环时，可以获取到当前外层循环了第几次的内层数组值。

- 改变某段逻辑、方法、变量时，请思考此次的改变是否会影响到其他方面，会不会导致出现意料之外的 bug，在保证一切安全的前提下，再去更改。

- 当某个方式无法实现需求、功能、模块，此时，通常需要换种思考方式，让一切迎刃而解。

- 在创建一个函数时，请记住：尽量避免（通常是永远）去更改形参的原始值，若去更改了形参的原始值，则当程序越来越大和复杂时，你通常会忘记该函数更改了你传入的值，导致程序出现意料之外的错误。
  
  即：若能创建[纯函数](https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0)，那么便创建它。
  
  若此函数必须存在副作用，请用更详细的注释来解释为什么，并且能通过函数名知道它是一个副作用函数。

- 创建一个函数时，保证它的解耦。
  
  即：若一个函数中，需要通过状态获取对应的数据，你可能这么写：
  
  ```js
  const func = (data, staus) => {
    switch(status) {
         case 'x' data.a 
      break;
      ...
    }
  }
  ```
  
  这并不是一种好的做法，因为该函数的是较耦合的，它和 status 的值相关了。
  
  所以笔者建议：直接传入正确的数据，而非在函数内部进行处理：
  
  ```js
  const func = (data) => {
      return data
  }
  func(staus === 'x' ? data : [])
  ```

- 在想要达到某个要求，从而使用递归操作时，如果此次递归包含[副作用](https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，则你可以将此要求用两个函数实现：`1. 包含副作用的递归` `2. 用来让递归函数的副作用不影响到其它地方的函数` 
  
  如：现有要求，有一数据格式为：`type Data = {title:string; key:string; children: Data[]}[]` 的对象数组 Data，现需要通过字符串数组（全是 key）从 Data 中删除指定的 key，函数如下：
  
  此处：[在线 code-onLine](https://codesandbox.io/s/zeng-shan-gai-cha-tree-4ku0wk?file=/demo.tsx)  
  
  ```typescript
  import _ from 'lodash'
  
  // 包含副作用的递归
  const digui = (dataSource, checkedKey) => {
    for (let index = 0; index < dataSource.length; index++) {
      const { key, children } = dataSource[index];
      // 当前层级找到了 checkedKey，则移除对应的节点
      if (key === checkedKey) {
        // 注意：splice 方法修改了原数组
        dataSource.splice(index, 1); // 删除选中的当前节点
        return;
      }
  
      // 如果当前层级存在 children，但不存在 checkedKey，则递归 children
      // 直到在某一层级找到 checkedKey，或一直没找到
      //（通常来说没有这可能，因为 checkedKey 代表的是选中的 key，说明存在于 dataSource）
      // 为什么要不存在 checkedKey？因为第一次找到后，就直接删除整个节点。
      if (children) {
        digui(children, checkedKey);
      }
    }
  };
  
  // 用来让递归函数的副作用不影响到其它地方的函数
  function remove(dataSource, checkedKeys) {
    // 深拷贝，使得直接修改参数 dataSource 不会影响到传入的 dataSource
    const data = _.cloneDeep(dataSource);
  
    checkedKeys.forEach((checkedKey) => {
      digui(data, checkedKey);
    });
  
    return data;
  }
  ```
