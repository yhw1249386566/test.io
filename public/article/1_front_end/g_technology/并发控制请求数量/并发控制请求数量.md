# Reference

- [CSDN](https://blog.csdn.net/Jioho_chen/article/details/117886350) 
- [promise-limit](https://www.npmjs.com/package/promise-limit) 

```js
// count: 最大并发数
function limiter(count) {
    // 当前已经执行过的任务数
    var activeTaskCount = 0
    var activeQueue = []

    // 当某个已经被执行过的任务完成后，
    // 就从队列中取出一个任务，将其放入栈中并执行。
    // 即：删除队列中最先进来的任务，并执行它。
    function remove() {

        // 此函数将会移除队列中的最先进来的元素
        // 所以当队列的任务被移除时，此变量同步减少一个
        // 让下一个任务可以被放入栈中执行，而非放入队列等待。
        activeTaskCount--

        // 取出队列中最先进来的任务并放入栈中执行。
        if (activeTaskCount < count) {
            dequeue()
        }
    }

    function dequeue() {
        // 队列：先入先出。
        // 所以这里删除最先的（第一个）被添加进入队列（数组）的元素
        var job = activeQueue.shift()
        semaphore.queue = activeQueue.length

        // 将刚刚出队的任务放入栈中，并执行
        if (job) {
            run(job.fn).then(job.resolve).catch(job.reject)
        }
    }

    // 将任务放入队列
    function queue(fn) {
        return new Promise(function (resolve, reject) {
            activeQueue.push({ fn: fn, resolve: resolve, reject: reject })
            semaphore.queue = activeQueue.length
        })
    }

    function run(fn) {
        activeTaskCount++
        return Promise.resolve(fn()).then(function (result) {
            // 当栈中某个任务完成 resolve 后，就从队列中取出一个任务，放入队列并执行
            remove()
            return result
        })

    }

    var semaphore = function (fn) {
        // 如果当前已经执行过的任务数 >= 最大并发数量，那么就把余下的任务放入队列。
        if (activeTaskCount >= count) {
            return queue(fn)
        } else {
            // 否则执行此任务
            return run(fn)
        }
    }

    return semaphore
}

function map(items, mapper) {
    var failed = false

    var limit = this

    return Promise.all(items.map(function () {
        var args = arguments
        return limit(function () {
            if (!failed) {
                return mapper.apply(undefined, args).catch(function (e) {
                    failed = true
                    throw e
                })
            }
        })
    }))
}

function addExtras(fn) {
    fn.queue = 0
    fn.map = map
    return fn
}

function go(count) {
    if (count) {
        return addExtras(limiter(count))
    } else {
        return addExtras(function (fn) {
            return fn()
        })
    }
}


var limit = go(2)

var jobs = ['a', 'b', 'c', 'd', 'e']

const task = jobs.map((name) => {
    return limit(() => job(name))
})

console.log(task)

Promise.all(task).then(results => {
    console.log()
    console.log('results:', results)
})

function job(name) {
    var taskName = `job ${name}`
    console.log('started', taskName)

    return new Promise(function (resolve) {
        setTimeout(() => {
            console.log('       ', taskName, 'finished')
            resolve(taskName)
        }, 100)
    })
}

```

