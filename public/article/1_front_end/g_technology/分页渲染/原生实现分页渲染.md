# 解析

当一个数据太过庞大时，我们需要实现分页获取数据，比如： 1 个数组 Arr 中，存有 100 条对象，每个对象都是 1 个分页中的数据。

那么想要实现它，我们需要使用 1 个函数（或者别的什么）func 来处理数组 Arr；并且我们需要让 func 函数知道当前分页是第几页、每页最多显示几条数据以及总数据数组是哪个（Arr）



现在有这么 1 个实现方法（原生实现），其步骤为：

1. 声明 1 个函数 func，用来处理数组 Arr

2. func 函数接收 3 个参数：
   
   1. page:number 当前分页是第几页
   2. pageMaxNum:object 每页最大显示条数
   3. totalData:[] 总数据所在的数组

3. 在 func 函数中总共需要进行 3 个判断（它们是相互嵌套的关系）
   
   - if 1 个分页就能渲染完所有数据，就直接将数据和第 1 页页码绑定，并返回该数据
     
     - else 至少存在 2 个及以上的分页时：
       
       if 当前页码没超过总数据最多渲染页数，就将当前页码的第 1 条数据到最后 1 条数据返回，并将该数据绑定到当前页码。
       
       - else 当前页码超过总数据最多渲染页数，就使得这个无效的页码使用最后 1 个有效的页码的数据（PS：通常我们不会使得存在无效的页码，这里只是提供这么一个思路）
         
         `得出总数据至少渲染的页数`
         
         `得出最后 1 页是否刚好足足渲染到分页`（即：最后 1 页数据是否等于每页最大渲染条数）=> 其目的：因为刚刚得到的是总数据**至少能渲染的分页数量**，所以**会忽略当前页不满足每页最大渲染条数的数据**
         
         所以为了得到不满足最后 1 页的数据 < 每页最大渲染条数的数组中的数据，我们需要判断：
         
         - if 最后 1 页数据是 < 每页最大渲染条数，就将 [最后 1 页的页码码+1] 页码作为超出的页码，并且将最后 1 页数据返回。
           
           - else if 最后 1 页数据是 === 每页最大渲染条数，直接最后 1 页作为超出的页码*（这实际上并不重要，只是一个标识，你为超出的页码设置为多少都不要紧，只要大于最后或等于最后 1 页页码即可）*
             
             并且将最后 1 页数据返回。

4. 获取一个存放数据的数组，并规定当前页码是多少 、每页最大渲染条数，并且将这 3 个数据传入 func 函数中，最后 func 函数会返回给你传入的页码的数据应该是哪些条。

其具体实现为：

- 下面的示例开箱即用，直接复制到 `.html` 的文件中看看吧！
- getTableData() 是函数的实现。

# 有注释

```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <script src="./mock.js"></script> -->

</head>

<body>
    <button class="forward">1</button>
    <button class="forward2">2</button>
    <button class="forward3">3</button>
    <button class="forward4">4</button>
    <button class="forward5">5</button>
    <button class="forward6">6</button>
    <button class="forward7">7</button>
    <button class="forward8">8</button>
    <button class="forward9">9</button>
    <button class="forward10">10</button>
    <button class="forward11">11</button>
    <button class="forward12">12</button>
    <div class="data">
        <o class="ul">
            <li class="li"></li>
        </o>
    </div>



</body>
<script>
    /**
4  * @param  {Number} page 当前页码，默认1
5  * @param  {Number} pageMaxNum 每页最多显示条数，默认10
6  * @param  {Array} totalData 总的数据集，默认为空数组
7  * @return {Object} {
8     data, //当前页展示数据，数组
9     page, //当前页码
10     pageMaxNum, //每页最多显示条数
11     dataLength, //总的数据条数
12   }
13 **/

    let data = [
        { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 },
        { id: 6 }, { id: 7 }, { id: 8 }, { id: 9 }, { id: 10 },
        { id: 11 }, { id: 12 }, { id: 13 }, { id: 14 }, { id: 15 },
        { id: 16 }, { id: 17 }, { id: 18 }, { id: 19 }, { id: 20 },
        { id: 21 }, { id: 22 }, { id: 23 }, { id: 24 }, { id: 25 },
        { id: 26 }, { id: 27 }, { id: 28 }, { id: 29 }, { id: 30 },
        { id: 31 }, { id: 32 }, { id: 33 }, { id: 34 }, { id: 35 },
        { id: 36 }, { id: 37 }, { id: 38 }, { id: 39 }, { id: 40 },
        { id: 41 }, { id: 42 }, { id: 43 }, { id: 44 }, { id: 45 },
        { id: 46 }, { id: 47 }, { id: 48 }, { id: 49 }, { id: 50 },
        { id: 51 }, { id: 52 }, { id: 53 }, { id: 54 }, { id: 55 },
        { id: 56 }, { id: 57 }, { id: 58 }, { id: 59 }, { id: 60 },
        { id: 61 }, { id: 62 }, { id: 63 }, { id: 64 }, { id: 65 },
        { id: 66 }, { id: 67 }, { id: 68 }, { id: 69 }, { id: 70 },
        { id: 71 }, { id: 72 }, { id: 73 }, { id: 74 }, { id: 75 },
        { id: 76 }, { id: 77 }, { id: 78 }, { id: 79 }, { id: 80 },
        { id: 81 }, { id: 82 }, { id: 83 }, { id: 84 }, { id: 85 },
        { id: 86 }, { id: 87 }, { id: 88 }, { id: 89 }, { id: 90 },
        { id: 91 }, { id: 92 }, { id: 93 }, { id: 94 }, { id: 95 },
        { id: 96 }, { id: 97 }, { id: 98 }, { id: 99 }, { id: 100 },
    ]

</script>
<script>

    const getTableData = (page = 1, pageMaxNum = 10, totalData = []) => {
        const { length } = totalData; // 这里指的是 [].lenght 属性（JS内置属性）
        // 每页应用的信息：当根据每页最大显示条数和总数据数量来表明 当前要显示的数据和当前页码。
        const tableData = {
            data: [], // 存放当前数据
            page, // 页码（当前分页是第几页
            pageMaxNum, // 每页最大显示条数
            dataLength: length, // 数据总数。这里是 100
        };

        // 只需要渲染 1 个页码时
        if (pageMaxNum >= length) { //pageMaxNum >= 总数据长度，说明只有1页数据或没有数据
            tableData.data = totalData; // 直接将数据存放
            tableData.page = 1; //直接取第一页

            // 需要渲染 2 个及以上的分页时。
        } else { //总数据长度 > pageMaxNum，这说明至少要存在 2 个页码，比如：每页最多显示 10 条，现在总数据有 11 条，则必须存入 2 个分页，才能渲染。
            const currentPageBeforeAllData = pageMaxNum * (page - 1); // 除当前页之前的数据总数
            /** 当前页码是否超出总数据渲染的最多页数 
             * 如：100 条总数据，每页至多显示 10 条，当前页码 11
             * 那么当前页之前的数据 = 总数据，说明当前页码已经超出总数据渲染条数
             * 反之当前页码 10，那么之前的数据 90，90<length，说明当前页码没超出总数据渲染条数
             */
            if (currentPageBeforeAllData < length) { //如果 currentPageBeforeAllData < 总数据长度，则说明当前页码没有超出最大页码
                /** 当前页第 1 条数据在总数据集中的索引
                 * 这是因为总数据存在数组中，而数组索引从 0 开始。
                 * 比如：100 条总数据，每页至多显示 10 条，当前页码 6，那么当前页之前共有 10*(6-1) - 50
                 * 0 到 50 总共有 51 条数据，那么 51/10 只能渲染 5 页，剩下第 51 条数据只能渲染在第 6 页面，
                 * 所以第 51 条数据的索引就是当前第 1 条数据的索引，即：50
                 */
                const startIndex = currentPageBeforeAllData;
                // 同样的道理，当前页之前的数据 - 1（数组从 0 开始计算，会多 1 条数据） + 每页最大显示数= 当前页最后 1 条数据在总数据是第几个，由于数组从 0 开始计算，索引需要 -1
                const endIndex = currentPageBeforeAllData + pageMaxNum - 1; //当前页最后一条数据索引                      
                /** 将当前页的数据存储到 tableData.data   totalData：总数据
                 * 注：即使当前页的数据条数 < 每页最大条数时，也按最大条数范围筛取数据。
                 * 也就是说：当前页数据不够 1 页我们也按照最大数据渲染。PS：这只会发生在最后 1 页~。
                 * 因为一旦出现这种情况，就说明已经到了最后 1 页了
                 * 如：5 < 10，也按最大条数范围筛取数据
                 */
                tableData.data = totalData.filter((_, index) => index >= startIndex && index <= endIndex);
                console.log(tableData.data)

                // 当前页码超出总数据能渲染的最大页面数量，则使用最后 1 页的数据
            } else {
                /** 总数据数量 / 每页最大显示数据数量 = 当前数据至少能渲染的分页数量
                 * 当前数据至少能渲染的分页数量：109 / 10 = 10，并使用 parseInt 去掉小数位
                 * 
                 * 你可能会认为去掉小数位会造成计算失误，比如：parseInt(109 / 10) = 10，109 条数据最多渲染 10 页？正确的是 11，
                 * 但是别忘记：这条指令只有当页面超过总数据能渲染的页码之后才会执行，
                 * 也就是说，我们故意取出当前数据至少能渲染的分页数量，而不是最多能渲染多少分页。
                 */
                const size = parseInt(length / pageMaxNum); //取商，先暂时得出总数据至少能渲染的页数
                /** 得出最后 1 页数据是否满足每页最大渲染条数
                 * 判断当前数据是否刚好足足的渲染没页面，还是说最后 1 页的数据是少的，不能足足的渲染为每页最大可允许渲染数据 
                 * 数据总量 % 页面最大渲染数量 => 求出最后 1 页的数据条数
                 * 如：109 条数据，每页最多渲染 10 条，
                 * => 109 % 10 = 9 或  109/10 = 10
                 */
                const rest = length % pageMaxNum; //取余数
                /** 存在最后 1 页
                 * 如同：if(rest !== pageMaxNum) 最后 1 页数据不等于每页最多渲染条数
                 * 如：99 条总数据，每页最多渲染 10条，那么最后 1 页数据只有 9 条，小于每页最多渲染的条数（10 条），
                 * 这说明最后 1 页的数据无法刚好渲染进入，即第 10 页只有 9 条数据。
                 * 那么由于我们刚刚计算 size 是总数据至少能渲染的分页数量，所以会忽略当前页不满足每页最大渲染条数的数据
                 * 在这里我们会忽略 99 条数据中的最后 9 条，得出 size 至少能渲染 9 页。
                 * 但实际上还可以渲染 1 页，第 10 页。
                 */
                if (rest > 0) { // 余数大于 0，说明刚刚暂时得出的总数据至少能渲染的页面数量需要 + 1（存在剩余数据）
                    tableData.page = size; // 将页数重置，+ 1
                    console.log(`当前页码：${tableData.page}`)
                    /** 取出最后 1 的数据
                     * 取出从 最后 1 页的第 1 个数据的索引位置 到 余下的剩余数据并赋值给  tableData.data 
                     */
                    tableData.data = totalData.filter((_, index) => index >= (pageMaxNum * size) && index <= length);
                    // 如同：if(rest === pageMaxNum)
                } else if (rest === 0) { //余数等于0，说明刚刚暂时得出的总数据至少能渲染的页面数量就是总数据最大渲染页面数量，已经没有剩下数据了
                    tableData.page = size + 1; //当前页码重置，取size
                    console.log(`当前页码重置为：${tableData.page}`)
                    /** 取出最后 1 页的数据
                     * 取出从 最后 1 页的第 1 个数据的索引位置 到 余下的剩余数据并赋值给  tableData.data 
                     * 这里 size-1 是因为你要得出的是最后 1 页的数据，当然需要从最后 1 页的第 1 条数据的开头开始朝朝，即第索引为 90 的数据开始查找。
                     * 正因为要从索引为 90 的数据开始查找，所以我们这里的 index 是 >=，而不是 >，
                     * 如果是 > 的话，那么对于数组来说，你要从索引为 91 的数据开始查找，与之对应的数据如果是从 1 开始，那么数据将会显示第 92 条数据。
                     * 所以这是错的。
                     * 而 index < length，不用 <= 因为数组计算长度时，是从 1 开始计算。
                     * 
                     * 如：100 条数据，每页最多渲染 10 条，那么最后 1 的数据在数组中的位置为：90-99
                     *  即 => 10*9=90 && 99<100
                     *  可得出：90 - 99 的数据
                     */
                    tableData.data = totalData.filter((_, index) => index >= (pageMaxNum * (size - 1)) && index < length);
                } //注：余数不可能小于0
            }
        }
        return tableData;
    };
</script>
<script>


    const dataEle = document.querySelector('.data')
    const ul = document.querySelector('.ul')
    let buttonlist = document.getElementsByTagName('button')

    for (let i = 0; i < buttonlist.length; i++) {
        buttonlist[i].addEventListener('click', () =>
            ul.innerHTML = getTableData(i + 1, 10, data)
                .data.map((v) =>
                    `<li>${v.id}</li>`
                )
        )
    }

    ul.innerHTML = data.map((v) => `<li>${v.id}</li>`)


</script>


</html>
```

# 无注释

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <script src="./mock.js"></script> -->

</head>

<body>
    <button class="forward">1</button>
    <button class="forward2">2</button>
    <button class="forward3">3</button>
    <button class="forward4">4</button>
    <button class="forward5">5</button>
    <button class="forward6">6</button>
    <button class="forward7">7</button>
    <button class="forward8">8</button>
    <button class="forward9">9</button>
    <button class="forward10">10</button>
    <button class="forward11">11</button>
    <button class="forward12">12</button>
    <div class="data">
        <ol class="ul">
            <li class="li"></li>
        </ol>
    </div>



</body>
<script>
    /**
4  * @param  {Number} page 当前页码，默认1
5  * @param  {Number} pageMaxNum 每页最多显示条数，默认10
6  * @param  {Array} totalData 总的数据集，默认为空数组
7  * @return {Object} {
8     data, //当前页展示数据，数组
9     page, //当前页码
10     pageMaxNum, //每页最多显示条数
11     dataLength, //总的数据条数
12   }
13 **/

    let data = [
        { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 },
        { id: 6 }, { id: 7 }, { id: 8 }, { id: 9 }, { id: 10 },
        { id: 11 }, { id: 12 }, { id: 13 }, { id: 14 }, { id: 15 },
        { id: 16 }, { id: 17 }, { id: 18 }, { id: 19 }, { id: 20 },
        { id: 21 }, { id: 22 }, { id: 23 }, { id: 24 }, { id: 25 },
        { id: 26 }, { id: 27 }, { id: 28 }, { id: 29 }, { id: 30 },
        { id: 31 }, { id: 32 }, { id: 33 }, { id: 34 }, { id: 35 },
        { id: 36 }, { id: 37 }, { id: 38 }, { id: 39 }, { id: 40 },
        { id: 41 }, { id: 42 }, { id: 43 }, { id: 44 }, { id: 45 },
        { id: 46 }, { id: 47 }, { id: 48 }, { id: 49 }, { id: 50 },
        { id: 51 }, { id: 52 }, { id: 53 }, { id: 54 }, { id: 55 },
        { id: 56 }, { id: 57 }, { id: 58 }, { id: 59 }, { id: 60 },
        { id: 61 }, { id: 62 }, { id: 63 }, { id: 64 }, { id: 65 },
        { id: 66 }, { id: 67 }, { id: 68 }, { id: 69 }, { id: 70 },
        { id: 71 }, { id: 72 }, { id: 73 }, { id: 74 }, { id: 75 },
        { id: 76 }, { id: 77 }, { id: 78 }, { id: 79 }, { id: 80 },
        { id: 81 }, { id: 82 }, { id: 83 }, { id: 84 }, { id: 85 },
        { id: 86 }, { id: 87 }, { id: 88 }, { id: 89 }, { id: 90 },
        { id: 91 }, { id: 92 }, { id: 93 }, { id: 94 }, { id: 95 },
        { id: 96 }, { id: 97 }, { id: 98 }, { id: 99 }, { id: 100 },
    ]

</script>
<script>

    const getTableData = (page = 1, pageMaxNum = 10, totalData = []) => {
        const { length } = totalData; // 这里指的是 [].lenght 属性（JS内置属性）
        const tableData = {
            data: [], // 存放当前数据
            page, // 页码（当前分页是第几页
            pageMaxNum, // 每页最大显示条数
            dataLength: length, // 数据总数。这里是 100
        };
        if (pageMaxNum >= length) { //pageMaxNum >= 总数据长度，说明只有1页数据或没有数据
            tableData.data = totalData; // 直接将数据存放
            tableData.page = 1; //直接取第一页
        } else { //总数据长度 > pageMaxNum，这说明至少要存在 2 个页码，比如：每页最多显示 10 条，现在总数据有 11 条，则必须存入 2 个分页，才能渲染。
            const currentPageBeforeAllData = pageMaxNum * (page - 1); // 除当前页之前的数据总数
            if (currentPageBeforeAllData < length) { //如果 currentPageBeforeAllData < 总数据长度，则说明当前页码没有超出最大页码
                const startIndex = currentPageBeforeAllData;
                const endIndex = currentPageBeforeAllData + pageMaxNum - 1; //当前页最后一条数据索引                      
                tableData.data = totalData.filter((_, index) => index >= startIndex && index <= endIndex);
                console.log(tableData.data)
            } else {
                const size = parseInt(length / pageMaxNum); //取商，先暂时得出总数据至少能渲染的页数
                const rest = length % pageMaxNum; //取余数
                if (rest > 0) { // 余数大于 0，说明刚刚暂时得出的总数据至少能渲染的页面数量需要 + 1（存在剩余数据）
                    tableData.page = size; // 将页数重置，+ 1
                    tableData.data = totalData.filter((_, index) => index >= (pageMaxNum * size) && index <= length);
                } else if (rest === 0) { //余数等于0，说明刚刚暂时得出的总数据至少能渲染的页面数量就是总数据最大渲染页面数量，已经没有剩下数据了
                    tableData.page = size + 1; //当前页码重置，取size
                    tableData.data = totalData.filter((_, index) => index >= (pageMaxNum * (size - 1)) && index < length);
                } //注：余数不可能小于0
            }
        }
        return tableData;
    };
</script>
<script>


    const dataEle = document.querySelector('.data')
    const ul = document.querySelector('.ul')
    let buttonlist = document.getElementsByTagName('button')

    for (let i = 0; i < buttonlist.length; i++) {
        buttonlist[i].addEventListener('click', () =>
            ul.innerHTML = getTableData(i + 1, 10, data)
                .data.map((v) =>
                    `<li>${v.id}</li>`
                )
        )
    }

    ul.innerHTML = data.map((v) => `<li>${v.id}</li>`)


</script>


</html>
```

# 简单分页思维逻辑

```ts
const pageSize = 20;
const page = 1;

// 0-19 1
// 20-39 2
// 40-59 3

// 手动分页数据
const data = []; //
const start = pageSize * (page - 1);
const target = pageSize * page - 1;

// 得到对应页码数据
data.slice(start, target + 1 );
```
