# 说明

RFC文档是一种规范,但是在实际项目中,不一定非要按照规范来,请根据自己的需求而定.

就好像规范是没错,但是它不应该成为你的限制,否则就变成了只吃前面的饼而被饿死的小孩.

​										-----一切为了利益

本篇文章参考:知乎-[大宽宽的回答](https://www.zhihu.com/question/28586791).

# 描述

- 首先请请你们要知道:不论是get,post,put还是delete等http方法,它们都只是语义上的区别. 本身是没有什么区别的(语法没有什么区别)

  因为能用get做到的事,post也能做到,反之依然.

  除非在浏览器中使用get和post,那么其传输数据的格式才会有硬性要求且其使用的要求也有所不同,而API中使用get和post则没有这种要求.
  
  ​	(这是浏览器的限制,而不是get和post本身不支持,即:使用者为get和post增添了限制,而get/post本身无所畏惧)
  
  

HTTP最早的时候是被用来做浏览器与服务器之间交互HTML和表单 的一种通讯协议;而后来又被广泛的扩充到接口格式的定义上.

​	*需要注意的是,HTTP协议除了get和post还有其他各种协议,只不过get和post是近乎所有浏览器都支持的方法.*

而在浏览器使用的get和post(典型的是form表单使用get和post)和在接口中使用的get和post(典型的是使用AJAX技术)是有所区别的.

# 浏览器中使用get和post

## 描述

这里说的浏览器中使用get和post,特指的是非AJAX的HTTP请求,即:从HTML和浏览器诞生起就一直使用的HTTP协议中的GET/POST.

如\<form>中的get和post.而不是xhr.open('get/post','url','true');***(参见<AJAX.md>***

## get

浏览器将HTTP的get定义为:仅读取.

即:get此时应该被仅用于读取某个资源,如:html,css,js,img等.

正由于get只是单纯的读取资源,所以使用get反复进行读取某个同样的资源时,不应该对访问的资源(数据)有副作用=>

​	在对应的服务器资源没有被手动改变: 使用get反复请求(获取)一张图片,不能说在第二次请求图片时,这张图片由于get请求变成了不是第一次请求的图片了,这是不可被接受的,因为由于浏览器的限制,get只能单纯的获取,如同db的read一样.

正因为get没有"副作用",所以通常我们说get是"[幂等](https://baike.baidu.com/item/%E5%B9%82%E7%AD%89)"的,即:每个get请求之间不会相互影响,是独立的,且多次get的结果 === 第一次get的结果.

也即是因为这些原因(幂等,仅读取),所以可以对get请求的数据做缓存,该缓存可以做到浏览器上(可以减少浏览器请求的次数),或代理上(如nginx),又或者server端)用Etag,至少可以减少带宽消耗）

## post

### 描述

浏览器使用post请求通常通过\<form>表单元素标签,如method='post'***(参见:<Form.md>)***

且POST请求是让服务器去做某件事,最后由服务器返回结果,参见[RFC文档](http://www.kaiyuanba.cn/content/develop/rfc/RFC1945.htm).
也就是向服务器发送数据,而不是如同get一样获取数据,不是发送.

且在浏览器(HTML)限制下,post是无法被缓存的,不[幂等](https://baike.baidu.com/item/%E5%B9%82%E7%AD%89)的,且可能修改终端(如:server端)数据的.

而不幂等代表着无法随意的进行多次执行,因为也就无法被缓存.因为多次执行post请求和post被缓存可能带来一些副作用,请看思考以下场景.

### 场景例子

<!--例子 start-->

x在购物网站买了个商品A,接着下单-付钱-购买-返回购买成功界面,此时这串请求操作通常由post完成(可以修改终端数据),

若该post在这一系列操作中可以被缓存,那么以后x只需要每次去相同的购物网站买个相同的商品A时,一下单就可以通过缓存(不一定是本地缓存,可以是server端等)返回购买成功的界面,

这是无法被接受的,一件很滑稽地事情: 没有在服务器下单,却返回了购买成功的界面.所以**post不应该被缓存.**它的"权限"很高,可以直接跟服务器进行对话*(发出请求,要求你返回数据)*,而get仅仅是请求获取*(求你返回数据).*

- 所以post如果能被缓存,就可以无视你服务器的设定(必须从下单开始才能到返回购买成功界面),直接从缓存返回购买成功界面(虽然不会再服务器中有订单留存,但是仍然很滑稽,不是吗?)

*对于get请求来说,根本就不存在这些问题,因为能被get缓存的一定是不需要被修改的资源,至少浏览器和Html中是如此.*

而post不能被缓存的终极原因:不能保证每一次post请求返回的结果都是正确的(可以改变终端数据).

(亲测)比如:

​	去某宝在订单支付的界面,进行收藏到书签,然后通过书签进入该订单,会发现界面出现的是:

​	系统繁忙,请稍后再试,也就是说要让你重新下单->进入订单.

​	而这就表明,该订单页面是通过post进行请求的,post无法被缓存.

<!--例子 end-->

举了以上这个例子,只是想说明,post如果能被缓存的"副作用". 

显然的,通过以上例子你们也应该对post无法被缓存有个大致的了解,但是请一定要记得,这只是在浏览器中使用post的限制,这是浏览器和html规定的,而不是http规范规定的

​	*(参见:[RFC文档](http://www.kaiyuanba.cn/content/develop/rfc/RFC1945.htm),你会发现RFC规范并没有说POST和GET必须得被应用到请求体或者说是请求头,统一都是实体(实体: 请求行,头,体)*

### 描述---续

你曾经有没有刷新/回退一个页面,即尝试重新执行post请求时,弹出一个警告框,询问呢你是否要继续执行:

![](.\picutre\post重新提交表单弹出警告框.png)

出现这种警告框就是因为该表单使用了post请求,而post是不幂等的,所以就会弹出警示:**如果你执行此操作,仍打算在当前表单中的输入框中保持你刚刚输入的数据是不可能的,你可能会需要重新提交(输入)你之前已经输入过的数据**,比如:

​	你在一个登录网页输入的用户密码并登陆成功后,使用了back键,那么此时浏览器就会提示你:你刚才输入的用户和密码将需要重新提交数据到服务器,否则登录状态将失效.

- PS:对于服务器开发者来说,完全可以将post实现为幂等,没有副作用. 
  而将get实现为不幂等,有副作用. 

  这两个操作都是可以的,因为诸如使用api调用get和post并不会遵循浏览器/html规范,而是遵循http协议规范,而http规范并不会限制get和post使用在哪里,只要符合http协议的格式即可.

  ***详见API中使用get和post.***

## 总结

在浏览器使用get和post中:

:one:凡是能被缓存的,一定是不需要被修改的资源(如单纯的一个静态页面,一个x宝首页),否则都无法被缓存(可以实现都被缓存,但没有傻子这么干),这是浏览器和html规范限制的.

否则get如果能缓存需要被修改的资源,则也会出现:一下单就返回购买成功的界面,这是不可被接受的.

:two:而不能被缓存的资源,是因为这些资源是可能会被修改的或多次请求时获得的资源不同,即:浏览器会发出一个请求给server,然后server会通过这个请求去判断是否修改资源会获取别的资源;

而这对于浏览器来说,这种操作是靠post实现的,因为post在html和browser限制下,它无法被缓存.

即使强制收藏为书签,那么当下一次通过书签进入到本无法被缓存/收藏的资源(页面)时,那么该资源可能(几乎必然)失效,或者要求你重新输入数据,重新发送请求.

​	*get就不会这样,能被get缓存的数据一定是不需要这么做的,至少没有人会这么做——*

​	*没有人会将订购买成功页面设计成为可以被缓存/收藏的页面,否则一下单就会返回购买成功,甚至不需要付款.*

## html和浏览器规范中get和post的区别

### get和post传输的数据格式不同

#### get

当浏览器发出一个GET请求时,就意味着用户是通过地址栏直接输入,或点击了有href的a标签,又或者是在form表单中使用了get请求提交数据.

所以get请求是通过原来的url + query string返回结果的.

- query string: 查询字符串.

需要注意的是:这并不是说GET只能由URL触发,而是说**浏览器直接发出的GET只能由一个URL触发**.

而**get具体传输的数据格式是**: 

- 将需要查询的数据以key=value的形式追加在url之后,

  以`?`分割url和key=value,而多个key=value之间使用`&`连接;

  ​	如果需要传输的数据中存在中文和空白:

  则中文会被转译成:`%+ASCII(16)`; 空白则会被转成 `+`.如:
  
  而这转译需要依靠一种编码,即:Percent-encoding,即:[WIKI-URL编码](https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81)
  
  即：中文通过 16 位的 ASCII 码转换 + Percent-encoding 转换。

使用get请求传输的数据会被放入请求报文的请求头中(post放入实体主体或说请求主体中), 

- PS:所以事实上,浏览器在使用get时,get并没有请求体.

然后这些数据连同请求行和请求头一起被发送给终端,接着由终端解析完传输的数据后,将结果以url+querystring形式返还给你,最后浏览器会通过这个值去终端寻找到相应的数据并通过页面的形式显示出来.

以下是一个典型的get请求返回的结果字符串***(或可以参见:<form.md - 属性和方法 - 属性 -method>)***:

​	`https://www.google.com/search?q=%E6%B5%8B%E8%AF%95+%E8%AF%95%E9%AA%8C&oq=%E6%B5%8B%E8%AF%95+%E8%AF%95%E9%AA%8C&aqs=chrome..69i57j35i39j0l3j69i61l2j69i60.10530j0j7&sourceid=chrome&ie=UTF-8`

这其中包含: `?`,`key=value`,`%ASCII(16)`,`+`以及其他请求头的信息***(如果想获取更多关于请求头的信息,请参见:<HTTP请求行-请求头-请求体.md>***).

#### post

浏览器使用post请求,则需要传输的数据被放置于请求报文的请求体中.即:\<entity-body>中.(参见:***<HTTP请求行-请求头-请求体.md>***)

### get和post的缓存区别

通过以上的get和post的讲解,显然可以发现:get是可以被缓存的,而post则明显不行.

### url限制get请求传输的数据长度,而post无限制

通过以上的get和post的讲解,显然可以发现: 由于浏览器有url的长度限制,浏览器使用get又只能通过url,所以我们可以狭隘的说:在浏览器中使用get,数据长度会存在限制.(实际上get本身在http规范中是不存在长度限制的)

但是post是放于请求体中而不是url中的,而请求体的长度是没有限制的,所以post在浏览器中使用是不存在长度限制的.

### get和post的安全性

#### get

##### 基于传输的数据的可见性

由于在浏览器中使用get,其需要传输给终端的数据直接以query-string的形式添加到url的后面,所以基于这点来说,get传输数据是不安全的,它能直接被发现,就算是"小白"也是如此.

##### 基于服务器的安全性

从服务器的角度来说,其实get是安全的,因为它仅仅用于获取资源,而不会修改服务器的数据,攻击者几乎无法通过正常的get请求修改服务器的数据.

#### post

##### 基于传输的数据的可见性

由于在浏览器使用post请求传输数据时,其数据被放置于请求报文的实体主体(请求体)中,所以不会如get那样,直接显示在地址栏上,

对于不够聪明的人来说,这已经是挺安全的保护了,而且相较于get请求,也是较为安全的(实际上在很多人眼中,都是菜鸡)。

##### 基于服务器的安全性

其实对于服务器来讲,post请求并不安全,因为它可能修改服务器上的数据（攻击者通过 post 向服务器请求需要的数据，诱导服务器区更改/获取隐私数据，从而导致服务器陷入危险状态）,如果攻击者通过post请求恶意修改服务器的数据,这是非常危险的一件事情,

所以基于这点来讲,get比post安全。

### get和post的编码类型不同

浏览器使用get请求发送数据,数据在被转换时,用的编码为:application/x-www-form-urlencoded.

而post通常使用:multipart/form-data,但是也可以使用application/x-www-form-urlencoded.

这些application...编码其实都是Percent-encoding,即:[WIKI-URL编码](https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81)

### get和post允许的数据类型不同

get只允许ASCII字符,而post没有任何限制,它甚至允许二级制数据.

当然了,这一切只是在浏览器中,在非浏览器的环境下,使用HTTP协议的get和post,没有浏览器和HTML规范的限制,则它们二者都是不限制类型的.

# API中使用get和post

## 描述

即这里的API指的是,如:浏览器通过AJAX的API(*XMLHttpRequest*,***参见:<AJAX.md>***),或者是IOS/Android的App的http client,

java的commons-httpclient/okhttp或者是curl,postman之类的工具发出来的GET和POST请求.

对于此时的get和post请求来说,它们不光能用在前后端的交互中,还能用在后端各个子服务的调用中(即当一种RPC协议使用)

​	*ps:尽管RPC有很多协议,比如thrift,grpc,但是http本身已经有大量的现成的支持工具可以使用,并且对人类很友好,容易debug；HTTP协议在微服务中的使用是相当普遍的.*

且当使用实现HTTP协议的接口发送get/post请求时(任意请求),就不存在浏览器/html中那么多的限制,只要是符合HTTP协议规范的格式即可.

所以我们可以将post实现为幂等,而get实现不幂等且有副作用:

- POST幂等能让很多业务的前后端交互更顺畅,以及避免一些因为前端bug,触控失误等带来的重复提交,

  且使用HTTP POST(不是被浏览器和HTML规范限制的),就不会出现: "可能需要重新提交你之前已经输入过的数据",这种弹框了

  (***详见:浏览器中使用get和post - post - 场景例子)***

- 把GET实现为有副作用是个很可怕的事情,如:使用GET请求可以修改管理员的权限,从而会造成安全漏洞隐患.

## HTTP请求的格式

HTTP请求的格式大概是:***(参见:<HTTP请求行-请求头-请求体.md>)***

```html
<method> <url> HTTP/1.1

<Header>:<Header-value>
<Header>:<Header-value>
....
<!-- 空行，表示元数据已传输完毕 -->
<Entity-body data...>
```

- 注意:若使用get,则这里的\<url>并不会包含key=value等数据,这些数据处于的是请求头中,即\<Header>:\<Header-value>.

  这就是我们存在我们使用get传输的数据在请求报文中的格式.

其中 \<method> 可以是post/get或者是其他的HTTP Method,如:put,deleted,option等.

我们从HTTP协议本身(参见[RFC文档](http://www.kaiyuanba.cn/content/develop/rfc/))来看,它并没有限制所GET和POST要放在哪里,即:get传输数据时不一定要追加在url后,也可以放在Entity-body中; 

post也不一定要放在Entity-body,也可以追加在url后,而这和浏览器使用get和post的不同之处在于:浏览器和html规范限制了get和post,而不是HTTP协议本身.

正由于HTTP协议get和post的开放性,所以我们可以更加自由地去利用格式,如:让POST一半的参数放在query string中,另一半放在entity-body中;

 甚至如果你愿意,所有的数据你都可以放在 \<Header> (请求头)中,——你可以做各种各样的定制.只要请求的客户端和服务器端能够约定好.

## 使用get/post太自由的代价

在*HTTP请求的格式*下面我们有说到:只要我们愿意,只要符合HTTP请求的格式,则我们可以为get/post/等请求传输的数据格式进行定制,任意的放置于 \<Header>或\<Entity-body>中.

可是这并不是没有代价的: 相关开发人不能不每次讨论将数据追加在url后,还是path中,亦或者是entity-body,header中,诸如此类的问题,让开发变得极为低效,

于是理所当然的会产生一些规范/风格来帮开发人员免除这些烦恼,让他们统一起来(就和浏览器/html规范统一了get和post的传输数据以及传输数据类型什么的).

如:[REST API](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2),该API中规范了get和post,这两者是不能随便乱用的,如有兴趣,可自己深入了解.

事实上,在一个实际项目中,是不可能给你这么高的自由度的,因为只有项目规范化之后,才能方便维护及其测试.

这里只是让你们知道,可以这样做.

# get和post安全性问题

## get和post其实都不安全

在 ***浏览器中使用get和post - html和浏览器规范中get和post的区别 - get和post的安全性***我们有大概提到:get和post的安全性问题.

它们在两种情况下————基于服务器的安全;基于传输数据的安全. 其安全性是不同的,基于服务器的安全:get较为安全. 基于传输数据的安全:post较为安全.

但是如果从攻击的角度来说,其实它们"半斤八两",都不安全,**因为HTTP本身就是个明文协议,每个HTTP请求和返回的每个byte都会在网络上明文传播,不管是url,header还是body**

​	这根本就不是一个"传输的数据是否可以在地址栏中被看到"这么一个问题.

所以如果想要避免在传输过程中数据的窃取,则必须**做从客户端到服务器的端端加密**,其业界的通用做法为,使用:**HTTPS**——即用SSL协议协商出的密钥加密明文的http数据,这个加密的协议和HTTP协议本身相互独立.

> 当然,端端加密并不一定非得用https.比如国内金融领域都会用私有网络,也有GB的加密协议SM系列.但除了军队,金融等特殊机构之外,似乎并没有必要自己发明一套类似于ssl的协议.

- 在公网上,不加密等于自杀!

## 避免泄密的手段:HTTPS

回到HTTP本身: GET请求的参数确实更倾向于追加在url上(浏览器使用时是规范,而API通常是倾向于追加在后),因此有更多机会被泄漏.比如:

​	携带私密信息的url会展示在地址栏上,还可以分享给第三方,就非常不安全了.

此外,从客户端到服务器端,有大量的中间节点,包括网关,代理等,他们的access log通常会输出完整的url,比如nginx的默认access log就是如此;所以若url上有携带敏感的数据,就会被记录下来.

但请注意**,**就算将私密数据在body里,也是可以被记录下来的(若有兴趣请自己查证),因此如果请求要经过不信任的公网,**避免泄密的手段就是https**.

这里说的"避免access log泄漏":仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患,比如:

​	你应该不太希望让自己公司的运维同学从公司主网关的log里看到用户的密码吧.(同一局域网区域下,该区域通常是可信任的)

## 冰山一角的网络安全话题

关于安全的话题是非常多的,且现在的get和post只不过是冰山一角中的微末的一角罢了,比如:返回私密数据的mask,XSS,CSRF,跨域安全,前端加密,钓鱼,salt.

因为,单独讨论get和post哪个更为安全,其实意义并不大太,只需要清楚,一般情况下,POST+body的使用,再配合HTTPS协议会更加的安全就好.

# get和post有关编码的问题

## get和post用什么编码于它们本身无关

在 ***浏览器中使用get和post - html和浏览器规范中get和post的区别 - get和post的安全性***我们有大概提到:get和post存在编码上的不同的情况.

常见的说法是:GET请求的数据(参数)只能支持ASCII,而POST能支持任意binary,包括中文.

但其实这种说法是不严谨的,在*API中使用get和post*一节中我们可以发现:不论是get还是post它们二者都能放置于url的querystring或entity-body中.

所以更为确切的说:http中url用什么编码则get/post就用什么编码;entity-body中用什么编码则get/post就用什么编码,

即:用什么编码来解析get/post的传输数据并不会因为使用的是get/post有什么不同,而是由url或entity-body中的编码类型指定.

## 被Percent-encoding方式编码的url

那么url用什么编码呢?即:ASCII,其说法源自于:[RFC1738](https://www.ietf.org/rfc/rfc1738.txt).

> Thus, only alphanumerics, the special characters "$-_.+!*'(),", and
>    reserved characters used for their reserved purposes may be used
>    unencoded within a URL.

实际上这里规定的仅仅是一个ASCII的子集[a-zA-Z0-9$-_.+!*'(),] ,它们是可以"不经编码"在url中使用,比如尽管空格也是ASCII字符,但是不能直接用在url里.

那这个"编码"是什么呢?如果有了特殊符号和中文怎么办呢?所以一种叫做percent encoding的编码方法就是干这个用的：[WIKI-URL编码](https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E5%8F%B7%E7%BC%96%E7%A0%81),

这也就是我们前文中——get和post传输的数据格式不同 中提到的url中会出现一堆的`%xxx` 和 `+`和16位数字组成的序列.

使用Percent Encoding,即使是**binary data,也是可以通过编码后放在URL上**的.

但要特别注意: 这个**编码方式只管把字符转换成URL可用字符,但是却不管字符集编码**（比如中文到底是用UTF8还是GBK）

> 注意:尽管在浏览器地址栏可以看到中文,但这种url在发送请求过程中,浏览器会把中文用字符编码+Percent Encode翻译为真正的url,再发给服务器.浏览器地址栏里的中文只是想让用户体验好些而已.

若你想详细了解URL编码,请参见--[阮一峰的相关文档](http://www.ruanyifeng.com/blog/2010/02/url_encoding.html)

## 自由的entity-body数据格式

对于HTTP的entity-body(请求体)来说,它有个Content-Type可以明确指定其编码的类型,比如:

```basic
POST xxxxxx HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded;
charset=UTF-8

// 实体数据(请求体数据)
<entity-body data>
```

这里Content-Type会同时定义请求body的格式（application/x-www-form-urlencoded）和字符编码（UTF-8）.

所以相对于url提交数据给后端,**POST的规范好一些,相对不容易出错,容易让开发者安心**,*(因为使用url后追加的数据如果带有中文,还需要进行重新percent-encoding)*

如果浏览器想使用POST请求,通常做法是使用form表单,但是form表单提交只有application/x-www-form-urlencoded编码(这是form表单的entype的默认值),用来针对简单的key=value场景;

以及multipart/form-data用来针对只有文件的提交,或者同时有文件和key=value的混合提交表单的场景

还存在一个text/plain:表明文件(该数据)是普通文本(理论上是人类可读的)

但如果是Ajax或者其他HTTP Client发出去的POST请求,**其entity-body数据的格式就非常自由了,常用的有json,xml,文本,cs等等**,

只要前后端能约定好,你**甚至可以自己发明格式**用作: 请求传输的数据放置于entity-body时的格式.

# 浏览器的post需要发送两次请求?

## 先说答案

不一定,即:浏览器使用 post 可以只发送一次,两次,或者 n 次请求.

PS: get 由于在浏览器中只是获取资源,而不是请求服务器做某件事,所以它只需要发送给服务器一次请求,服务器响应并回传你想要"我"显示的资源(页面)即可.

## 答案为什么这么说?

首先我们要清楚,浏览器的post需要发送两次请求这种说法从何而来?

其实是因为: 在 *API中使用get和post - HTTP请求的格式*中,我们有提到HTTP请求的格式大致是什么样子,即,每个请求可以被分为:

- 请求头(\<method>,url,\<header>:\<header-value>)

  ​	也就是说请求行也被包含在了请求头中.

- 请求体(\<entity-body>)

正是因为HTTP协议规范定义这种格式,所以在使用HTTP(任何让服务器做某事的请求,如POST)请求时,有个约定:

所有的"控制类(有关配置)"信息应该放在请求头,而具体的数据(由使用者传输的数据)放在请求体中.

于是,因为这个约定,开发server的人总是会让服务器先解析请求头中的全部信息,在将了解请求头中包含的配置类信息后,再根据这个请求头的配置信息,决定如何处理这个请求,是接受?还是拒绝?然后根据相对应的方式去返回结果.

在 *实际例子*  一小节中,我会给出一个具体的例子,帮助你们理解.

## 实际例子

### 前言

需要注意的是,以下说的普通的请求,即是: 能向服务器发送请求并要求服务器去做某件事的请求,例如:post. 

而get明显不在此列,它只是单纯的获取服务器上的资源,服务器并没有为它做什么,是get主动去索取资源,然后由客户端(通常是浏览器)进行渲染罢了.

### 一个普通的请求发送一次

存在一个上传文件的服务,此时有一个文件需要被上传到服务器端,那么浏览器就会发送一个请求*(此时先不管该请求是什么请求)*给服务器,

该请求的头部中的url包含了文件名称,而请求体中是该文件被编码,然后压缩过后的一串111mb大小的二进制流.

当服务器接收这个请求时,会先检查请求头部中的信息,如:判断url中的文件名称是否符合规范,用户是否有权限上传文件等等,如果该请求头部中的配置信息不符合服务器的要求,

则服务器将直接停止继续处理该请求然后丢弃该请求,并返回的对应的失败结果,而不用等到连请求体中的二进制流都处理完成之后才返回一个失败的结果.

但是即使是这样,也浪费了服务器的[带宽](https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD)([知乎](https://zhuanlan.zhihu.com/p/86540005)),因为该文件并没有上传成功,但是浏览器发送请求时,仍然将该文件被压缩后的二进制流一起发送给了服务器,可是这个二进制流是没有任何用处!

### 一个普通的请求发送两次

由于在*一个普通的请求发送一次*一节中,我们发现,直接无脑的将需要传输给服务器的数据一起传送给服务器端,是一件很愚蠢的事情.

所以为了优化这一点,我们可以让客户端(浏览器)利用HTTP的Continued协议来这样做,即: 

浏览器发送请求时,先发送请求头部,让服务器先校验请求头部的各种配置(控制类)类信息: 

1. 如果失败则直接返回失败的结果,**到这里整个请求就结束了.**
2. 如果成功校验,(继续往下看)

则可以通知客户端(例如:服务器回复:"100 - Continue")你的请求头我已经看过了,符合要求,现在你把剩下的请求体中的所有信息发送给我把.

1. 这样如果服务器接收了这个请求,那么就会处理该请求,并可能返回一个成功的提示.**到这里整个请求就结束了.**
2. 如果服务器再通过请求头部校验之后,仍然拒绝了该请求,则可能回复一个失败的结果,如:400之类的错误,**到这里整个请求也结束了.**

通过以上的优化,我们可以发现,这样能大大的避免带宽的浪费,防止一个请求体中的数据流都没用到仍然会被发送给服务器,从而浪费带宽这一做法.

不过这种优化并不完美,仍然存在一个问题: 如果刚一个请求中的请求体数据信息量非常的少,比如:只有1kb等. 

那依靠这种优化,浏览器(客户端)依然会发送两次请求,这样反而会造成Round Trip,即往返,这是什么意思呢?即:

​	每个请求分成两次发送,但是每一次的请求在传输过程中都需要时间,且服务器来处理请求并返回响应的结果也需要时间,而**仅仅为了1kb的数据流可能造成的带宽浪费,去必然浪费一次往返的时间,这值吗?不值!**

所以为了仅仅1kb大小的请求体中的信息,从而多造成了1次往返(即发送请求,服务器响应对应结果),是没必要的.

因为,我们仍然可以继续为这一问题优化,请继续往下看.

### 一个普通的请求是发送一次?两次?还是n次好?

基于*一个普通的请求发送两次* 从而可能造成的"往返"导致浪费时间的问题,我们可以在一次进行优化,比如:

在客户端上进行优化,如:内部设定一次(post)请求的请求体中的数据信息:

1. 如果不超过1kb就一次性全部发送给服务器;
2. 如果超过1kb,就先发请求头,再发请求体.

甚至还可以做另一些优化,如:Adaptive的策略,统计发送成功率,如果成功率很高,就总是全部发等等.

不同浏览器,不同的客户(curl,postman)都可以有各自的不同的方案。不管怎样做,优化目的总是在提高数据吞吐量和降低带宽浪费上做一个折衷.

想达到十全十美近乎(或者说一定)是不可能的,所以:到底是发送一次请求,还是发送两次,亦或者是发送n次请求,都是不一定的,客户端(浏览器)可以自行决定,

因为**不管你发送多少次请求,都是符合HTTP协议的**,因为我们应该将这中发送几次请求**视为一种对HTTP协议的一种实现细节**,而不是说什么浏览器的post就是发送两次请求这种白痴话题,

也不要扯到get和post本身的区别上,真是无稽之谈.

# query string

即查询字符串,即 `?`后面那串key=value&key=value&...字符串.(不包括 `?`)

