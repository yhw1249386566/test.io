# [TCP 的三次握手](https://www.zhihu.com/question/24853633）

## 解释1

TCP作为—种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

TCP可靠传输的精髓：TCP连接的方A，由操作系统动态随机选取一个32位长的序列号（ （Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001,1002,1003.，并把自己的初始序列号SN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为10012000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号SN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001,2002,2003.…，并把自己的初始序列号SN告诉A，以便A可以确认B发送的每个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。

一句话概括，TCP连接握手，握的是啥？通信双方数据原点的序列号！以此核心思想我们来分析二、三、四次握手的过程。

A <-------> B

**四次握手的过程**

1. A发送同步信号SYN+A' s Initial sequence number
2. B确认收到A的同步信号，并记录As|SN到本地，命名B' s ACK sequence number
3. B发送同步信号SYN+B' s Initial sequence number
4. A确认收到B的同步信号，并记录  B's ISN 到本地，命名A' s ACK sequence number

很显然2和3这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。

二次握手的过程

1. A发送同步信号SYN+A' s Initial sequence number
2. B发送同步信号SYN+B' s Initial sequence number+ B's ACK sequence number

这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000.但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。

于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是个字节的数据，按照TCP对有数据的 TCP segment必须确认的原则，所以在这里A必须给B个确认，以确认A已经接收到B的同步信号。

有童鞋会说，如果A发给B的确认丢了，该如何？A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。

那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止

**补充阅读**

第一个包，即A发给B的SYN中途被丢，没有到达B A会周期性超时重传，直到收到B的确认

第二个包，即B发给A的SYN+ACK中途被丢，没有到达A B会周期性超时重传，直到收到A的确认

第三个包，即A发给B的ACK中途被丢，没有到达B A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为 Active状态

a.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为 Established状态，双向可以发包

b.假定此时A有数据发送，B收到A的Data+ACK，自然会切换为 established状态，并接受A的Data。

c.假定B有数据发送，数据发送不了，会直周期性超时重传SYN+ACK，直到收到A的确认才可以发送数据

总结：

也就是说：第三次握手时，不论 A 发送确认时，在传给 B 的过程中包有没有丢失，A 都不会进行超时重传这工作，超时重传会有第二次握手时的 B 去超时重传，因为 B 并不知道是不是因为它发送确实时的过程中包丢失，从而使得 A 没接收到，所以它会去超时重传。

这么一来，第二次握手的 B，会周期性的进行超时重传，直到 A 发送过来的 ACK（确认）。

请注意看 b 这一点，假如 A 发送了数据，B 有收到 Data + ACK，B 就会收到 A 的确认（数据都发送过来了，说明 A 和 B 都已经没问题），所以 B 自然会切换为 established状态，并接受A的Data。

## 解释2

1. **A -> B 发送一条信息**
   B 收到：B 就知道——A 发件 和 B 收件的能力。
   但此时 A 不知道 A 的发件能力 和 B 的收件能力。

2. **B -> A 回应一条信息**

   A 收到：A 就知道——A 发件和收件*（若 B 没收到 A 的发件，B 怎么回件？）*和 B 收件*（B 需要收到 A 发件，才会回件）*的能力。

   到目前两次握手：

   1. B 确认了 A 的发件能力和 B 的收件能力；
   2. A 确认了 A 的发件和收件能力以及 B 的收件能力；

   此时，只有 B 还并不知道 A 是否收到自己的发件，所以还未确认 B 的发件能力和 A 的收件能力 => 因为可能 B 发件没问题，但 A 收件有问题；又有可能 A 收件没问题，但 B 发件有问题。

   所以此时需要在进行一次握手（第三次），让 A -> B 发送信息，用来使得 B 可以确认 B 的发件和 A 的收件能力都没问题。

3. **A -> B 反馈一条信息**

   B 收到：B 就知道——B 的发件和 A 的收件能力。

若此若做，A 和 B 都能确认自己的发件和收件以及对方的发件和收件都没有问题，就可以安心的传递数据，不用担心丢包。



现在，让我们用专业一点的话来解释 TCP 三次握手的过程：

1. 客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号 ISN（比如是100），那么客户端向服务端发送的报文段包含 SYN 标志位（也就是SYN=1），序列号seq=100。
2. 服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号（比如是300）。然后给客户端回复一段报文，回复报文包含SYN和ACK标志（也就是SYN=1,ACK=1）、序列号seq=300、确认号ack=101（客户端发过来的序列号+1）。
3. 客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位（ACK=1）、ack=301（服务端序列号+1）、seq=101（第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101）。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

# TCP 的四次挥手

四次挥手的目的是关闭一个连接

- `第一次挥手`：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文（当然数据没发完时也可以发送连接释放报文并停止发送数据），释放连接报文包含FIN标志位(FIN=1）、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号）。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
- `第二次挥手`：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1）、确认号ack=1102(客户端FIN报文序列号1101+1）、序列号seq=2300(300+2000）。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- `第三次挥手`：服务端将最后数据（比如50个字节）发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1）、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50）。
- `第四次挥手`：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1）、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长）后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。

# 关于 TCP 的常见面试题

## 为什么TCP连接的时候是3次？2次不可以吗？

不可以。这是因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的**确认报文段丢失**，

此时服务端已经准备好了收发数据（可以理解服务端已经连接成功），而**客户端一直没收到服务端的确认报文**，所以客户端就不知道服务端是否已经准备好了（可以理解为客户端未连接成功），这种情况下**客户端不会给服务端发数据**，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，**服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手**，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

## 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开 TCP。

而客户端发出 FIN 报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。

而服务端收到客户端的 FIN 报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的 FIN 报文了，

但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

## 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。

服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。

若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# 参考文档

- [CSDN](https://blog.csdn.net/ThinkWon/article/details/104903925)
- [知乎]( )









