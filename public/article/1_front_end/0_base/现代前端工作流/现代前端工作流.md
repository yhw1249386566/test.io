# 工作流 Workflow

通常，对于现在（2023年8月17日）的前端来说，大多数使用 React、Vue、Angular 等框架和配套库（如：webpack）辅助开发，那么在它们背后，它们的工作流是什么？

以及我们使用框架背后进行本地开发的工作流又是什么？

# 简易工作流

## SPA 工作流简化如下

### 将需要的资源放入为本地服务开辟的内存中

这是一个 SPA 本地开发思想，我们通过 `node` 启动本地服务器，进行前端项目展示和调试，其背后工作流也是类似的。

- 我们这里用了类似 webpack 的手法, 写了一个简易的工作流程: 

  `webpack` 将会把所有打包好的文件 *(如：dist)* [存到内存](https://webpack.docschina.org/guides/development/) 中，然后再根据请求从内存读取对应文件内容并返回给前端，
  这会让这些打包后的文件就好像真的挂载在硬件服务器的根路径一样。
  这么做的好处是获取内存资源快，坏处是占用内存空间.

```
app
 - index.html
 - index.js
 - index.css
 - server.js
```

1. 你在本地写一个 `server.js` 文件, 使用 node 启动一个服务: `localhost:3000`.

   此服务将会监听 URL, 端口变化, 当访问 `/index.html`(对应的资源文件)  时, 将会读取 `index.html` 内容, 并返回响应.

```js
const http = require("http");
const fs = require("fs");
const path = require("path");

// 缓存到内存的文件内容
const memoryCache = {};

function readFolderToMemory(
  folderPath,
  parentFolder = "",
  excludedFolders = []
) {
  const files = fs.readdirSync(folderPath);

  files.forEach((file) => {
    const filePath = path.join(folderPath, file);
    // => 父文件夹名字/子文件夹名字/子文件名字
    // => article/0_base/index.md
    const key = path.join(parentFolder, file).replaceAll("\\", "/");

    // 检查是否在排除列表中
    if (!excludedFolders.includes(file)) {
      if (fs.statSync(filePath).isDirectory()) {
        // 如果是文件夹，则递归读取，并传递当前文件夹作为父级
        readFolderToMemory(filePath, key, excludedFolders);
      } else {
        const content = fs.readFileSync(filePath, "utf8");
        memoryCache[key] = content;
      }
    }
  });
}

const readFilePath = path.join(__dirname);

// 递归读取指定目录内每个文件的内容
readFolderToMemory(readFilePath, "", ["node_modules"]);

const server = http.createServer((req, res) => {
  const requestedFile = decodeURI(req.url.slice(1));

  if (memoryCache.hasOwnProperty(requestedFile)) {
    let header = { "Content-Type": "text/html" };

    // 根据不同的资源返回不同的响应头
    if (requestedFile.includes("css")) {
      header = {
        "Content-Type": "text/css",
      };
    }

    if (requestedFile.includes("js")) {
      header = {
        "Content-Type": "text/javascript",
      };
    }

    res.writeHead(200, header);

    res.end(memoryCache[requestedFile]);
  } else {
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("File not found");
  }
});

const PORT = 4000;
server.listen(PORT, () => {
  console.log(`Server is running at http://localhost:${PORT}`);
});
```

2. `index.html` 将被读取, 并被启动的服务作为响应返回;
   在这里就是返回响应给浏览器, 浏览器拿到内容, 将会解析为 html 并展示给用户.

   即: 解析 css, script 以及其他 html 节点

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="/index.css" />
  </head>
  <body>
    <h1>Welcome</h1>
  </body>
  <script src='./index.js' />
</html>
```

```js
// index.js
console.log("hello world");
```

```css
/* index.css */
h1 {
  color: red;
}
```

**这里值得注意的是:** 如果启动 node 服务时, 未提前将数据存入 

=> 操作系统为启动的服务开辟的内存中, 那么你访问某个未存入内存的资源时(比如: `hello.html`), node 启动的服务会找不到你要的资源, 从而走异常处理逻辑.

在这里将会返回响应: `File not found`

且我们这里采用递归的方式获取指定文件夹下的所有内容, 当存在一个庞大的文件夹时(如: node_modules) 这可能造成卡顿.

毕竟我们这里只是学习使用, 你可以采用 [http-server](https://www.npmjs.com/package/http-server) 这样的库, 它们采用了其他解决方案解决了类似的问题.

## 将文件放到服务器的工作流

对于直接将文件放到某个服务器里面，而不是通过本地开发，如果是纯前端的项目，就不需要 `server.js` 文件，所以文件目录为：

```
app
 - index.html
 - operator.js
```

- 硬件服务器：指物理硬件，即：一台可以托管应用程序、数据或服务的计算机。
  比如：自己的计算机、云服务器等。
- 软件服务器（或服务器软件）：服务器除了指硬件服务器之外，还有软件服务器，即：**运行在硬件服务器上的软件**，用于提供服务、应用程序或资源等。
  比如：Naginx, Tomact, Apache 等，
  软件服务器有多种多样的，比如：Web 服务器、数据库服务器、应用服务器等。

工作流是：

1. 将 `index.html` 和 `operator.js` 放到硬件服务器，利用 `Nginx` 或 `Tomcat` 等服务器软件提供资源（js, html, 图片等）给前端。
2. 使用 DNS 解析域名，将域名指向硬件服务器的 ip 地址，在硬件服务器上安装服务器软件（如：Nginx）并进行配置——比如：监听端口号，设置访问的域名等，
   让前端访问域名时，域名转到硬件服务器，然后此硬件服务器上的服务器软件可以进行拦截，处理前端请求。
3. 前端访问域名（如: whyhw.com），然 Nginx 处理请求并返回 `index.html`
4. 浏览器解析 `index.html`，如果解析到 `<script  src='/operator.js'/>`，则继续向 Nginx  发送请求并获取此资源（`https://www.whyhw.com/opeartor.js`）
5. 浏览器开始解释执行 `operator.js`
6. `operator.js` 执行完毕*（如果非异步执行，脚本文件就会先被浏览器执行，再解析 DOM，\<style/> 也是）*，再继续解析 DOM。
   当所有工作完成，浏览器会开始绘制 DOM，最终呈现给用户。
