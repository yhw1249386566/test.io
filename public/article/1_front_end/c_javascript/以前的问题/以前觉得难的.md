# 1. function(){}和new Function();

```js
<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <title>Document</title>

</head>

<body>



</body>

    <script>

​    /* 

​      用new Function()翻译这段代码，即：

​        sayColor → let sayColor; 

​        (sColor) → 'sColor'

​      【this.color = sColor;alert(this.color);】 → 'this.color = sColor;alert(this.color);'

​    */ 


​    function sayColor(sColor) {

​      this.color = sColor;

​      alert(this.color);

​    }

​    sayColor('red') //red



​    /* 

​      上面的写法和下面的写法结果是一样的

​      这段例子的目的在于: 
        有助于理解函数也只不过是一种引用类型，函数们的行为与用Function类明确创建函数的行为是相同的。
            也就是说语法糖的函数，说到底是Function类的参数。
​        或者可以说：function function_name(arg1,..,argn) { // function_body }; 是一个语法糖，它真正的写法应该是：

​          → let function_name = ( 'arg1',..,'argn', 'function_body，即函数要执行的代码;');

​      最后一个参数必须是函数需要执行的代码块，即主体。

​     */

​    let sayColor = new Function(

​        'sColor', // 参数

​        ' this.color = sColor; alert(this.color); ' // 函数执行主体

​      )

​    sayColor('red') // red

/* 
    现在直到为什么我们使用function name(){};时,可以直接调用它而不需要多一步new name();了吧？→ sayColor('red') 
    因为它本身已经就是被实例化，已经存于内存空间中了。
    而如果继续实例化一个函数：
        let name = new functionName();
    说到底只不过是用另一个指针继续指向一个指针而已
    →用name指针 指向 functionName指针。
        因为funciontName其实等于let functionName = new Function(...);所以我们说它是一个指针。
    所以这里即使双重指针：指针指向指针。
*/

  </script>

</html>
```

1. ​    但是若在语法糖当中写了一个方法，我们无法直接使用name.Method();这样的方式去调用这个方法。

2. 浏览器会报错：语法错误，Method不是一个函数。

3. 所以依然要实例化语法糖，使用一个指针(对象)去调用方法。
   
   ​    (待定,依然报错不是一个函数)

4. 但是实例化语法糖,用对象引用则可以调用语法糖中的属性.

# 2. 以上内容引发的思考

## Example

```js
    function sayColor(sColor) {

​      /*

​        即使给函数添加了color属性，并使用return返回此值，console.log也是undefined，这是因为并没有实例化此函数，

​          即使它已经是实例化过Function类的对象

​        若我们实例化它，并赋值，那么就可以捕获到color属性

​      */

​      this.color = sColor;

​      color = sColor;

​      alert(this.color);

​      return color

​    }

​    /* 

​      下面一行输出未定义的原因是因为，sayColor代表的是一整个函数，而此函数中并不存在color属性，

​      有的只是this.color。这两者有本质区别，this并不代表sayColor函数，而是代表调用此方法的对象~，

​      所以才会输出undefined

​     */

​    let b = new sayColor('blcak');

​    console.log(sayColor.color) // undefined
​     console.log(b.color); // black
```

既然function语法糖其实已经是一个对象（实例化Fucntion类），那

我们能否直接使用此对象调用它里面的方法/属性呢？

​    先说结论：不行，无法直接调用，必须得实例化此函数。（对象）

以上的代码充分的证明了1这一点，当只有

​    this.color = sColor;时，使用 console.log(sayColor.color);

并不能得出color属性，原因在注释中有讲。

​    即使给了sayColor函数单独的一个color属性并使用return返回它，也是输出undefined，这是为什么？

```js
           color = 'red';
        return this.color
```

​    明明sayColor函数中有color属性，并return返回了值，还是输出undefined？ 

​    很简单，因为sayColor本身不存在内存空间中，什么意思?为什么前面说function xx(){} 等于 let xx =  new Function('..','body'); 现在却说sayColor不存在?

​    这是因为function xx(){}虽然等于new Funtion(),但是要知道,function xx(){}并不是一个声明语句啊,它并不会被执行,也就不会存于内存空间中. 不存在内存空间中的数据,当然是输出undefined了! 

请继续往下看:

​        function sayColor() 和 let sayColor = new Function()

​    Function的实例sayColor存在于内存空间中，

​    function sayColor(){}; 中的sayColor还不存在于内存空间中.

- ​    前者是操作指针中存储的new Function(){}内存空间中的数据,即数据存于指针中,也就是存于sayColor这个变量中,而不是存于Function的实例中.

- ​    后者操作sayColor指针,其数据存在的是sayColor指针指向的Funtion的实例的内存空间中.

- ​    所以前者不能直接使用sayColor操作其里面的方法/属性,因为其方法/属性存在的是指针sayColor中,
  
  ​    此指针还不存在,还没new,亦没被声明,也就没有数据,那怎么操作.
  
  ​    后者就可以直接使用,因为sayColor指针不存在数据,只是指向了new Function(){}的内存地址空间,而new Funtion(){}是声明,
  
  ​        CPU会为之开辟一个内存空间地址存放数据,所以数据是存在的,所以能操作.

​    所以function sayColor(){}其中的属性/方法等也不存在于内存空间，所以我们必须得先实例化它，让它存于内存空间中，在使用对象引用（指针)引用它，这样才能获得它其中得属性/方法。function(){}和new Function();

```js
    function sayColor() {

        this.color = 'red';

    }
    let b = new sayColor(); // 这里有没有()都可.
    console.log(b.color)  // red
```

- **let b = new sayColor();**
  
  ​    这里的意思就是说:将sayColor(指针)中的数据存放在CPU开辟的内存空间地址中,然后使用b指针指向此内存空间地址,
  
  ​    所以既然sayColor已经有自己的内存空间了,当然可以存放数据了,所以此时使用b是可以访问sayColor内存空间中的属性/方法

## 为什么不使用prototype

看Example中的例子,我们不难发现,为什么不使用prototype为sayColor()函数创建一个存放在Prototype原型对象空间中的数据呢,这样是不是就可以用sayColor.属性/方法了?

不,想多了,因为使用prototype此属性创建的属性/方法,只能被prototype存在的函数(或者说是类/对象)的实例所使用.

```js
    function sayColor() {

        sayColor.prototype.color = 'red';
        return sayColor.prototype.color;

    }
    console.log(sayColor.color); // undefined 
```

- ​    很显然,我所说的是对的~ 或许有人会说,sayColor()函数根本不会被执行, `sayColor.prototype.color = 'red';`代码行也不会被执行,
  
  ​    凭什么说prototype没用,prototype可是一个声明语句,而且还能提到函数外面,这样它就会被执行,就会有用!
  
  ​    呵呵呵,请往下看:

```js
    function sayColor() {
    }
    sayColor.prototype.color = 'red';
    console.log(sayColor.color); // undefined 
```

- ​    很显然,依然undefined,即使将 `sayColor.prototype.color = 'red';` 代码行提到外面依然是如此.
  
  ​    是的,它被执行了,程序知道sayColor的指针prototype指向的Prototype原型对象内存空间地址中又存放了一个color数据
  
  ​    可是那又如何?这个Prototype对象中的数据可不是一般人能动的,除了调用prototype指针,然后让其在Prototype对象中存放的函数的实例(对象),有谁能动Prototype对象中数据?没有!
  
  ​    对!即使是sayColor()函数本身的名字sayColor也不行.

# 3.因函数中错误使用return的死循环

```js
    死循环写法：
​   let beChanged = new Functon
(
    'confirm("确定改变吗？");
     return beChanged();'
); 
​    console.log(beChanged());
```

​    因为return beChanged()代表返回函数值,也代表函数被调用,

而此时，这里函数的函数值为：

```js
    ƒ anonymous() {
      confirm("确定改变吗？");
      return beChanged();
    };
```

​    当然，如果仅仅只是这一段函数代码块不会造成死循环,即

```js
    let beChanged = new Functon
(
    'confirm("确定改变吗？");
     return beChanged();'
); 
```

​    原因很简单，函数的return beChanged();它只会带出数据，而不会执行它，需要有触发点，所以真正造成死循环的是：

```js
    console.log(beChanged());
```

- ​    更为直白地说：任何调用beChnaged()函数且能让它执行其中代码块的都能造成死循环。
  
  ​    因为当你执行这段代码时，肯定会调用此函数：
  
  ​        即上面的那段函数。
  
  ​        *<u>至于为什么它的函数名叫 anonymous(无名的),后面会解释。</u>*

- ​    程序会执行此函数代码，由于函数代码中有return beChnaged();
  
  ​        程序会捕获到再一次调用了此函数，即上面那段代码块，所以又会执行，直到碰到return beChanged();

- ​    程序又又捕获到再一次调用,又执行..

- ​    如此反复，造成死循环。
  
  ## 简单来说就是：

- ​      第一次弹出对话框,返回（带出）函数值
  
  ​        运行consoloe，调用函数返回值（即调用函数本身)。
  
  ​        程序执行函数代码块（即你最初创建的函数： )
  
  ```js
  new Function(
      'confirm("确定改变吗？");
       return beChanged;'
  );
  ```
  
  ​         不执行函数，程序怎么直到函数返回值是什么，每次调用函数，程序都会执行一次函数本身。
  
  ​        因函数本身中又调用此函数，即继续执行此函数。

- ​      第二次弹出对话框，又调用函数
  
  ​        执行函数

- ​      第三次弹出对话框，又调用函数
  
  ​        执行函数

- ​      ...

为什么new Function()里面的return beChanged()在没有console时不会执行，而是解释为带出函数值，

反而执行了console时，调用的函数的return beChanged();反而会被执行，而不是解释为带出？

emm,盲猜是因为触发的问题，即console触发了return beChanged();后，会导致它变为运行状态，而不是返回状态…别管这么多。以后再说。

(突然想到了，请往下看)

----------------------------

因为return从字面意义上来讲代表返回，如果在一个函数中写了return;那么程序在执行到这个return;语句时，将会立即中断函数执行，

​        若return有返回值，则将返回值返还给调用者。 

​        若没有指定返回值，则返回undefined，除非有使用一些别的手段。

所以当只有new Function()时，里面的return beChanged();只是单纯的中断函数，并没有带出返回值beChanged()，所以它是不会无限循环的，

当出现调用者console时，调用的函数返回值，程序将会执行此函数的代码块，得到它的返回值，

所以在函数里面的→return beChanged();将会被运行，它被运行的原因是因为 return会将值返回给调用者，

而此时，调用者是beChanged();    即这个beChanged()运行时，程序所执行的代码块。

那么又会在代码块中遇到return，return又会将值beChanged()传给调用者beChanged();继续导致函数返回值被执行，

返回值被执行，即就是函数代码块又被运行，又再一次再代码块中遇到return beChanged();    return又会再一次将值返回给调用者beChanged，而值又是beChanged();     又会执行…

一直无限循环。

-----

本来beChanged();就是调用函数的返回值

而此时，函数的返回值是：beChanged();函数的返回值.

----

调用者console调用函数返回值时，执行函数代码块    

​        ——————得到函数返回值return beChanged();

由于函数返回值return beChnaged();是因为console调用函数返回值时执行函数代码块时遇到的，

所以当执行到return beChanged();时，将会再一次返回bechanged函数的返回值给调用者，而此时调用者为beChanged();

函数返回值将会被返还给beChanged();

就相当于 a ( b( ) );即beChanged()调用了beChanged();

​    中文意思:beChanged()调用了beChanged函数的返回值:beChanged();

那又会执行一次函数代码(因为有beChanged())，

​    又再一次遇到return beChanged(); 又再一次会把上一个beChanged(); 当作调用者执行beChanged(); 又又再一次执行beChanged函数，判断函数返回值为：beChanged();，

​    又会返回给调用者beChanged(); 又会执行beChanged() ( beChange() ),又再一次遇到return beChanged(); 又会返回给调用者…又

如此反复，一直循环。

## 当然不一定要使用return才能造成死循环，请看下面的示例代码

以下一个超简单的死循环

```js
    // 超简短的死循环    
    // (function_code)();调用函数代码的返回值，即自调用
​    (function fcn1(){

​      alert('死循环')

​      console.log(fcn1()); // 换成：return(fcn1()); 也行

​    })();
```

> 至于为什么会是ƒ anonymous()，而不是f beChanged()，简而言之：
> 
> ​    anonymous：无名函数
> 
> ​    或者说是：actually an anonymous function：即实际上是一个匿名函数。
> 
> 而关于匿名函数是什么？这里我们不过多赘述，会后续在后文讲清。

# 数值加字符串出现的循环累加问题

```js
<script>
    let a = 2;
    let b = '';
    while(a != Infinity) {
        a = a * a;
        b = b + a + "<br/>"

    }
    document.write(b)
    document.write('这一长串为字符串')
</script>
```

输出结果为: 

> ​        4    
> 
> ​        16
> ​                256
> ​                65536
> ​                4294967296
> ​                18446744073709552000
> ​                3.402823669209385e+38
> ​                1.157920892373162e+77
> ​                1.3407807929942597e+154
> ​                Infinity
> ​                这一长串为字符串

​    此为运行代码块时，浏览器页面会显示的结果。根据此结果，常见的疑问会有两个:

1. 为什么它会一行一行的输出下来，像是每次循环都输出一次一样。

2. b = b + a不是会累加吗？不是应该是
   
   ​    →  a = 2 * 2;     b = ''+ 4        a = 4 , b = 4
   
   ​          a = 4 * 4;     b = '4’ + 16;  a  = 16,b = 416;
   
   ​            …..
   
   为什么现在会显示一行行的，且不因为有字符串与数字相加造成的级联的结果，而是像两个数字相加一样呢？
- 请注意： b = b + a + "<br/》"中的<br》,它代表了折行。而且它是一个字符串，所以这就等于：b + a + 一个字符串
  
  ​    第一次计算时， 由于b也是字符串，所以等于: 一个字符串+数值+折行字符串。
  
  ​    最后变成级联，b会一直累加为:
  
  ​        `"4<br/>16<br/>256<br/>65536<br/>4294967296<br/>..."`
  
  ​    最后的 document.write(b)，它将会输出b这串字符串。
  
  ​    注意：由于在b这字符串中有\<br>折行的存在，这会导致js在解析时碰到<br》就会折行，而不会输出\<br>,。
  
  ##### 这就会造成浏览器页面输出这么多行的景象。
  
  ##### 这也会让我们误以为每次循环输出一次，b也没有进行累加。
  
  ##### 这是错误的理解，正确的理解为：
  
  ​        一次性输出了b字符串，由于字符串中有\<br>而导致折行。
  
  ​        b有进行累加，由于b为字符串，\<br>也为字符串导致会变成级联，而不是数值相加。
  
  ​            → `4<br/> + 16 + <br/>` → `4<br>16<br/>`
  
  ​        最终就会显示为：
  
  ​            `"4<br/>16<br/>.."`
