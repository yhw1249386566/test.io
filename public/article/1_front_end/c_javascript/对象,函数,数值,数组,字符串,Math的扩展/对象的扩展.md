[TOC]

# 简要

对象(object)是JavaScript中最重要的数据解构,ES6对它进行了重大升级.

注意: 在ES6之前,JS对象中的属性名都是字符串,不过ES6中有办法将之改变成变量.

# 属性的简洁表示法

- 使用变量作为属性的名和值,即变量名作为属性名,变量值作为属性值.

- 方法的简写: 直接使用属性名,后跟(参数),{..}作为对象的方法.
  
  → funcName(.) {..} == funcName: function(...){...}

## 简洁表示对象的属性和方法

ES6允许在一个对象中,直接写入变量名和函数名作为对象的属性名和属性值,以及方法(属性中存放的是一个方法).

```js
let foo = 'yhw';
const obj1 = {
    foo,
    func(){return 'yomua'}
}
// 等效于
const obj2 = {
    foo:'yhw',
    func:function(){return 'yomua'}
}

console.log(obj1); // {foo: "yhw", func: ƒ}
console.log(obj2); // {foo: "yhw", func: ƒ}
// f代表是一个函数
```

使用ES6对象的写法,能大大的提高代码的简洁以及可读性.即:

如果在一个对象中使用一个变量作为其属性,则变量名就是属性名,变量值就是属性值,怎么样,是不是方便快捷.

而且在对象中可以直接写类似外部的函数形式( *function name(...){...}* ): 
`func(...){...}`, 则相当于: `func:function(){return 'yomua'}`

这样一比,显然前者更加简单易懂,而且方便,如果一个函数的返回值是一个对象,那么我们使用ES6在这种写法将会非常方便:

```js
function func() {
    const a = 1;
    const b = 2;
    return {a, b};
    //等效于
    return {a:1, b:2};
}
console.log(func());
```

- PS:ES6之前,JS对象中的属性名都是字符串,不存在变量,但是ES6有办法将之改变成变量.
- 我们上面这种写法,并不是将对象中的属性名当作变量,只是将变量名作为属性名而已(属性名仍是字符串:`'a' 'b'`),变量值作为属性值.

属性的简洁表示,其实用了变量的解构赋值的概念(或许反过来说变量的解构赋值用了简洁表示也行)

对于解构赋值来说,左边的变量其实是属性值,而它的属性名刚好和属性值的名一样,且属性名是一个模式,用来匹配等号右边的值的.

等号右边的值也是赋值给这个属性值的(等号左边的变量名),而不是属性名,显然简洁表示也是这样,即变量名等于属性名,变量值等于属性值

即外部的变量名匹配对象内部的属性名(简洁表示的),然后将变量值赋值给对象的属性值(简洁表示的)。

对象中属性值(简洁表示的)相当于解构赋值等号左边的变量,而对象外部的变量名和其值相当于解构赋值等号右边的变量名和其值…

所以才说他们两个概念上差不多

## 简洁表示在输出对象时使用

```js
let user = {
  name: 'test'
};

let foo = {
  bar: 'baz'
};

console.log(user, foo);
console.log({user, foo});
/*
    {name: "test"} {bar: "baz"}
    {user: {name: "test"}, foo: {bar: "baz"}}
*/
```

- ***console.log({user, foo});***
  
  ​    注意这里的log()括号中,输出的是一个对象,但是er我们知道对象是要有属性名和属性值的,而这里只存在一个值,
  
  ​    所以理所当然的这是对象的简洁表示法,这个数值(user,foo)表示某个变量,即: 根据前文讲到的,变量名作为对象的属性名,变量值作为对象的属性值,
  
  ​    所以这里应该是: `user:user值, foo:foo值`,现在我们再来看user和foo变量的值是什么,即:
  
  ​     `user: {name: "test"}, foo: {bar: "baz"}`, 同时这两个属性又在一个对象中,所以最终结果为: 
  
  ​    `{user: {name: "test"}, foo: {bar: "baz"}}`,即一个对象中存在两个属性:user和foo,且它们的值都是对象.

# 属性名表达式

即除了表达式是对象 以外的表达式,作为其对象的属性名,也就是说,我们可以为对象的属性名定义变量,而不再只是字符串了.

```js
    let x = 'name';
    let obj = {
        [x]:'yhw'
    }
    console.log(obj[x]); // yhw
    // 等效于 
    console.log(obj['name']); // yhw
```

更多实例与讲解请往下看.

## 属性和方法名使用表达式

算上ES6的话,现在的JS定义对象的属性,方法(和访问属性),有两种方式:

```js
// 方法一
obj.foo = true;

let obj = {
    foo:true

}

// 方法二
obj['a' + 'bc'] = 111;

let obj = {
    ['a' + 'bc']: 111
}
```

**方法一**: 这是ES6之前使用的定义对象的属性的方式,即使用标识符作为属性名.

**方法二:** 乍一看,方法二似乎有些难以理解,但是如果你仔细看的话,就可以发现,它只不过是加了括号的表达式罢了.即ES6允许创建字面量对象时,使用方法二(表达式)作为对象的属性名,即把表达式放在一个中括号内.

方法二存在两种访问对象的属性的方式:

```js
console.log(obj['a' + 'bc']); // 111
console.log(obj['abc']); // 111
```

- 即很明显的,我们可以直接使用 `'表达式'`来作为访问对象的属性的方式, 或者也可以使用`表达式计算后出来的值`作为访问对象的方式.

当然了,[expression]这样的形式也能作为一个对象的方法名,同时也能使用[expression]和表达式计算出来的值来访问对象的属性.

```js
let obj = {
        ['h' + 'ello']() {
        return 'hi';
    }
};
console.log(obj.hello())// hi
console.log(obj['hello']()); // hi
console.log(obj['h' + 'ello']()); // hi
```

## 属性名表达式是一个对象时

使用属性名表达式,需要特别注意:若一个表达式是object(对象)时,会出现一个问题:

​    即默认情况下,使用一个表达式作为属性名,且这个表达式为对象时,将会被自动解析(计算)为: `[object Object]`,是的,会得出这一整个结果,包括中括号.

```js
    const keyA = { a: 1 };
    const keyB = { b: 2 };
    const keyc = { c: 2 };
    const myObject = {
        [keyA]: 'valueA',
        [keyB]: 'valueB',
        foo: 3,
        [keyc]: 'valueC',
    };
 // {[object Object]: "valueC",foo: 3}
    console.log(myObject) 
```

很有趣不是吗,至于为什么我们写了三个表达式,只出现了一个对象的属性:[object Object], 这是因为表达式只要是对象,

那么这个表达式用于对象的属性名时,都会被自动计算为`[object Object]`,所以[keyA],[keyB],[keyc]三个表达式的计算结果都为[object Object],

即就相当于最后一个[object Object]属性名覆盖了前面相同的属性名,所以只存在了一个 [object Object]: "valueC" 

更有趣的是,当一个对象的属性名使用表达式且此表达式为对象时,这个对象中的属性和方法的顺序将被排序,即:

​    当程序自上而下运行时,只要出现属性名是表达式且为对象的,就会将当前执行的对象中所有表达式为对象的属性名直接提到第一次出现的表达式为对象的属性名的位置,并用最后一次出现的[object Object]: value,作为其key:value.

​    而此时的对象就会变成: `{..., [object Object]: value,...}`类似的形式.

---

但有意思的是,特殊的对象:数组,并不再此列,它还依然会被解析成一个正常的表达式,即若一个表达式是数组时,并不会出现这样的问题.

```js
    const keyA = [1,2];
    const keyB = [3,4];
    const myObject = {
        [keyA]: 'valueA',
        [keyB]: 'valueB'
    };
    console.log(myObject);// {1,2: "valueA", 3,4:"valueB"} 
```

很显然, 表达式依然会发挥它的正常作用,而不是被强制解析为:
 `[object Object]`

# 对象的方法的name属性

## 普通的方法

我们知道,函数存在name属性***(参见<函数的扩展.md>)***, 那么很自然的可以想到对象中如果存在属性方法(即属性中放入函数),那么自然也会有name属性.

```js
const person = {
  sayName() {
    console.log('hello!');
  },
};
console.log(person.sayName.name)  // "sayName"
```

## 对象访问器get和set

但是需要注意:如果对象中的方法是对象访问器get和set***(参见<对象.md>)***,那么`name`属性不是在该方法上面,而是在该方法的属性的描述对象的`get`和`set`属性上面,即在该方法的属性描述符上,其返回值为:方法名前加上`get`和`set`.

```js
const obj = {
  get foo() {},
  set foo(x) {}
};
obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

//{enumerable: true, configurable: true, get: ƒ, set: ƒ}
console.log(descriptor)
descriptor.get.name // "get foo"
descriptor.set.name // "set foo"
```

- ***Object.getOwnPropertyDescriptor(obj,prop)***
  
  ​    obj:指定的对象, prop:需要查找的属性的名称.
  
  ​    返回指定对象上一个自有属性对应的属性描述符.(自有属性指的是直接赋予该对象的属性,不需要从原型链上进行查找的属性)
  
  ​    在这个示例意为: 找到obj对象的自由属性foo其对应的属性描述符是什么.

## bind()创建的新函数和Function()构造函数创建函数

使用name属性还会遇到两种特殊情况：`bind`方法创造的函数,`name`属性返回`bound`加上原函数的名字；

`Function`构造函数创造的函数,`name`属性返回`anonymous`.

```javascript
(new Function()).name // "anonymous"  匿名的

var doSomething = function () {
    // ...
};

console.log(doSomething.bind().name)// "bound doSomething"
// 等效于
let d = doSomething.bind();
console.log(d.name); // "bound doSomething"

console.log(doSomething.name); // doSomething
```

- ***doSomething.bind().name*** 
  
  创建一个新函数,新函数是克隆doSomething函数的.
  
  需要注意的是,这个新函数并没有让某一个变量指向它,这意味着,这个新函数只存在于使用 `doSomething.bind();`此语句的一刹那.
  
  请看最后一句: console.log(doSomething.name); // doSomething 
  
  即: doSomething函数仍然是没有变的,这就是证明.

## 如果对象的方式是个是symbol值

如果对象的方法是一个 Symbol 值,那么`name`属性返回的是这个 Symbol 值的描述.

```javascript
const key1 = Symbol('I am description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // [I am description]
obj[key2].name // "" (一个空字符串)
```

上面代码中,`key1`对应的 Symbol 值有描述,`key2`没有.

且返回的值是存在中括号的.

# 属性的可枚举性和遍历

参见<ES6-阮一峰>

## 可枚举性

## 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性.

### for...in

`for...in`循环遍历对象自身的和继承的可枚举属性(不含 Symbol 属性).

### Object.keys(obj)

`Object.keys`返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含 Symbol 属性)的键名.

### Object.getOwnPropertyNames(obj)

`Object.getOwnPropertyNames`返回一个数组,包含对象自身的所有属性(不含 Symbol 属性,但是包括不可枚举属性)的键名.

### Object.getOwnPropertySymbols(obj)

`Object.getOwnPropertySymbols`返回一个数组,包含对象自身的所有 Symbol 属性的键名.

### Reflect.ownKeys(obj)

`Reflect.ownKeys`返回一个数组,包含对象自身的所有键名,不管键名是 Symbol 或字符串,也不管是否可枚举.

### 总结

以上的 5 种方法遍历对象的键名,都遵守同样的属性遍历的次序规则.

- 首先遍历所有数值键,按照数值升序排列.
- 其次遍历所有字符串键,按照加入时间升序排列.
- 最后遍历所有 Symbol 键,按照加入时间升序排列.

```javascript
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
```

上面代码中,`Reflect.ownKeys`方法返回一个数组,包含了参数对象的所有属性.这个数组的属性次序是这样的,首先是数值属性`2`和`10`,其次是字符串属性`b`和`a`,最后是 Symbol 属性.

# super关键字

- 只能用于简洁表示的对象的方法中,即:
  
  let obj = { funcName() {..}, foo}, 其他用法则会报错,请往下看

我们知道,`this`关键字总是指向函数所在的当前对象,ES6 又新增了另一个类似的关键字`super`,指向当前对象的原型对象.

```javascript
    const proto = {
        foo: 'hello'
    };

    const obj = {
        foo: 'world',
        find() {
            return super.foo;
        }
    };

    Object.setPrototypeOf(obj, proto);
    console.log(obj.find())    // "hello"
```

- ***Object.setPrototypeOf(obj, proto);***
  
  将obj对象的原型对象设为proto对象.

- ***return super.foo;***
  
  会返回这个return语句当前所处的对象的原型对象上的foo属性,即proto这个对象上的foo属性,所以输出hello.

需要注意的是: `super`关键字表示原型对象时,只能用在对象的方法之中,用在其他地方都会报错.

```js
// 报错
const obj = {
  foo: super.foo
}

// 报错
const obj = {
  foo: () => super.foo
}

// 报错
const obj = {
  foo: function () {
    return super.foo
  }
}
/*
    'super' keyword unexpected here
*/
```

上面三种`super`的用法都会报错,因为对于 JavaScript 引擎来说,这里的`super`都没有用在对象的方法之中.

第一种写法是`super`用在属性里面,第二种和第三种写法是`super`用在一个函数里面,然后赋值给`foo`属性.

**目前,只有对象方法的简写法可以让 JavaScript 引擎确认,定义的是对象的方法.**

JavaScript 引擎内部,`super.foo`等同于

​    `Object.getPrototypeOf(this).foo`(属性)或

​    `Object.getPrototypeOf(this).foo.call(this)`(方法)。

# 对象的扩展运算符

参加<变量的解构赋值.md> , <展开语法.md>

- 即在对象中使用展开语法就如同使用 Object.assign();
  
  即克隆一个/多个对象到另一个新对象中去.

## 补充

### 合并两个对象

扩展运算符可以用于合并两个对象.

```javascript
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

如果用户自定义的属性,放在扩展运算符后面,则扩展运算符内部的同名属性会被覆盖掉.

```javascript
let a = {x:'yomua',y:"yhw",z:11};
let aWithOverrides = { ...a, x: 1, y: 2 };
console.log(aWithOverrides);//{x: 1, y: 2, z: 11}
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
```

上面代码中,`a`对象的`x`属性和`y`属性,拷贝到新对象后会被覆盖掉

这用来修改现有对象部分的属性就很方便了.

```javascript
let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
```

上面代码中,`newVersion`对象自定义了`name`属性,其他属性全部复制自`previousVersion`对象.

如果把自定义属性放在扩展运算符前面,就变成了设置新对象的默认属性值,即自定义中和扩展运算符内部同名的属性会被覆盖掉.

```javascript
let a = { x: 'yomua', y: "yhw", z: 11 }
let aWithDefaults = { x: 1, y: 2, ...a };
console.log(aWithDefaults);//{x: "yomua", y: "yhw", z: 11}
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
```

与数组的扩展运算符一样,对象的扩展运算符后面可以跟表达式.

```javascript
    let x = 5;
    const obj = {
        ...(x > 1 ? { a: 1, b: 2, c: 'yomua' } : {}),
        b: 3,
    };
    console.log(obj)
```

- ***...(x > 1 ? { a: 1 } : {}),***
  
  ​    若x变量大于1,则让x变量指向{a:1}对象,否则指向{}空对象,最后在将此对象所有可遍历属性拷贝到当前对象(obj)中.
  
  ​    若此扩展运算符中的对象的属性和当前对象的属性重叠,则依据程序执行的先后顺序进行覆盖,即在后面的覆盖前面的,
  
  所以这里的b:2会被b:3覆盖,最后得出结果为: 
  `{a: 1, b: 3, c: "yomua"}`

扩展运算符的参数对象之中,如果有取值函数`get`,这个函数是会执行的.

```javascript
// 并不会抛出错误,因为 x 属性只是被定义,但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throw new Error('not throw yet');
  }
};

// 会抛出错误,因为 x 属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throw new Error('throw now');
    }
  }
};
```