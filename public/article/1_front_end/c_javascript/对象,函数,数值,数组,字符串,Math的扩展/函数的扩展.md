[TOC]

# 基本用法

## 函数参数可以指定默认值

## 参数指定默认值和解构赋值一起使用

参见<变量的解构赋值.md>

## 函数的 length 属性

指定了默认值以后,函数的`length`属性,将返回没有指定默认值的参数个数.也就是说,指定了默认值后,`length`属性将失真.

```javascript
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

上面代码中,`length`属性的返回值,等于函数的参数个数减去指定了默认值的参数个数.比如,上面最后一个函数,定义了 3 个参数,其中有一个参数`c`指定了默认值,因此`length`属性等于`3`减去`1`,最后得到`2`.

这是因为`length`属性的含义是,该函数预期传入的参数个数.某个参数指定默认值以后,预期传入的参数个数就不包括这个参数了.同理,后文的 rest 参数也不会计入`length`属性.

```javascript
(function(...args) {}).length // 0
```

如果设置了默认值的参数不是尾参数,那么`length`属性也不再计入后面的参数了.

```javascript
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

不过我们依然可以使用arguments对象获取到所有参数的个数,因为arguments对象不论实参有没有对应的形参,都会获取有多少个数.

# 函数参数的作用域

如果我们为函数的参数制定了默认值,则函数进行声明初始化时,参数(即括号中)内会形成一个单独的作用域. 只有函数初始化结束后,这个作用域才会消失.

而这种行为,如果不指定函数参数的默认值,是不会出现的.

```javascript
    var x = 1;

    function foo(x = x) {
        // ...
        return x
    }

    console.log(foo())   //Uncaught ReferenceError:Cannot access 'x' before initialization
```

以上示例foo函数的参数中: x = x;  然后我们调用foo()函数,却发现出错: 不能在初始化x之前就使用x.

咦,我们不是已经声明(初始化)了x吗?并且是使用var,为什么还报错呢? 这就是我们所说的,如果指定了参数默认值,则会在参数内部形成一个块级作用域,只有函数初始化结束后,这个作用域才消失.

也就是说(x = x)就如同(let x = x),当然会报错了,即暂时性死区了.

注意: 如果函数的参数的默认值指定的是一个函数,也是如此.(即函数参数是变成了匿名的回调函数)

```javascript
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x); // 3
  console.log(this.x); // 1
}

foo();
console.log(x); // 1
```

- ​    之所以foo()内部的console.log(x);结果为3,是因为(x, y = function() { x = 2; })里面会形成一个单独的作用域,

  ​    即使调用了y(),也不会影响到var x = 3和var x = 1; 不输出1的原因,是因为x又被重新赋值,当然输出3了.

-  console.log(this.x); // 1

  ​    这个输出1,是因为我们使用了this,指向了全局对象,window. 而为什么不输出3的原因在于this,它指向的是外面的全局变量x,而不是foo()内部的全局变量x. 

# 	rest参数

参见:<变量的解构赋值.md>

# 严格模式

从 ES5 开始,函数内部可以设定为严格模式.

```javascript
function doSomething(a, b) {
  'use strict';
  // code
}
```

ES2016 做了一点修改,规定只要函数参数使用了默认值、解构赋值、或者扩展运算符(展开语法/剩余参数),那么函数内部就不能显式设定为严格模式,否则会报错.

```javascript
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```

这样规定的原因是,函数内部的严格模式,同时适用于函数体和函数参数.但是,函数执行的时候,先执行函数参数,然后再执行函数体.

这样就有一个不合理的地方,只有从函数体之中,才能知道参数是否应该以严格模式执行,但是参数却应该先于函数体执行.

两种方法可以规避这种限制.第一种是设定全局性的严格模式,这是合法的.

```javascript
'use strict';

function doSomething(a, b = a) {
  // code
}
```

第二种是把函数包在一个无参数的立即执行函数里面.

```javascript
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
```

# name 属性

函数的`name`属性,返回该函数的函数名.

```javascript
function foo() {}
foo.name // "foo"
```

这个属性早就被浏览器广泛支持,但是直到 ES6,才将其写入了标准.

需要注意的是,ES6 对这个属性的行为做出了一些修改.如果将一个匿名函数赋值给一个变量,ES5 的`name`属性,会返回空字符串,而 ES6 的`name`属性会返回实际的函数名.

```javascript
    var yomua = function () { };
    console.log(yomua.name); // yomua
//ES5中,返回 ""
```

上面代码中,变量`yomua`等于一个匿名函数,ES5 和 ES6 的`name`属性返回的值不一样.

如果将一个具名函数赋值给一个变量,则 ES5 和 ES6 的`name`属性都返回这个具名函数原本的名字.

```javascript
const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"
```

`Function`构造函数返回的函数实例,`name`属性的值为`anonymous`.

```javascript
let yhw = new Function('arg1','arg2',(`console.log("hhh");return "返回值"`));
    console.log(yhw.name); // anonymous
	console.log(yhw()); // hhh 返回值
```

`bind()`方法返回的函数,`name`属性值会加上`bound`前缀.

```javascript
function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
```

# 箭头函数

## 描述

箭头函数 `=>` 是已经经常用到的一个ES6技法之一.

参见:<h5_css_js.doc>

详情请看《JavaScript》帮助文档

箭头函数表达式的语法比函数表达式更简洁,并且没有自己的this,arguments,super或 new.target.

这些函数表达式更适用于那些本来需要匿名函数的地方,并且它们不能用作构造函数.

箭头函数允许使用简短的函数来编写函数表达式,不需要 function 关键字、return 关键字以及花括号.

```js
let x = function ( x , y ) { return x + y }
// 等效于
const/let x =  (x , y ) => x + y
```

即一个函数的大括号中的只有return语句,则我们能省略掉return和大括号.

## 使用注意事项

需要注意的是:

- 箭头功能没有自己的 this.它们不适合定义对象方法,即函数体内的`this`对象,就是定义时所在的对象,而不是使用时所在的对象.

- 箭头功能未被提升.它们必须在使用前进行定义.

- 使用 const 比使用 var 更安全,因为函数表达式始终是常量值

- 如果函数是单个语句,则只能省略 return 关键字和花括号.因此,保留它们可能是一个好习惯（建议）

  →：即如果函数是多个语句,则无法省略.

  ​    即箭头函数的=>右边可以有多个代码块,只需要用{}大括号括起来,就和写普通的被{}大括号括起来的代码块一样,如:

  ```js
      let account = () => {
  		console.log('请输入账号');
  		console.log('a')
  	};
  /*
   请输入账号
   a
  */
  ```

- 如果箭头函数直接返回一个对象,则必须使用()包住,否则会报错,

  因为JS引擎会把它识别为代码块,很显然代码块无法直接使用属性:值的形式.

  let getTempItem = id => ({ id: id, name: "Temp" });

- 不可以当作构造函数,也就是说,不可以使用`new`命令,否则会抛出一个错误.

- 不可以使用`arguments`对象,该对象在函数体内不存在.如果要用,可以用 rest 参数代替.

- 不可以使用`yield`命令,因此箭头函数不能用作 Generator 函数.

上面的注意点中,第一点尤其值得注意.`this`对象的指向是可变的,但是在箭头函数中,它是固定的.

```javascript
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
```

上面代码中,`setTimeout`的参数是一个箭头函数,这个箭头函数的定义生效是在`foo`函数生成时,而它的真正执行要等到 100 毫秒后.

如果是普通函数,执行时`this`应该指向全局对象`window`,这时应该输出`21`.

但是箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`）,所以输出的是`42`.

### 嵌套的箭头函数

箭头函数内部,还可以再使用箭头函数.下面是一个 ES5 语法的多重嵌套函数.

```javascript
function insert(value) {
  return {into: function (array) {
    return {after: function (afterValue) {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }};
  }};
}

insert(2).into([1, 3]).after(1); //[1, 2, 3]
```

上面这个函数,可以使用箭头函数改写.

```javascript
let insert = (value) => ({into: (array) => ({after: (afterValue) => {
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
}})});

insert(2).into([1, 3]).after(1); //[1, 2, 3]
```

# 尾调用优化

## 什么是尾调用？

尾调用（Tail Call）是函数式编程的一个重要概念,本身非常简单,一句话就能说清楚,就是指某个函数的最后一步是**调用另一个函数.**

```javascript
function f(x){
  return g(x);
}
```

上面代码中,函数`f`的最后一步是调用函数`g`,这就叫尾调用.

以下三种情况,都不属于尾调用.

```javascript
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
```

上面代码中,情况一是调用函数`g`之后,还有赋值操作,所以不属于尾调用,即使语义完全一样.情况二也属于调用后还有操作,即使写在一行内.情况三等同于下面的代码.

```javascript
function f(x){
  g(x);
  return undefined;
}
```

尾调用不一定出现在函数尾部,只要是最后一步操作即可.

```javascript
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

上面代码中,函数`m`和`n`都属于尾调用,因为它们都是函数`f`的最后一步操作.

## 尾调用优化

### 需要知道的

尾调用之所以与其他调用不同,就在于它的特殊的调用位置.

我们知道,函数调用会在内存形成一个“调用记录”,又称“调用帧”（call frame）,保存调用位置和内部变量等信息.(也就是内存地址空间)

如果在函数`A`的内部,调用函数`B`,那么在`A`的调用帧上方,还会形成一个`B`的调用帧.等到`B`运行结束,将结果返回到`A`,`B`的调用帧才会消失

​	*(即内存地址空间存储的函数b以及其里面的内容会消失,其原因是因为JS引擎存在自动回收垃圾机制,参见<h5 css_js.doc>).*

如果函数`B`内部还调用函数`C`,那就还有一个`C`的调用帧,以此类推.所有的调用帧,就形成一个“调用栈”（call stack）.

尾调用由于是函数的最后一步操作,所以不需要保留外层函数的调用帧,因为调用位置、内部变量等信息都不会再用到了,只要直接用内层函数的调用帧,取代外层函数的调用帧就可以了.

### 什么是尾调用优化

“尾调用优化”（Tail call optimization）,即只保留内层函数的调用帧.

也就是说把一些不必要的代码删除,只留下有必要执行的那个函数.

### 示例

```javascript
    function g(num) {
        return num;
    }
    function f() {

        let m = 1;
        let n = 2;
        return g(m + n);
    }
    console.log(f());

    // 等同于
    function f() {
        return g(3);
    }
    console.log(f());

    // 等同于
    console.log(g(3));
```

- 这样看,似乎很笨,因为每个人都会直接将3传递给g()函数,而不会在外层嵌套一个函数,使用两个变量做加法.

  但是有时候我们就是需要一个函数嵌套到另一个函数,此时尾调用优化就非常有用.

上面代码中,如果函数`g`不是尾调用,函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息.但由于调用`g`之后,函数`f`就结束了,所以执行到最后一步,完全可以删除`f(x)`的调用帧,只保留`g(3)`的调用帧.

这就叫做“尾调用优化”（Tail call optimization）,即只保留内层函数的调用帧.如果所有函数都是尾调用,那么完全可以做到每次执行时,调用帧只有一项,这将大大节省内存.这就是“尾调用优化”的意义.

注意,只有不再用到外层函数的内部变量,内层函数的调用帧才会取代外层函数的调用帧,否则就无法进行“尾调用优化”.

```javascript
function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
```

上面的函数不会进行尾调用优化,因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`.

注意,目前只有 Safari 浏览器支持尾调用优化,Chrome 和 Firefox 都不支持.(不知道什么时候的了)

### 尾递归

参见<ES6,阮一峰>