# 字符的Unicode表示法

- Unicode(统一码,万国码,单一码)是一项标准,Unicode需要被进行编码,常见的将Unicode编码的有:UTF-8, UTF-16,UTF-32.

  而代码点(点代码/码点)也是包含于Unicode的.

ES6加强了对Unicode字符,允许使用 `\uxxxx`的形式表示一个字符,但是这种表现法只限于Unicode码在`\u0000~\uFFFF`之间的字符,超出这个范围的字符则必须使用两个双字节的形式表示.

```js
// 单个字符表示
"\u0061"
// "a"

// 超出范围的字符采用双字节表示
"\uD842\uDFB7"
// "𠮷"
```

如果直接在 `\u`后面跟上超过`0xFFFF`的数值（比如`\u20BB7`）,JavaScript 会理解成`\u20BB+7`.由于`\u20BB`是一个不可打印字符,所以只会显示一个空格,后面跟着一个`7`,如:

```js
"\u20BB7"
// " 7"
```

不过,ES6 对这一点做出了改进,只要将码点放入大括号,就能正确解读该字符:

```javascript
"\u{20BB7}"
// "𠮷"

"\u{41}\u{42}\u{43}"
// "ABC"
```

而且大括号表示法和双字节的UTF-16编码是等价的,即: `'\u{1F680}' === '\uD83D\uDE80'`的值为true.

所以有这种使用Unicode表示法+大括号的形式表示形式之后,JS共有六种方法可以表示一个字符.

```js
'\z' === 'z'  // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

# 字符串的Iterator接口

即字符串的包装对象变成了迭代器对象,实现迭代器协议以及可迭代协议,并且也存在next()方法,且满足一系列条件. *参见:<Generator&Thunk-迭代器和生成器以及协议.md>*

所以现在字符串能使用for...of语句和@@iterator方法.

```js
for(let variable of "yomua") {
    consonle.log(variable); // y o m u a
}
```

# 字符串中使用字符的转义形式

我们在字符串中可以直接使用字符的转义形式,或者直接输入字符,例如: 
"中"的Unicode码点是U+4e2d,则我们可以直接在字符串中使用这个"中"的码点.

```js
console.log('\u4e2d' === '中'); // true
```

不过,JavaScript中有五个字符,不能直接在字符串中使用,需要使用"\"反斜杠进行转义.

1. U+005C：反斜杠（reverse solidus)
2. U+000D：回车（carriage return）
3. U+2028：行分隔符（line separator）
4. U+2029：段分隔符（paragraph separator）
5. U+000A：换行符（line feed）

譬如: 字符串中不能直接包含反斜杠,因为反斜杠代表着转义,以下示例代表将右边的单引号转义,那么这样左边就匹配不到单引号了,所以直接错误.

如果我们想要在字符串中使用反斜杠,只需要在使用另一个反斜杠将这个反斜杠进行转义即可.

```js
console.log('\'); // 编译错误
console.log('\''); // '
console.log('\\');// \
```

# 模板字符串

## 描述

即使用反引号 `` 作为字符串,在反引号中可以添加变量和常规字符串,非常的方便.

```js
// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
```

上面代码中的模板字符串,都是用反引号表示。如果在模板字符串中需要使用反引号,则前面要用反斜杠转义。

```javascript
let greeting = `\`Yo\` World!`; 
```

## 表示多行字符串

如果使用模板字符串表示多行字符串,所有的空格和缩进都会被保留在输出之中,且模板字符串中嵌入变量,需要将变量名写在`${}`之中,大括号内部可以放入任意的 JavaScript 表达式,可以进行运算,以及引用对象属性。

```javascript
let x = 1;
let y = 2;

`${x} + ${y} = ${x + y}`
// "1 + 2 = 3"

`${x} + ${y * 2} = ${x + y * 2}`
// "1 + 4 = 5"

let obj = {x: 1, y: 2};
`${obj.x + obj.y}`
// "3"
```

## 模板字符串中调用函数

模板字符串之中还能调用函数。

```javascript
function fn() {
  return "Hello World";
}

`foo ${fn()} bar`
// foo Hello World bar
```

## 大括号中的内容不是字符串

如果大括号中的值不是字符串,将按照一般的规则转为字符串。比如,大括号中是一个对象,将默认调用对象的`toString`方法。

如果模板字符串中的变量没有声明,将报错。

```javascript
// 变量place没有声明
let msg = `Hello, ${place}`;// 报错

```

由于模板字符串的大括号内部,就是执行 JavaScript 代码,因此如果大括号内部是一个字符串,将会原样输出。

```javascript
`Hello ${'World'}`
// "Hello World"
```

## 嵌套的模板字符串

```javascript
const tmpl = addrs => `
  <table>
  ${addrs.map(addr => `
    <tr><td>${addr.first}</td></tr>
    <tr><td>${addr.last}</td></tr>
  `).join('')}
  </table>
`;
```

## 可以将模板字符串写成函数

如果需要引用模板字符串本身,在需要时执行,可以写成函数。板字符串写成了一个函数的返回值。

执行这个函数,就相当于执行这个模板字符串了。

```javascript
let func = (name) => `Hello ${name}!`;
func('Jack') // "Hello Jack!"
```

# 标签模板tagged template

## 描述

标签模板其实不是模板,而是函数调用的一种特殊形式。“标签”指的就是函数,紧跟在后面的模板字符串就是它的参数,

该函数将被调用来处理这个模板字符串.

```js
alert`123`
// 等同于
alert(123)
```

且若使用标签模板,则向函数传参时,JS引擎会去解析这个模板字符串,从而让这个模板字符串参数和普通的调用函数传参的效果迥然不同.

## 标签模板的解析(定义)

即: 调用此模板字符串的函数一定会接收到一个数组,这个数组中存放的是所有普通字符串.

也就是说该模板字符串中的所有**普通字符串会被"打包"成一个数组a传入函数参数中,且该数组的索引个数一定>=变量的个数+1(否则索引上补空值)**,这个数组a中存放模板字符串中的普通字符串和一个raw属性.

​	这个raw属性指向的是另一个数组n(即它的内存地址空间中有个数组),该数组b中的值和数组a中的值完全一致,两者唯一的区别在于:

​	raw属性指向的数组b存放的是被转义过后的模板字符串中的字符串,即若模板字符串中存在"\n"则,raw属性指向的数组b中会将"\n"认为是两个字符: `\\` 和`"n"`,而在数组a中会被认为是换行符,

之所以会存在一个这样的raw属性,是为了方便取得模板字符串中的字符串还未被转义之前的原始模板而设计的,因为如果 "\n"被转移了,那么就成为了换行符,而我们根本就不知晓模板字符中曾经有过"\n"这个数据.

而如果模板字符串**除了普通字符串还存在变量 `${}`,则这些变量会先被计算,将得到的值传入调用它的函数的参数中.**

不过**首先传入的是数组a,**即首先传入将所有普通字符串打包的一个数组,然后**再依次传入变量被计算过后得到的值**.

所以如果一个函数只有一个形参,在不使用剩余参数的前提下,该形参只能接收到一个数组(数组中存在raw属性)

## 示例

### 如果字符串模板中是纯普通字符串,没有任何变量

```js
    function tag(...arg) {
        return arg;
    }
    console.log(tag`22 222 23,213`)    
```

- ***...arg***

  ​    首先该tag函数中的参数是一个剩余参数,所以arg是一个数组,且存放了展开语法展开完指定数据结构的值,

  ​     所以arg现在存放的是一个数组a: `[ ["22 222 23,213", raw: Array(1)] ]`

  *PS:如果不是展开语法,则只会存在:  `["22 222 23,213", raw: Array(1)]`*

  ​	在该数组中的索引0位置上存放的是另一个数组,该数组b中存放模板字符串中的非变量的字符串

  > ​	对于只存在普通字符串的模板字符串来说,函数的参数只会接收到一个存放所有普通字符串的数组.
  >
  > ​    该数组只有一个索引0以及每个数组b都有的raw属性; 
  >
  > ​	而如果是字符串+变量,或者只存在变量的模板字符串,则函数接收到的形参又会是什么情况呢?请往下看)

  ​	由于arg存放的是被展开过后的数据的值且本身又是一个数组,所以arg现在为:  `[ ["22 222 23,213"] ]`

  ​	数组嵌套数组.

### 字符串模板中只存在变量,不存在普通字符串

```js
    let a = 5;
    function tag(arg, v1, v2, v3, v4) {
        console.log(arg, v1, v2, v3, v4)
    }
    tag`${a}${a + 1}${a + 2}${a + 3}`;
```

其输出结果为: ` ["", "", "", "", ""] , 5  7  7  8`

我想你们也注意到了,普通字符串会和变量${..}区分开来,

存放普通字符串的数组的索引个数一定是变量的个数+1,即数组中存放的普通字符串的个数一定多于变量`${..}`的个数,

如果源模板字符串中的数量加起来不够多余`变量+1`,则数组将会被强制补充""空字符串(不是一个空格字符)到索引的最后,所以才会输出以上的结果

​	*(你们现在不妨想想,如果普通字符串中存在变量,然后变量后面又存在普通字符串,那么打包所有普通字符串的数组的索引中的每个值又会是什么样呢?请往下看).* 

而变量则会被放到放到最后传进函数的参数中,按照模板字符串中从左→右的顺序依次放入索引中.

### 模板字符串中既有变量又有普通字符串.

```javascript
let a = 5;
let b = 10;
function tag(arg, v1, v2, v3, v4) {
	console.log(arg, v1, v2)
}
tag`Hello ${ a + b } World ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
```

输出结果为: `["Hello ", " World ", ""] 15, 50`

如果模板字符串中既有变量又有普通字符串,则依然是向我们前面所说的那样,还是会先将模板字符串中的所有普通字符串依次整合成一个数组传入到函数参数中,再将变量计算过后的值传入函数参数中.

如果你细心的话,你应该发现了,存放所有普通字符串的数组中,有个空字符串"",这是因为我们前文提到过的,整合普通字符串形成的一个数组,其索引个数一定**大于或等于**变量的个数+1.

### 总结

所以根据以上的示例,我们其实可以得出一个结论: 

函数使用模板字符串作为参数时,**函数会首先接收到一个数组,**这个数组存放的是:

​	模板字符串中所有普通的字符串,且该数组的索引个数永远大于或等于模板字符串中的变量个数+1,不够则强制在后面的索引位置上使用""空字符,如果多出或刚好则一切照旧.

​	且**当模板字符串的普通字符串在被整合成数组的一个个索引时,是以变量分割的**,即每遇到一个变量,就会形成一个索引,如

​	`yomua${var}yhw(${var2})`,其整合出来的普通字符串数组为: 

​		**["yomua",   "yhw(",    ")" ]**

然后其余被计算过后的值的变量也会依次被传入函数的参数中.且这里的普通字符出已经等于变量的个数+1,所以 yomua和yhw之间并没有空的索引值.

我想你们应该注意到了,函数先处理的是数组,**再处理计算出来的值的变量**.

## 作用

### 过滤HTML字符串

"标签模板"的一个重要作用就是:过滤HTML字符串,防止用户输入恶意内容.

```js
    let sender = prompt('输入:')
    let message =
        SaferHTML`<p>${sender} has sent you a message.</p>`;

    function SaferHTML(templateData) {
        // templateData:包含所有普通字符串的数组
        let s = templateData[0];
        // arguments:函数所接受的所有实参(不管有没有对应的形参)
        for (let i = 1; i < arguments.length; i++) {
            let arg = String(arguments[i]);

            // 请在替换中转义特殊字符。
            s += arg.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            // 不要在模板中转义特殊字符
            s += templateData[i];
        }
        return s;
    }
    console.log(message);
/**
	当用户输入: <yomua>&时,输出:
	<p>&lt;yomua&amp;&gt; has sent you a message.</p>
*/
```

- ​    使用标签模板作为函数参数,让函数只接受一个参数,即普通字符串整合成的数组,

  ​	*(因为使用模板字符串作为函数参数时,函数先接收到参数首先为普通字符串整合成的数组)*

  ​	然后再内部使用arguments对象进行遍历所有实参,不论有没有对应的形参,这样,我们就实现了我们自定义的普通字符串和变量的分离.

  ​    这样我们就可以很好的对变量进行操作,即:每当用户输入的字符串中存在&,<>时,我们就使用replace()方法直接将用户输入的字符串中的所有这些不合格的字符,用字符实体(或其他方式)的方式替换掉

### 多语言转换

标签模板的另一个应用,就是多语言转换（国际化处理）

```javascript
i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`
// "欢迎访问xxx,您是第xxxx位访问者！"
/*
	i18n
*/
```

- i18n: inter nationalization,国际化

  可以使用  vue-i18n切换中英文.

### 使用标签模板,在 JavaScript 语言之中嵌入其他语言

```js
jsx`
  <div>
    <input
      ref='input'
      onChange='${this.handleChange}'
      defaultValue='${this.state.value}' />
      ${this.state.value}
   </div>
`
```

上面的代码通过`jsx`函数,将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到`jsx`函数的[具体实现](https://gist.github.com/lygaret/a68220defa69174bdec5)。

## 模板字符串的限制

前面提到标签模板里面,可以内嵌其他语言。但是,模板字符串默认会将字符串转义,导致无法嵌入其他语言。

举例来说,标签模板里面可以嵌入 LaTEX 语言。

```javascript
function latex(strings) {
  // ...
}

let document = latex`
\newcommand{\fun}{\textbf{Fun!}}  // 正常工作
\newcommand{\unicode}{\textbf{Unicode!}} // 报错
\newcommand{\xerxes}{\textbf{King!}} // 报错

Breve over the h goes \u{h}ere // 报错
`
```

上面代码中,变量`document`内嵌的模板字符串,对于 LaTEX 语言来说完全是合法的,但是 JavaScript 引擎会报错。原因就在于字符串的转义。

模板字符串会将`\u00FF`和`\u{42}`当作 Unicode 字符进行转义,所以`\unicode`解析时报错；而`\x56`会被当作十六进制字符串转义,所以`\xerxes`会报错。也就是说,`\u`和`\x`在 LaTEX 里面有特殊含义,但是 JavaScript 将它们转义了。

为了解决这个问题,ES2018 [放松](https://tc39.github.io/proposal-template-literal-revision/)了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义,就返回`undefined`,而不是报错,并且从`raw`属性上面可以得到原始字符串。

```javascript
function tag(strs) {
  strs[0] === undefined
  strs.raw[0] === "\\unicode and \\u{55}";
}
tag`\unicode and \u{55}`
```

上面代码中,模板字符串原本是应该报错的,但是由于放松了对字符串转义的限制,所以不报错了,JavaScript 引擎将第一个字符设置为`undefined`,但是`raw`属性依然可以得到原始字符串,因此`tag`函数还是可以对原字符串进行处理。

注意,这种对字符串转义的放松,只在标签模板解析字符串时生效,不是标签模板的场合,依然会报错。

```javascript
let bad = `bad escape sequence: \unicode`; // 报错
```