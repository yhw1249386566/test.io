# 必看

PS: 这篇文章所有指的可迭代对象或者说迭代器对象其实都是一种数据结构,

ES6又规定:只要存在Iterator接口的数据接口,那么我们此数据结构就是可迭代的.

又由于ES6还规定默认的Iterator接口部署在Symbol.Iterator属性上,所以一个数据结构只要存在Symbol.Iterator属性,那么同样是可迭代的.

- **数据结构,即数据的构成方法,或者说组合数据的方式.例如对象,数组,字符串等它们都属于数据结构.**

所以这里我们说对象是可迭代的是不完整的,应该说是数据解构是可迭代的,但是由于这个[必看]是后面补上的,所以我们没再修改以下的章节的说法,

**但你们依然要知道这个道理: 即以下的什么迭代器对象/可迭代对象/生成器对象,其实都可以认为是一种数据结构,只不过我们为了更为的详细,就将之区分开来.**

即使你们没看到这段话也不要紧,因为以下的说法其实也并没有什么毛病,那都是MDN文档上看过来并理解的.

# 可迭代协议

## 描述

可迭代协议允许JavaScript对象去定义或定制它们自己的迭代行为,例如:定义在一个[`for..of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)结构的可迭代对象,此对象能可以让自己什么能获取到什么值,什么值又无法被得到.

​	*不像普通的那种 for 循环遍历数组,只能被迫的接收for循环规定的迭代行为,即一次迭代一个索引,并且每个索引都会被迭代*

有一些内置类型是内置的可迭类型并且有默认的迭代行为,比如:Array,Map,而**另一些类型则没有内置的可迭代类型和默认的迭代行为,比如:Object.**

- 内置类型:是指任何语言在设计初期定义的类型，

  ​	JS中的内置类型有number,string,boolean,array,map等,而内置是什么意思?就是不需要开发人员声明也能使用的类型,

  ​	推而广之,内置对象也是这个意思:即开发人员不需要特别声明,也能使用内置的对象.例如:Math就是一个内置对象,否则我们为什么可以直接使用四则运算?使用四则运算之前创建Math对象了吗?没有!

而想要成为一个可迭代的对象,那么就必须遵守可迭代协议,即**这个对象或者原型链上)必须实现@@iterator方法,(由JS保证默认实现了@@iterator方法)**

**同时必须存在Symbol.iterator属性(保证开发者能自定义实现@@iterator方法,这行为符合可迭代协议:允许JavaScript对象去定义或定制它们自己的迭代行为),**

实现@@iterator方法 的两种方式,第一种通常是开发者自定义实现,第二种通常是JS的默认实现.

PS:可以用开发者自定义的@@iterator方法覆盖第二种的JS的默认实现

```js
@@iterator方法 就等于:
// 这样的形式通常是自定义实现的@@iterator,即自定义可迭代对象的行为.
	xxx[Symbol.iterator] = function(){..}
同时等于:
//可迭代对象的默认实现的@@iterator
	xxx[Symbol.iterator](){...}; 
//xxx:拥有Symbol.iterator属性的对象,即是下了可迭代协议的对象.
```

我们将在以下的Symbol.iterator详细的讲解Symbol.iterator属性方法与它的返回值

## Symbol.iterator 

### 返回值

当需要对一个对象进行迭代时,我们可以使用它的@@iterator方法(即`[Symbol.iterator]()`),此方法可以在不传入参数情况调用,还会返回一**个新的迭代器对象,此迭代器是用来获取迭代的对象的值.**

> 自定义的实现了Symbol.iterator属性的方法不一定要返回一个迭代器对象,一个普通的对象也行,甚至什么都不返回,只有单纯的一个alert()语句都是可以的.
>
> ​	 默认的实现了Symbol.iterator属性的@@iterator方法返回的必定是一个迭代器对象
>
> 因为实现了可迭代协议的对象不一定实现迭代器协议,所以我们可以任意的往@@iterator函数中任意添加各种符合语法的代码都行.
>
> 不过我还是要忠告一句:很少看到只实现了这两个协议中的一个的对象,建议两者都实现.
>
> 而且返回一个迭代器对象也是非常好的,否则该方法的意义近乎为无,因为调用此方法,就说明有对象要被迭代,那没有迭代器对象,怎么迭代?

​	也就是说,使用该方法并不用传入参数,**且该方法return(返回)的值是一个对象,此对象属于迭代器对象,即同时实现了可迭代协议和迭代器协议的对象,**

​	因此该对象可以使用next()函数

​	*(next()函数也返回一个对象,不过是一个common对象,但是此对象一定存在done和value属性,用来获取当前正被迭代的对象的值的,详情看:迭代器协议 - next())*

而Symbol.iterator虽然说是一个属性,但是它里面可以存一个方法. 即如同: `obj.func = function(){...}`这样形式存储.

所以我们可以使用该属性自定义一个可迭代对象的迭代行为.

同时若我们使用`typeof  variable[Symbol.iterator]` 时,返回的类型会是function类型**,因为JS已经默认实现了Symbol.iterator属性,即将该属性变成一个函数**: `ƒ [Symbol.iterator]() { [native code] }`

因为若像这样输出输出`console.log(variable[Symbol.iterator])`,则会得到一个函数形式的代码:

```js
ƒ [Symbol.iterator]() { [native code] }
// native code,即可迭代对象默认实现的行为.
```

### 一些内置类型使用@@iterator的用法

#### 描述

即@@iterator方法如何使用于内置类型(不需要开发者明确声明,就能使用的类型).其中有@@iterator方法的内置类型,如下:

- [`Array.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator)
- [`TypedArray.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/@@iterator)
- [`String.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator)
- [`Map.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator)
- [`Set.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/@@iterator)



## 示例

#### `String.prototype[@@iterator]()`

我们从以上的 *Symbol.iterator-描述* 中随便找出一个[`String.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator)来讲解如何使用@@iterator方法,即使用 `[Symbol.iterator]()`.

##### `String.prototype[@@iterator]()`

@@iterator方法在前文我们讲过是一个对象要成一个迭代器对象必须有的方法,即这个对象必须存在Symbol.iterator属性.

现在,我们现在准备讲的,内置类型String如何使用@@iterator方法的.

```js
const str = 'Yomua is my baby';

let iterator = str[Symbol.iterator]();
let theChar = iterator.next();

while(!theChar.done && theChar.value !== ' ') {
  console.log(theChar.value);
  theChar = iterator.next();
  // expected output: "Y"
  //                  "o"  
  //                  "m"
  //				  "u"
  //				  "a"
}  

```

**代码解析**

- `let iterator = str[Symbol.iterator]();`

  这行代码的意思为:

  ​	若变量str实现了@@iterator方法且存在Symbol.iterator属性,那么在我们使用@@iterator方法时(即使用`[Symbol.iterator]()`方法),	该方法会返回一个新的迭代器对象,并且此迭代器对象会遍历调用@@iterator方法的对象的值的代码点,

  ​	即遍历变量str值的一个个代码点,然后返回每一个代码点的值.

  - 代码点:其实也可以说是字符串上的每个字符,从第一个字符串开始遍历,直到结尾.

  

  ​	最后将此迭代器对象赋值给iterator变量.
  
-   `theChar = iterator.next();`

  ​    这步也非常的关键,为什么这么说呢?如果没有这一步,那么while循环就会变成无限循环.因为永远存在下一序列的值且永远不为" ".

  ​	这是因为若没有这行代码,则代表我们一直在重复遍历整个变量str,也就是在这个循环中,下一个值永远是变量str的第一个字符,因为第二个字符取不到.

  ​	因为此时在没有这行代码时,对于while的循环条件来说,它们永远是基于整个变量str的值,也就是说,每一次循环判断条件,都是从变量str的第一个字符串开始遍历.

  ​	所以才会导致永远循环下去. 

  ​	但是若存在此行代码,那么就会在循环的过程中执行此代码,将变量str的下一个值赋值给变量theChar,而while循环的条件也和theChar变量有关,即theChar.done 和 theChar.value两个属性.

  ​	这就代表着在循环内部我就能取到变量str的下一个done和value属性,即也就是能取到下一个字符,比如说:得到第一个字符串完成后,就可以改变theChar变量指向的内容.

  ​	*例如: 现在遍历的是第一个字符,然后输出完第一个字符,就在循环内部获取第一个字符的下一个字符并赋值给theChar变量,*

  ​	*这样循环条件也就变了,即第二个字符的下一个字符串是否存在,是否为" ",然后执行里面的代码或者不执行.*

  

  ​	*然后输出第二个字符,将第二个字符的下一个字符再继续赋值给theChar变量,这样循环条件又变了,*

  ​	*即第第三个字符的下一个字符是否存在,是否为" ", 以此类推,直到条件为false..*

### string[Symbol.iterator] 

```js
let someString = "hi";
typeof someString[Symbol.iterator]; // function  
// ƒ [Symbol.iterator]() { [native code] }
console.log(someString[Symbol.iterator]);
```

如果只是用 string[Symbol.iterator] 这样的形式,即如同只使用一个函数的名字,不用(),它代表返回一整个函数代码块,而不是函数返回值,所以它会输出: 

​	`ƒ [Symbol.iterator]() { [native code] }`

# 迭代器协议

## 描述

迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值,并且当所有的值都已经被迭代后,就会返回一个默认的值.

当一个对象只有满足下述条件才会被认为是一个迭代器,即某个对象实现了 `next()`方法且此方法具有以下next()一节中的含义.

有意思的是,一些内置的语法结构,内部同样也实现了迭代器协议和可迭代协议,例如**展开语法**,请看示例.

## next()

### 描述

该方法会返回且必须返回一个对象,而且此对象必须存在done和value属性,如果返回了一个非对象值(即返回的值的返回类型不是object,例如false和undefined),那么就会在运行时报错: TypeError.

且我们可以向iterator.next()方法传递参数,此参数将会赋值给生成器函数内部, 当前yield/return语句的**上一条yield语句左边的变量** *（或者说，因为哪条 yieled/return 语句，从而导致 iterator.next(参数) 方法被执行，那么哪条语句左边的变量值就会被 【参数】 赋值）*,若上一条yield语句不存在此变量,那么x就等于undefined,则yield x就等于yield undefined. ***详见: 生成器(对象) -yield和yield\* - yield -yield示例.***

### 返回值

 返回一个对象,被返回的对象存在两个属性:

​	**done (是一个boolean值)**

​		如果该值为true: 则代表迭代器已经超过了可迭代次数. 在这种情况下,value的值可被省略.

​		如果该值为false:则代表迭代器可以生成序列中的下一值,即若进行下一次迭代时,别迭代的对象还存在值.这就相当于没有指定done这个属性.

​	**value**

​		迭代器在迭代过程中返回的任何JavaScript值.当done属性为true则可以省略该值.

## 示例

先使用可迭代对象实现的@@iterator方法,再使用迭代器对象的next()方法,这样可以获取一个字符串或数组的所有可枚举的值,

并且next()会返回一个对象,此对象必存在done和value属性,done即布尔值,value即迭代的任何JS值.

```js
    let someString = 'hi';
    let arr = ['hi',2,1];
	// 返回一个迭代器对象
    let v = arr/someString [Symbol.iterator]();
    console.log(v.next())
    console.log(v.next())
    console.log(v.next())
/*
someString:
	{value: "h", done: false}
	{value: "i", done: false}
	{value: undefined, done: true}
	
arr:
	{value: "hi", done: false}
	{value: 2, done: false}
	{value: 1, done: true}
*/
```

请注意someString中有一行结果为undefined,且done为true,则是因为在第二次迭代过程中,someString变量不存在下一个序列值,所以获取不到value,即undefined.

且我们在 *描述* 中说过,展开语法其实也实现了可迭代协议和迭代器协议,因为使用展开语法也能将someString和arr迭代.

```js
    let someString = 'hi';
    let arr = ['hi',2,1];
	console.log(...someString); // h i
	console.log(...arr); // hi 2 1
```

但是请注意: @@iterator方法和next()方法无法用于字面量对象,即:

```js
    let obj = {name:'yomua', sex:"boy"};
    let v = obj[Symbol.iterator]();
/*
Uncaught TypeError: obj[Symbol.iterator] is not a function
*/
```

使用@@iterator方法迭代一个字面量对象是错误的行为,原因是:Object对象不存在iterator接口,所以它没有@@iterator方法,也没有Symbol.iterator属性.

即对象并不是一个可迭代对象和迭代器对象. 既然使用@@iterator方法无法迭代一个对象,那么同样,展开语法也是无法展开一个对象变量的.

```js
	console.log(...obj);
// Uncaught TypeError: Found non-callable @@iterator
```

即当我们试图展开一个对象变量时,就会报错:发现不可回调的@@iterator方法,也就是对象不能被展开,没有@@iterator方法.

注意:**因为Object对象没有实现可迭代协议和迭代器协议,而展开语法实际上是基于可迭代协和迭代器协议实现的一种语法,所以就会报错.**

​	也因此,for...of也无法遍历字面量对象,准确来说,这是因为Object对象没有实现iterator接口,但是String,Array这些内置对象实现了..

​	有意思..

但是展开语法还是有诸多用处的,例如:解构赋值等.

# 可迭代协议和迭代器协议

## 总结

即实现了@@iterator方法的对象是可迭代对象,也就是存在Symbol.iterator属性方法.

当调用JS默认实现的@@iterator方法时将会return(返回)一个对象,该对象实现了迭代器协议,所以该返回对象也叫做迭代器对象.

​	*自定义的@@iterator方法不一定返回和一个对象,详情请看Symbol.iterator .*

因此该迭代器对象必能使用next()方法.同时next()方法返回的是一个common对象(只是单纯的对象),且此对象必须存在done属性和value属性,而这两个属性致使这个common对象能获取当前调用@@iterator方法的对象的值.

所以我们使用@@iterator方法,就能获取当前正在使用@@iterator方法的对象的值.

## 描述

可迭代协议和迭代器协议并不是一体的,它们是两个独立的个体. 即一个对象能满足可迭代协议,但是这并不代表这个对象一定能满足迭代器协议.

我们不可能知道一个特定的对象是否实现了迭代器协议,除非你用可迭代协议/迭代器协议测试此对象是否为迭代器对象/可迭代对象,这样就能判断它们是否实现了两个协议.

虽然无法知道一个特定的对象是否实现了迭代器协议,然而创造一个同时满足迭代器协议和可迭代协议的对象是很容易的.(请看以下示例)

请注意:很少有实现了迭代器协议而不实现可迭代协议的对象.

```js
var myIterator = {
    next: function() {
        // ...
    },
    [Symbol.iterator]: function() { return this }
}
```

该示例同时实现了可迭代协议和迭代器协议,这样做的好处在于:

​	允许一个迭代器对象能被不同希望迭代的语法方式所使用,也就是防止因为只存在一个协议而导致刚好没有的协议想要迭代对象,从而造成此对象无法被迭代的情况,

# 改变存在@@iterator方法的内置对象的默认迭代行为

## 描述

即使用可迭代协议实现改变可迭代对象的默认迭代行为,也就是改变@@iterator方法,用的语法格式应该为:

`xxx[Symbol.iterator] = fucntion() { ...do something}`

这里我们使用JS的内置的可迭代对象作为示例,即使用字符串对象作为示例,改变字符串对象的默认迭代行为.

## 示例

### 存在_init:ture

```js
    let str = new String('yomua');

    str[Symbol.iterator] = function () {
        return {
            next: function () {
                let strObjValue = ""
                // 此判断语句只会执行一次
                if (this._init) {
                    this._init = false
                    // 获取字符串对象的所有字符,以空格分开
                    for (let i = 0; i< str.length; i++) {
                        strObjValue += `${str[i]} `;
                    }
                    // next()函数必须返回的common对象
                    return {
                        value: strObjValue,
                        done: false 
                    }
                } else {
                    return { done: true }
                }
            },
            _init: true
        }
    }
    console.log(...str); // y o m u a
```

**代码解析**

- ***str[Symbol.iterator] = function () {}***

  ​    自定义可迭代对象的迭代行为

- ***return {}***  上面代码行的return

  ​	@@iterator方法**~~必须~~返回一个迭代器对象**,用来获取调用@@iterator方法的序列值,

  ​		*不一定要返回一个迭代器对象,一个普通的对象也行,甚至什么都不返回,只有单纯的一个alert()语句都是可以的.*

  ​		*因为实现了可迭代协议的对象不一定实现迭代器协议,所以我们可以任意的往@@iterator函数中任意添加各种符合语法的代码都行.*

  ​		*不过我还是要忠告一句:很少见只实现了这两个协议中的一个的对象,建议两者都实现.*

  ​	所以这里我们使用return {},即返回一个对象,但是由于此对象是迭代器对象,

  ​	所以该对象**必须存在next()方法**,因为只有实现了此方法,同时该方法还需要实现特定的含义,那么我们才能说这个对象时迭代器对象.

  ​	不过又由于这是对象的形式,所以我们只能以 name:function(){...}的形式写next()方法.

- ***next: function () { }***
      next()方法**必须返回一个对象**(一个普通的对象就行了),所以这里我们使用return {};**(返回一个非对象,则会报错)**
      且该普通对象必须有done和value属性, 这两个属性是默认属性.但是我们可以改变它们的值.
      value:用来获取当前迭代的可迭代对象的值
      deone:布尔值,true:可迭代对象不存在下一个序列值,false:可迭代对象存在下一个序列值.

- ***done:false***

  ​    告诉next()方法,当前正迭代的对象下一个序列是存在的且可被迭代,这里如果为true,以展开语法形式使用@@iterator方法将会输出空值

  ​	详情原因请看下面,即 不*添加_init:true的后果*

- ***_init:true***

  ​    加入此属性的目的在于:在开发者使用展开语法对一个可迭代对象进行展开时,能返回其展开的值,

  ​	否则没有此属性以及其关联代码行,那么展开语法将获取不到value值,详情请看: *不添加_init:true的后果*
  
- next:function(){ 

  ​	for (let i = 0; i< str.length; i++) {strObjValue += ${str[i]};}

  ​	return { value: strObjValue,  done: false }

  }

  我这种方法愚蠢的地方在于: 若使用:

  `str[ Symbol.iterator]().next()`,直接回获取所有的字符串对象的值,而不是单个对象中的单个值,即:{value: "y o m u a ", done: false}

  而若我们不使用以上的自定义迭代器,其结果会返回:{value: "y", done: false}.

  究其原因,在于: 我是**使用了for循环直接执行一次next就可以获取到字符串对象的所有的值**.

  不过这目的也正好告诉你们: 我们真的可以自定义一个迭代器方法!

  

  ​	

### 不添加_init:true的后果

```js
next: function () {
	// next()函数必须返回的common对象.
	return {
		value: str,
		done: true
	}
 }
```
这是最初的next方法版本,不存在_init属性,可以被 `str[Symbol.iterator]().next()`方法获取到 value值,但是使用展开语法`...str`将获取不到任何值.

​    `str[Symbol.iterator]().next()`能获取到value值是因为:

​		它强制调用next()函数,并获取其返回值,即获取到了一个common对象{value: String, done: true}.注意:value的值String仍然为一个对象.

​    `...str`获取不到是因为:

​		展开语法虽然也会调用next()方法,但是展开语法可没有返回值,它展开的是调用@@iterator方法所返回的迭代器对象的next()方法的返回对象的value值,**也就是说展开语法会自动获取其value值.**

​		不像`str[Symbol.iterator]().next(); `这样的形式调用还需要再继续调用`.value`属性,才能获取其value属性的值.
​    

​		但是由于我们书写value属性所在的对象时,也写了done属性的值为true,这代表下一个值不可被迭代,即不存在下一个值.

​		那么当然,展开语法就获取不到value值,因为不存在怎么获取到.

​    	这时候有人可能会有疑惑,为什么我是先写value属性再写done属性的,却不能获取到value属性的值呢?

​		这是因为,这两个属性都处于一个对象中,这也就代表执行这个对象时虽然程序会先执行value属性再执行done属性;

​		但是,程序需要将整个对象中的代码(即属性)都执行完之后,才会开始进行其他的操作,而不是执行一个属性,然后就执行其他操作了.

​	    所以程序知道value属性存在值的时候,又被done属性告知,下一个值是不存在的,你不要去管了,所以此时对象对于程序来说,里面的属性的value值是不存在的,那么展开语法直接去获取value属性的值,当然是获取到空值,

​		或许有人还会疑惑,value属性的值不是当前正被迭代的值吗?而done属性指的是下一个值,这两个又没有关系,为什么获取不到当前值,这是因为:

​        **next()方法能获取到第一个字符,是因为next()方法最开始是从整个需要被迭代的对象的索引-1开始判断的,**而索引-1根本不存在,所以value值当然也不存在,而又因为done为true,下一个值也不存在,最后的结果当然返回"",即无值.

### 总结

经过以上的添加和不添加_init:true属性以及相关代码行的辨析之后,我想现在诸位肯定都对 @@iterator方法有了更深的理解了.

所以,当我们以后要为一个实现了可迭代协议和迭代器协议的对象定制它的默认迭代行为时,请考虑是否要为它添加更好的方法来获取其被迭代的值.

当然了，以上的示例并不一定要这么写,存在着多种实现对象自定义的迭代行为的方式. 例如不用一开始直接return,而是先写一段代码,里面存在对象,然后这个对象有着相关操作,最后return这个对象即可.

# 迭代器(对象)

## 描述

在迭代器协议一节中,我们也说过,如果一个对象实现了迭代器协议,那么这个对象就可以称之为迭代器对象.

同时我们也知道,迭代器协议定义了一种标准来产生有限/无限序列的值,然后当所有的值都被迭代后,最后再返回一个默认值.

当然了,设置一个无线序列的值是没有任何意义的,因为它可能会迭代无限次,陷入死循环,不过倒是可以将无限Infinity这个关键字作为一个默认的值,

因为我们并不知道传进的需要被迭代的东西(数组,对象,参数等)要被迭代多少次,所以这才是产生无限序列的值的意义所在

以下示例为一个简单的范围迭代器,即由调用者指定其开始和结束以及步长(每次要累加的数字,用来控制是否继续迭代)

## 示例

一个简单的范围迭代器,由调用者传入参数并指定其开始和结束以及步长

```js
    // 开始,结束,步长,实参===undefined,才使用默认值.
    function rangeIterator(start = 0, end = Infinity, step = 1) {
        let count = 0; // 计算循环几次
        // 需要被返回的迭代器对象
        const iteraotorObj = {
            // next()方法返回一个common对象,该返回对象存在value和done属性.
            next: function () {
                let result;
                if (start <= end) {
                    result = { value: start, done: false }; // result的目的是为了让第一个循环的值能被计算到.
                    start += step; // 循环第一次结束之后,第二次循环需要加上步长,默认为1.
                    count++;
                    return result;
                }
                return {
                    // 计算循环结束之后的值并赋值给value.
                    value: count, 
                    done: true
                };
            }
        };
        // 迭代器对象
        return iteraotorObj;
    }
    let iteObj = rangeIterator(1, 10, 1);
    let result = iteObj.next();
    while (!result.done) {
        document.write(`${result.value} `);
        result = iteObj.next(); // 让result变成下一个将会迭代的对象,防止永远只迭代第一个值.
    }
	// 上面已经将最后一次next()方法会返回的对象给了result,所以此时的result对象存入的是最后一个值的value和done属性.
	console.log(result.value); // 迭代总次数: 10
/*
	输出结果为: 1 2 3 4 5 6 7 8 9 10
*/
```

# 生成器(对象)

生成器:Generator

## 描述

要想明白什么是生成器,那么就必须先了解以下下概念.

生成器对象是一个函数的返回值,它是一个生成器函数所返回的一个对象,并且此生成器对象符合可迭代协议和迭代器协议,

即它实现了@@iterator方法和存在Symbol.iterator属性,并且同时也存在next()方法.

## 生成器函数

### 语法

`function* name([param1,...,paramN]) {do something};`

- function* : 是定义生成器函数所必需的关键字,*很关键
- name: 函数名
- do somethis: 普通的JS代码．

### 描述

funtion* 这样的写法会定义一个生成器函数:Generator Function,该**函数返回一个[Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)对象**,即生成器对象.

该函数在执行过程中可以通过代码方式让之被暂停,又可以在暂停处继续执行.

当我们调用一个生成器函数时,它里面的代码并不会被马上执行,而是会先返回一个生成器的迭代器对象.只有当这个生成器(迭代器)对象的next()方法被首次执行后(即被显式的调用后),

​	*PS: 其实我们可以将这个迭代器对象直接认为是生成器对象,即生成器函数返回的生成器对象,它具有迭代器和可迭代对象的共同行为.*

那么它里面的代码才会开始被执行,执行到首次出现yield关键字(执行完当前语句后)就会停止,[`yield`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield) 关键字后面会紧跟一个表达式,注：此表达式计算后值是生成器(迭代器)对象的 next方法返回的common对象的value属性的值.

如果首次出现的不是yield,而是yield*,那么表示将当前生成器函数的执行权移交给另一个生成器函数或一个可迭代对象,当前生成器函数将会暂停执行.

如果yield和yield*关键字都不出现,那么此时的生成器函数和普通函数没什么区别,会直接运行到函数结束.

**简单来说就是:** 一个生成器函被调用时,首先会返回一个生成器对象,只要当被返回的生成器对象的**next()方法被执行时**,那么该生成器函数**内部的代码才会被执行（直到下一条 yield/return 语句，或直接执行完毕）**,**否则**生成器函数内部代码将**不会被执行**.

而这里的生成器对象的next()方法也是必须存在的,且也仍然返回一个common对象,并且此common对象存在value和done属性的,但是和普通的value,done属性有所区别,即:

- **value属性的值**:

  ​	是生成器函数内部使用yield关键字,它后面所跟的表达式的值,即 `yield expression;`

- **done属性的值**: 意思近乎没改变,仍然是一个布尔值.

  ​	为true时表示迭代器无法生成序列中的下一个value,即迭代器已经超过可被迭代的序列的末尾.

  ​	为false时则表示迭代器能生成下一个序列的值,依然相当于没有指定done.

### 功能

生成器函数Generator Function 是ES6中提供的一种异步编程解决方案,语法行为和传统函数完全不同.

它不同于自定义的迭代器,即 可迭代对象[Symbol.iterator] = function(){..}; 因为自定义的迭代器需要显示地维护其内部状态,因此我们需要谨慎的创建迭代器方法.

而生成器函数提供了一个强大的选则: 它允许我们定义一个自己包含有迭代算法的函数,同时该函数可以自动维护自己的状态.

而该函数名字叫: 生成器函数: Generator Funtion.使用Function*书写.

我们可以根据需要而多次的调用生成器函数,并且若每次都调用生成器函数,那么都会返回一个Generator对象, 

但是我们可以选择只使用一个Generator对象多次调用next()方法,也同样可以将生成器函数执行多次,当然前提是yield是足够多的情况,否则调用一次next(),生成器函数就被执行完了.

## yield和yield*

### yield

#### 描述

yield关键字用来暂停和恢复一个生成器函数(即function* 或 [遗留的生成器函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/Legacy_generator_function))

yield关键字后面紧跟的表达式的值将返回给生成器的调用者,它可以被认为是一个基于生成器版本的return关键字.

yield关键字实际上返回一个IteratorResult对象,即迭代结果对象,此对象存在两个属性:

value属性: value属性是yield后面的表达式求值的结果

done属性: 是true或false,false则代表生成器函数尚未执行完成,true则代表执行完成。

一旦遇到yield代码行,生成器函数的代码将会被暂停执行,直到生成器的next()方法被调用.每次调用生成器的`next()`方法时，生成器都会恢复执行，直到达到以下某个值：

- `yield`，导致生成器再次暂停并返回生成器的新值。 下一次调用`next()`时，在`yield`之后紧接着的语句继续执行。

- [`throw`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/throw)用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。

- 到达生成器函数的结尾；在这种情况下，生成器的执行结束，并且`IteratorResult`给调用者返回[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)并且`done`为`true`。

- 到达[`return`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/return) 语句。在这种情况下，生成器的执行结束，并将`IteratorResult`返回给调用者，其值是由`return`语句指定的，并且`done` 为`true`，也就是说：此时生成器函数具有返回值（return 返回的表达式），否则生成器函数将返回 undefined，详见：***yield示例***。

  ​	和yield语句类似,都是将右边expression传给next()返回的common对象的value属性,只不过它会终止生成器函数的执行.


如果将参数传递给生成器的`next()`方法，则该值将成为生成器当前`yield`操作返回的值,即:next(xxx); (详见:yield示例)

且需要注意的是:不要在一个生成器函数g1()中 yield* g2() ,在g2()又yield* g1(),
这种双方相互调用,是会造成堆栈溢出的!（参见：***<JS并发模型与事件循环-堆-栈-队列-同步异步任务-宏观微任务.md>***）

#### 语法

`[rv] = yield [expression];`

- rv 可选

  此变量返回一个可选值,将此值传递给生成器的next()方法中的value属性,以让生成器函数恢复其执行.

  而rv变量本身是[expression]计算出来的值,然后将这个值传递给next()方法返回的Common对象的value属性(next()返回的Common对象).

- expression 可选

  ​	*可以不用是表达式,可以直接是一个常量,例如1,2,天才,yomua等.*

  ​	定义 通过迭代器协议从生成器函数返回的值,如果省略,则返回undefined.

  ​	也就是说: 此表达式的值将作为返回的迭代器对象的next()方法的返回的Common对象的value属性的值.

  

#### 	yield示例

由于生成器的知识点颇多,所以这里我建议先了解完以上知识后才来看这个示例,此示例包含生成器函数,生成器对象,yield和next()等方法的知识点.

在这里我将会详细的讲解它们之间的关系.

```js
// 生成器函数
    function* generatorFunc() {
        console.log('调用生成器对象的next()方法后我将被执行');
        yield 1;
        console.log('看来你又调用了一此next()方法');
        x = yield 'foo';
        yield x;
        console.log('这是我们最后一次见面了,生成器函数将被执行完毕.')
        return 2;
    }
    let generatorObj = generatorFunc(); 
    let commonObj = generatorObj.next();
	console.log(commonObj)
    console.log(generatorObj.next())
    console.log(generatorObj.next(100));
    console.log(generatorObj.next()); 
	console.log('下一条语句value为undefined')
	console.log(generatorObj.next());
/*
调用生成器对象的next()方法后我将被执行
{value: 1, done: false}

看来你又调用了一此next()方法
{value: "foo", done: false}

{value: 100, done: false}

这是我们最后一次见面了,生成器函数将被执行完毕.
{value: 2, done: true}

下一条语句value为undefined
{value: undefined, done: true}
*/
```

**代码解析**

- ***let generatorObj = generatorFunc();***

  ​    调用生成器函数,会返回一个生成器对象,并将此生成器对象赋值给一个变量.

  ​	由于生成器函数被调用后也无法立即被执行,只会被暂停.

  ​	只有当生成器对象的next()方法被调用后,生成器函数才会从暂停状态到执行状态.

- ***let commonObj = generatorObj.next();***

  ​	*输出的是一个对象,即next()函数的返回值,common对象.*即返回:`{value: 1, done: false}`

  ​    调用生成器对象的next()方法,返回一个普通对象,此对象必有value和done属性,然后将此对象赋值给变量;

  ​    **此时,生成器函数也将开始执行器内部代码.**

  ​	也就是说此代码行可以让生成器函数执行一次,但是若在执行过程中碰到yield/throw/return则会被强制暂停,不过yield/throw/return会被先执行完之后,才会暂停生成器函数.

- ***yield 1;***

  ​	此语句会在***let commonObj = generatorObj.next();***代码行后开始执行,直到整个函数结束或遇到下一个yield/return/throw才会暂停/完全结束执行.当然了,下一个yield语法也要先执行完才会暂停函数.

  ​    当此行代码被执行时,就将生成器函数返回的生成器对象的next()函数返回的common对象的value值使用yield后面的表达式值代替.

  ​		即yield关键字后面紧跟的表达式值就是next()方法返回的common对象的value值.

  ​    并再一次将生成器函数暂停执行(**先执行完yield语句才会让函数暂停**),直到next()方法再一次被调用时,才会接着继续执行生成器函数中的代码.

  ​		**注意:一个next()方法可以让生成器函数继续执行一次.(前提是yield和next()方法数量相当)**

  ​    PS:当生成器函数再一次被执行后,除非遇到以下的情况,否则将直接执行到函数结束,此时common对象中的value为undefined,done为true.
  ​    	1.再一次碰到yield关键字,生成器函数依然被暂停执行,除非next()方法又被调用.
     	 2.throw.详情了解<异常.md>,抛出一个异常,并让整个生成器函数完全停止
     	 3.碰到return语句.

- ***x = yield 'foo';***

  ​    这里的x变量将会接收下一条next()函数中传递过来的实参，而 yield 'foo' 仍然将会起作用，'foo' 将被抛出去给当前使生成器函数执行的 next() 返回的 common 对性的 value 属性。

- ***console.log(generatorObj.next(100));***

  ​	*输出的是一个对象,即next()函数的返回值,common对象.*

  ​    请注意参数100,如果向next()函数中传递参数,那么此参数将会赋值给当前yield/return语句的**上一条yield语句左边的变量**,若上一条yield语句不存在此变量,那么x就等于undefined,则yield x就等于yield undefined.

  ​    **传递该参数,一定要是上一条语句,上上条语句也是一样不会起到任何用处.**

  - ​	且当前语句即使不是yield,是return语句仍然也奏效

    ```js
    function* gen(x) {
    	var y = yield x + 2;
    	return y;
    }
    	var g = gen(1);
    // { value: 3, done: false }
    console.log(g.next()) 
     // { value: 11, done: true }
    console.log(g.next(11)) 
    // 我们可以清楚地发现，y 为 11
    ```

  

- ***yield x;***

  ​    与之对应的是***console.log(generatorObj.next(100));*** 即将会输出: `{value: 100, done: false}`因为此时的x为100.

- ***return 2;***

  ​    与之相关的next()方法为***console.log(generatorObj.next());***  即return语在生成器函数中的作用和yield相似,都是讲右边的表达式传递给next()的 返回对象的values属性,

  ​	但是其差别在于:return语句会直接终止整个生成器函数执行,而不是暂停. 所以在return语句后的所有代码都不会被执行.

  ​	如果存在语句,则***console.log(generatorObj.next());*** 应该输出: `{value: 2, done: true}`

  ​	当然了如果不存在,就一切照旧:即value应该为undefined,请看下面代码行解析.

- ***console.log(generatorObj.next());*** 

  ​	由于上一条的next()函数已经将生成器函数执行完毕,所以该条next()的返回对象的value值为undefined,done为true

以上示例需要注意的是,当生成器函数内部被执行然后暂停时,会先执行会导致暂停的语句,然后再将生成器函数暂停.

且由于是因为先调用next()方法才会让生成器函数开始执行的,所以在生成器函数执行过程中,

程序不会跳到生成器函数外部*(例如:`console.log(generatorObj.next())`这样的语句)*去执行,

而是一直在生成器函数内部执行,除非将函数执行完毕.

**因为yield语句会先将其表达式值传给next()方法返回对象的value属性,然后直接就会将等效于执行了next()方法所在的那行代码(块).**

- 可以这么理解.

#### yield总结

即当生成器函数遇到生成器对象调用next()方法的运行逻辑如下:

1. ​    第一次next()方法被调用,生成器函数被执行,若遇到`yield`语句,就先执行完必yield语句,再暂停执行后面的操作,

   ​    并将紧跟在`yield`后面的那个表达式的值，作为next()返回的对象的`value`属性值。

2. ​    由于此时已经暂停了函数执行,所以现在生成器函数将会等待下一次的next()方法的调用才会继续被执行.

   ​	直到遇到下一个`yield`表达式。

   PS:只有此生成器函数被暂停执行,其他不相关的代码仍然可以被执行.

3. ​    如果不存在下一个yield语句,则生成器函数将直接一直执行到结束,直到`return`语句为止,

   ​	并将`return`语句后面的表达式的值,作为next()方法返回的对象的`value`属性值。

   ​    也就是说,如果我们在上面的示例结束之前写了return语句,例如`return 2`,则最后一个next()返回的对象应改为:{value: 2, done: true}

4. ​    如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

**需要注意的是**:生成器函数中的`yield`语句,只有当调用`next`方法时才会被执行,因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

### yield*

#### 语法

`yield* [expression]`

expression 可选:

​	返回一个可迭代对象的表达式(或者另一个生成器函数)

​	即此表达式应该是:可迭代的对象或者一个生成器函数.

#### 描述

此语法(表达式)的作用: 能让开发者在一个生成器函数内部调用且迭代另一个生成器函数或者任何的可迭代对象.

为什么要有这样的表达式(语法)呢?因为如果我们想要在生成器函数中去调用另一个生成器函数或者可迭代对象等,那么就需要我们手动去遍历,例如:

```js
function* foo() {
  yield 'a';
  yield 'b';
}
function* bar() {
  yield 'x';
  // 手动遍历 foo()
  for (let i of foo()) {
    console.log(i);
  }
  yield 'y';
}
for (let v of bar()){
  console.log(v);
}
// x
// a
// b
// y
```

而ES6提供了yield* 语法是可以不需要在一个生成器函数内部进行遍历就能迭代另一个生成器函数或者迭代一个可迭代对象.

**yield* 表达式(语法)用于委托(将执行权力交给)给另一个生成器函数Generator Function或一个可迭代对象.**

即当程序执行到yield*表达式时, 程序将会跳转去执行yield *后面指定的表达式,这个表达式必须是一个生成器函数或者可迭代对象,否则会报错. 

注：将执行权交给生成器函数 / 迭代器对象时，程序会去执行它，直到遇到 return / yield / throw 才会停止（和 ***yield - 描述*** 一节一样）

​	跳转的原因是因为yield*语法会将它当前所在的生成器函数的代码执行权转交给yield *后面紧跟的表达式.

而且我们一直在说,yield* 后面紧跟的是一个表达式,所以yield *表达式存在自己的值.

在以下示例中,我将会一一讲解.

#### 示例

##### yield*的表达式为生成器函数

下面我们用几个示例来详细的解释什么是yield* expression

```js
function* g2() {
  yield 2;
  yield 3;
  yield 4;
}
function* g1() {
  yield 1;
  yield* g2();
  yield 5;
}
var genObj = g1();
console.log(genObj.next()); //{ value: 1, done: false }
console.log(genObj.next()); //{ value: 2, done: false }
console.log(genObj.next()); //{ value: 3, done: false }
console.log(genObj.next()); //{ value: 4, done: false }
console.log(genObj.next()); //{ value: 5, done: false }
//{ value: undefined, done: true }
console.log(genObj.next()); 
```

**代码解析:**

- ***console.log(genObj.next());  yield 1;***

  ​    当调用生成器对象的next()方法时,会执行一次此生成器对象所属生成器函数中的代码.

  ​	当执行到yield 1;时,再执行完此语句后,此生成器函数将会被在那听,等待下一次的next()方法的调用,才会继续从上一次暂停处继续执行.

  ​	并且yield后面的表达式值1将会传递给next()方法所返回的对象的value属性,所以此时输出结果为: `{ value: 1, done: false }`

- **console.log(genObj.next()); yield * g1(); yield 2;**

  ​    next()方法被调用,那么生成器函数将从上一次被暂停的地方开始执行,当执行到yield* g1()并开始执行此语句时,

  ​	由于此语句使用的是yield*,所以此时的程序执行权将被yield *抛出去,给yield *后面的表达式去执行,

  ​		*此表达式一定要是生成器函数或者可迭代对象,否则将会报错*

  ​	由于此表达式是一个生成器函数,所以此生成器函数将被执行,

  ​		请注意: 当执行yield* expression 语句时,将会直接执行一次所指定的表达式(可迭代对象/生成器函数),

  ​		这是因为当yield* 语句被执行时,肯定已经调用了next()方法(不调用生成器函数将被暂停),所以当执行权被交给指定的表达式时,表达式将直接被执行一次.

  ​		 **简单来说: 将生成器函数自身的本次执行权力转交给指定的生成器函数或可迭代对象,在普通情况下,该表达式(生成器函数或可迭代对象)被执行完毕后才会返回来执行生成器函数.**

  ​	生成器函数g2()中的yield 2;被执行, 即会将此值2,返回给g1()返回的生成器对象的next()方法返回的common对象的value属性.

  ​	所以此时console.log(genObj.next());的输出结果才会为: 

  `{ value: 2, done: false }`

- 由于此时的执行权已经交给了g2()生成器函数,**所以在默认情况,只有g2()被执行完毕后才会再去执行g1()**.所以我们看到的输出结果的value属性的值,才会是g2()中的yield语句返回的值.

##### yield\*的表达式为可迭代对象

当yield\*的表达式为一个可迭代对象时,也仍然需要调用生成器对象的next()方法才会进行迭代此可迭代对象,调用一次迭代一次,

很少存在d调用一次next()方法,就能将此可迭代对象迭代完必,因为可迭代对象如果只有1个序列值,那么yield\*再将执行权抛给可迭代对象时,

这个可迭代对象就能执行一次,然后就执行完毕了.

```js
  let i = 0;
  function* g() {
    // 调用一次next()只会迭代一次此数组(数组为可迭代对象)
    yield* [1, 2, 3]; 
    yield* 'yomua'
  }
  let gOBj = g();
  while (i < 8) {
    document.write(`${gOBj.next().value} `);
    i++;
  }
/*
	输出结果为: 1 2 3 y o m u a
*/
```

**代码解析**

- **yield\* [1, 2, 3];** 

  ​    将自身的本次生成器函数的执行权力交给[1,2,3]此可迭代对象去执行,每次调用next()方法仅能迭代一次.

- **while (i < 8) {}**

  ​    i初始值为0,总共调用八次next()方法,刚好将两个yield*语法指定的表达式迭代完毕.

##### yield* 表达式的值

```js
  let result;
  function* g2() {
    return 'yomua';
  }
  function* g1() {
    result = yield* g2();
  }
  let gObj = g1(); // 调用g1(),返回一个生成器对象啊
  // {value: undefined, done: true}
  console.log(gObj.next());
  console.log(result);// yomua
```

**代码解析:**

​	此程序的执行顺序为: 

1. let result;

2. let gObj = g1();` 

3. `gObj.next()` 

   由于此方法被调用,所以将执行生成器函数一次

4. `result = yield* g2();` 

5. `return 'yomua';` 

6. `console.log(gObj.next());` 

7. `console.log(result);`

 

- ***console.log(gObj.next());***

  ​    该输出语句并不会被马上执行,因为这个语句输出的是gObj.next(),会先执行生成器函数内部的代码,

  ​	只有当生成器函数内部执行完与这语句对应的yield语句时,此console语句才会被执行.

  ​	若不存在与之对应的yield语句,则此函数将会等到生成器函数内部的代码都被执行完毕之后才会被调用.

  ​	由于gObj所在的生成器函数,不存在yield语句也不存在return语句,所以此时,next()的返回对象结果为: 

  ​	`{value: undefined, done: true}`

  ​	请注意:return语句也是如同yield语句会将值给value属性的,只不过它会导致整个生成器函数的停止

- ***return 'yomua';***

  ​	此时的return语句并不是返回给gObj的next()方法返回的common对象的value属性,
  ​	而是返回给将生成器函数的执行权抛过来那个yield*语句,因为此时的return语句是属于g2()的,而不是g1()的.

  ​	不信请看上面的输出语句,value属性值为undefined.

- **result = yield * g2();**

  ​	将自身函数的本次执行权转交给g2()生成器函数,然后得到一个此生成器函数g2()使用return语句的返回结果.

  ​	如果g2()函数中没有return语句,则result则为undefined或默认值.

  ​		*注意如果g2()函数中存在yield语句,则代表将yield语句后面的表达式值传递给g1()函数返回的生成器对象的.......value属性.*
  
  ​	在上面两个示例中我们都已经说明过了,这里将不再赘述.

## 属性和方法

### 方法

#### [Generator.prototype.throw()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw)

##### 描述

throw()方法用来向生成器抛出异常，并恢复生成器的执行，返回带有 done 及 value 两个属性的对象。

是的,生成器函数会被恢复执行.

***参见:<Generator函数的异步应用.md - 异步 - 使用异步的传统方法 - 使用Generator函数的异步 - Generator函数的数据交换和错误处理 - 错误处理*** 

##### 语法

`gen.throw(exception)`

###### exception

用于抛出的异常。 使用 [`Error`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error) 的实例对调试非常有帮助.

###### 返回值

带有两个属性的[`对象`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)

- done (boolean)

如果迭代器已经返回了迭代序列的末尾，则值为 true。在这种情况下，可以指定迭代器 value的返回值。 

如果迭代能够继续生产在序列中的下一个值，则值为 false。 这相当与不指定 done 属性的值。

- value 

 迭代器返回的任何 JavaScript 值。当 done 是 true 的时候可以省略。