[TOC]



# [展开语法Spread Syntax](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

## 描述

可以在函数调用 或 数组构造时,将string字符串 或 数组表达式在语法层面展开;还可以在构造字面量对象时,将对象表达式按key:value的方式展开.

- 字面量对象: let obj = {...}这样的形式.

  ​	展开语法: ~~{ ...obj};即将obj以key:value形式展开.~~准确来说,我们只能将一个对象使用展开语法将之展开之后再赋值给另一个对象变量,
  
  ​	但是我们无法直接展开一个对象,将之输出,这是错误的行为.
  
  ```js
  const obj = { a: 1 };
  console.log(...obj); 
  //Uncaught TypeError: Found non-callable @@iterator
  ```
  
  ​	因为Object对象没有实现可迭代协议和迭代器协议,但是展开语法实际上是基于可迭代协和迭代器协议实现的一种语法,所以就会报错,自然不存在能展开字面量对象了
  
  ​	也因此,for...of也无法遍历字面量对象,准确来说,这是因为Object对象没有实现iterator接口,但是String,Array这些内置对象实现了..
  
  ​	有意思..
  
  *详情了解这两种协议:<迭代器和生成器以及协议.md>*

使用展开语法时也会自动调用@@iterator方法,即`xxx[Symbol.iterator]()`方法,若不存在此方法或Symbol.iterator,则使用展开语法失败,程序会报错.

今天2020/3/10.

​	在未来的代码中,若会遇到以下示例中的情形或类似的情形或适合使用展开语法的情形等,请使用展开语法,这将会更见简单,间接,易阅读以及更优优雅.

## 语法和用途

### 数组中使用展开语法

`...[a,..,n]`

**将...后的数组转为用逗号分割的参数序列,若出现在函数中,等价于调用funcName.apply(null, arr);** 即调用函数时使用展开语法，相当于为当前函数按顺序传递数组中的索引值。

​	请注意:这里说的是以逗号作为分隔符,即如同spilt()方法.简单来说:

​		就是在找到分隔符后,将其从整个数组中删去,并将分割符分割的索引值返回,得到一串并列的值,如下所示: 	



```js
// 1 2 3
console.log(...[1, 2, 3])
// 1 2 3 4 5
console.log(1, ...[2, 3, 4], 5)
/*
	[<div>, ....<div>],查询当前页面中所有的div元素并将之转为数组形式的值.
	必须加[],否则报错,因为不加中括号或者()等这些,直接使用的话,JS引擎及编译器不认识...xx是一个什么表达式,就和 = + - 这些四则运算符号一样,要用在正确的地方,才是正确的.
[...document.querySelectorAll('div')]
*/
```

若在没有展开语法的版本,我们要实现连接一个数组,还需要用到concat()等方法

所以数组展开语法可以使用在函数调用中,请往下看

- 且展开语法使用在数组中时会创建一个新数组.需要注意的是:这种方式属于浅拷贝. ***参见:<数组的扩展.md - 展开语法>***

### 函数调用使用展开语法

`myFunction(...iteratorObj);`

在函数使用展开语法时,就等价于调用该函数apply()的方法.即: 

​	在ES6之前,如果想将一个数组元素迭代为函数参数,我们通常使用[`Function.prototype.apply`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 的方式进行调用.

```js
function myFunction(x, y, z) {....}
var args = [0, 1, 2];
myFunction.apply(null, args)
```

- ***myFunction.apply(null, args)***

  ​    myFunction函数调用apply方法,将自身代码中的this指向改为Window,且自身的参数变成args值.

  ​	PS:若使用apply()和call()方法,将它们的第一个参数thisArgs指定为null或者undefined,则意味着:调用它们的函数,里面的this自动被改为指向全局对象:window.

但是现在有了展开语法,我们可以改成以下形式:

```js
function myFunction(x, y, z) { 
    console.log(x, y, z); // 0 1 2
}
var args = [0, 1, 2];
myFucntion(...args);
```

- ***myFucntion(...args);***

  ​	即等价于myFunction(null, args); 也就是使myFunction()函数中的所有this指向window对象,并且自身的参数变成args中的每个索引值.

  ​	简单来说就是:将一个数组args变成函数中的参数序列,并让函数中的this指向全局对象window.

所有函数的参数都可以用展开语法来传值,也不限制多次使用展开语法

```js
function myFunction(v, w, x, y, z) {
     console.log(v, w, x, y, z) ; // 1 2 3 4 5
}
var args = [1,2];
myFunction(...args, ...[3,4], ...[5]);
```

### 函数参数中使用展开语法(或者说剩余参数)

详情请看<变量的解构赋值.md - 示例 - rest参数说明>

### 将展开语法(或者说剩余参数)用于解构赋值

如果将展开语法作为解构赋值中的一员,用在字符串/对象/数组的解构赋值中,那么我们可以使用展开语法,即`...变量`,以变量作为对象的形式,使用当前展开语法所在的类型的所有方法/属性;

注意:以展开语法为变量的返回类型为object,请看以下示例:

- 字符串解构赋值时会被转成一个类数组对象,所以返回类型为object.
- 数组本身就是特殊的对象
- 对象,就是对象(字面量对象/纯对象).

```js
let  { x, y, ...z } = { x: 1, y: 2, a: 3 };
console.log(typeof z); // object
console.log(z['a']); // 3
console.log(z); // {a: 3}

let [x, y, ...z] = [1, 2, 3, 4];
console.log(typeof z); // object
console.log(z.push('yooo')); // 3
console.log(z); // [3, 4, "yooo"]

let [x, y, ...z] = "yomua";
console.log(typeof z); // object
console.log(z.concat('yomua'));//["m", "u", "a", "yomua"]
console.log(z); // ["m", "u", "a"]
```

很明显的我们可以发现,将剩余参数应用解构赋值的特点:

- 获取余下的所有key / 值
- 展开语法展开的变量返回的类型都为对象（包含了类数组对象）
- 被展开语法展开的变量能使用当前所处的赋值语句类型的所有属性/方法

而且值得我们注意的是: 将展开语法用于解构赋值和函数参数中时,展开语法展开的变量只能处于最后一个参数中,以下形式都错:

```js
let {...y, x, z} = { x: 1, y: 2, a: 3 };
let { x, ...y, ...z } = { x: 1, y: 2, a: 3 };
// Uncaught SyntaxError: Rest element must be last element
```

这也是很好理解的,因为在函数参数中和解构赋值中,展开语法的意思可以认为是剩余参数,即获取剩下的所有参数 / 所有key或value值.

### 构造字面量数组或字面量字符串使用展开语法

`[iteratorObj, '4', ....'hello', 6];`

构造字面量数组时使用展开语法非常的给力!

在曾经没有展开语法时,我们只能使用诸如puth(),splice(),concat()等方法去将一个已经存在且有元素的数组添加到一个新数组上,成为新数组的一部分,

但是我们若使用展开语法,这将变得非常简单,间接,以及更加的优雅.

```js
let arr = ['yomua', 'boy'];
let newArr = ['fox', ...arr, '2020/3/10'];
// [foo, 'yomua', 'boy', '2020/3/10']

/* 以下是使用concat()的写法 */
var arr = ['yomua', 'boy'];
var newArr =['fox'].concat(arr,['2020/3/10'])
```

看到了吗,高下立判,展开语法就是如此的好用.



### 构造字面量对象时,进行克隆或者属性拷贝(ES2018新增)

`let objClone = {...obj};`

- 注意:Object是不存在展开语法的,***详见:描述***

其意思为:将指定的对象的所有可枚举属性拷贝到新构造的对象中,大家有没有觉得这个跟什么很像?嘿嘿,与其说是很像,不如说这就是解构赋值.

诸位发现了吗,这就是对象的解构赋值呀,即先将obj对象展开,然后再进行解构赋值给objClone.

单纯的:  `{...obj}`语法; 则意为: 将指定的对象在语法层次面以key:value这样的方式展开.

在没有展开语法的ES的版本,我们要克隆/复制一个已经存在的对象,*(ps将一个对象引用指向另一个对象引用不叫复制,因为对象是易变的,详情看:<对象.md>)*

通常使用的是	[`Object.assign()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)方法,例如:

- Object.assign(target, source)方法: 用于将所有可枚举属性的值从一个/多个源对象复制到目标对象。

  它将返回目标对象. 请看以下示例:

```js
// 使用assign()
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
// 使用展语法
const obj = { a: 1 };
const copy = {...obj}
console.log(copy); // { a: 1 };
```

- ***const copy = Object.assign({}, obj);***

  将`obj`对象赋值到空`{}`对象中去,并返回{ `里面存在obj对象所有可枚举的属性和值 }`对象,然后将 有属性和值的`{}`对象赋值给copy变量.

- ***const copy = {...obj}***

  将obj对象中的所有可枚举的属性和其属性值在语法层次面以key:value形式展开,然后赋值给copy变量.	
  
  即: ...obj 展开之后为: a:1, 但是由于我们将 ...obj 包裹在了一个对象中(即: {...obj}),所以,当 obj 展开之后,就为: {a:1}

但是使用展开语法clone/复制/拷贝一个对象,将会显得非常优雅,并且简单. 

**不过这种使用展开语法拷贝一个对象,属于浅拷贝,**

也就是**不包含指定对象的prototype**,即新对象不会拷贝指定对象存于的prototype属性指针指向的Prototype原型对象的内存地址空间的内容.

**并且展开语法不会触发[set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set)**(*详情请看<对象.md>,JavaScript对象访问器*).

同时 使用展开语法将一个对象的可枚举属性和其值克隆给一个新的对象引用(对象变量),并不能替代或者模拟`Object.assign()`函数,

*PS: Object对象没有实现可迭代协议和迭代器协议,展开语法实际上是基于可迭代协和迭代器协议实现的一种语法,*

*所以展开语法无法展开字面量对象,只能将字面量对象的可枚举属性和值克隆到另一个对象上,可以看 描述 .*

上面的例子只是拷贝了对象实例的属性,如果想克隆一个完整的对象(包括prototype),可以采用下面的写法:

```javascript
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

上面代码中，写法一的`__proto__`属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。



### 在new表达式中使用展开语法(剩余参数)

​	`new XXX(...xxx);`

```js
var dateFields = [1970, 0, 1]; // 1970年1月1日
var d = new Date(...dateFields);
// Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)
console.log(d); 
```

```js
var arr = [1,2,3];
var a = new Array(...arr);
console.log(a); //  [1, 2, 3]
```

让我们先来讲解第二个示例,即...arr很显然等于1 2 3 ; 所以new Array(...arr) 在效果上等效于new Array([1, 2, 3]); 但是这并不代表它们是相等的或者严格相等的;

`console.log(new Array(...arr) == new Array([1,2,3]))` // false

因为对象在进行比较时,比较的是对象的所处的内存空间的地址,而地址是唯一的,所以它们当然不相等,这是一个很简单的概念. 

再让我们回到第一个示例,这个示例看上去也不难,最关键的一条代码行是:

- ***var d = new Date(...dateFields);***

  其意思为:实例化Date,并向其Date构造器中的有参构造函数传入...dateFields,即传入1970,0,1三个参数, 等效于: 

  ​	new Date(1970, 0, 1)

如果不使用展开语法, 想将数组元素传给构造函数, 实现方式可能非常的繁琐,例如:

```js
function applyAndNew(constructor, args) {
        function partial() {
/* 
	相当于调用 myConstructor.apply(partial,myArguments); 
    即将myConstructor函数中的this的指向改为partial,并向其传入参数myArguments.若myConstructor函数本身不存在此参数
	则将 myArguments 整个当作其函数参数,且是以它原本的形式当作参数,比如myArguments为数组,则myConstructor参数就是一个数组参数.
*/
            return constructor.apply(this, myArguments);
        };
        if (typeof constructor.prototype === "object") {
            /* 
                为partial构造函数的原型链上添加一个新对象:constructor.prototype,简单来说就是partial继承了constructor对象
            可以使用constructor里面的属性和方法.其结果等效于: partial.prototype = constructor

            */
            partial.prototype = Object.create(constructor.prototype);
        }
        // 返回整个partial构造函数代码
        return partial;
    }


    function myConstructor() {
        console.log("arguments.length: " + arguments.length);
        console.log(arguments);
        // 为partial()构造函数添加两个属性: prop1,prop2
        this.prop1 = "val1";
        this.prop2 = "val2";
    };

    var myArguments = ["hi", "how", "are", "you", "mr", null];
    var myConstructorWithArguments = applyAndNew(myConstructor, myArguments);

    /* 
   		相当于new partial(),所以会执行partial()里面的代码.
    	最后再返回myConstructorWithArguments()函数的值,在这里值就为 partial()整个函数代码. 
    */
    console.log(new myConstructorWithArguments());
     /*  
     (myConstructor构造函数中):  
     	arguments.length: 6
     	
     (myConstructor构造函数中):  
     	["hi", "how", "are", "you", "mr", null]
     	
     ("new myConstructorWithArguments"中):
     	{prop1: "val1", prop2: "val2"}
     */
```

看到了吗,ES6的展开语法给我们带来多么大的便利啊!! 即使你去 [Babel中文网](https://www.babeljs.cn/)或者使用其他工具将这展开语法翻译成ES6之下的语法,也是一样的繁琐,和我这个示例是差不多的.

