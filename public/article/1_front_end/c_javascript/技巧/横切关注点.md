# [什么是横切关注点](https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9)

在回答什么是横切关注点时，我们需要先知道，**关注点**指的是什么？

> A **Concern** is a term that refers to a part of the system divided on the basis of the functionality.

即：**关注点**是指基于功能划分系统的一部分。

**横切关注点** 则是指：一部分【关注点】`横切`（横跨）了程序中的数个模块，又或者说某个行为横跨了程序中的多个模块。

**简单来说：系统的某个功能出现在了 2 个及以上的模块中，我们把这种概念称之为“横切关注点”。**

让我们通过一个简单的示例来讲解： 

在某个应用程序中，存在一个日志功能，其中在用户模块中需要通过日志功能来记录用户信息，管理模块也需要通过日志功能来记录管理信息， 后台模块等其他一些模块也需要日志功能来做些什么，

那么显然的，我们知道：日志功能是一个“关注点”（*它是程序中基于功能划分系统的一部分*），并且该关注点”横切“了多个模块（*多个模块都需要使用到它*），所以我们将这个日志功能称之为：**横切关注点**。

# [横切关注点的麻烦](https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9#%E8%83%8C%E6%99%AF)

通过 <a href="#[什么是横切关注点](https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9)">什么是横切关注点</a> 一节我们知道，横切关注点指的是一个功能出现在了 2 个及以上的模块中，而这种横切关注点势必会带来代码在程序中分散或重复执行的问题，最终导致程序模块化的丧失。

这个原因很简单：如果一个程序具有横切关系，那么由于过程性和功能性编程语言的结构完全是步骤化调用，也就没有语法可以同时进行功能实现和横切关系处理，所以自然就会使得代码分散执行，程序模块化丧失。

**TIP**：程序内那些冲突或者内部依赖过度一般都和横切关系有直接联系

那么我们该如何去解决因横切关注点从而导致的程序模块化丧失的麻烦呢？请看 <a href='#如何解决横切关注点的麻烦？'>如何解决横切关注点的麻烦？</a> 一节。

# 如何解决横切关注点的麻烦？

现在假设存在一个输出日志的模块，在 A 和 B 两个模块中都要调用使用到它，我们不假思索的就可以写出以下方案：

## 引入基础类

**抽象日志功能的作用，形成一个基础类 Log：**

```ts
class Log { // 定义 Log 类
    printLog:(v:string)=>void
    printLog(logValue) {console.log(logValue)}
}

// A 和 B 两个模块继承 Log 类
class A extends Log { }
class B extends Log { }
new A().printLog('hello'); // hello
new B().printLog('world'); // world
```

这种方案胜在简单，但是当日志功能需要变得更为复杂，并且横切更多模块，甚至于日志功能本身就是一个“被切“的功能，

那么整个程序就骤然变得复杂以及臃肿，模块与模块的耦合将会增加（不利于扩展，而且牵一发而动全身），

并且随着日志功能（Log 类）的复杂度增加，它的职责也会越来越模糊…

## 依赖注入

我们除了定义一个基础类 Log，并使得其他类继承它之外，还有另一个方案：**注入**。

即：将 Log 类的实例直接注入到 A 和 B 类中，从而在 A 和 B 的实例使用 Log 类的方法：

```ts
type V = string | object | Array<any> // 定义一个联合类型的别名

// 日志模块
class Log { // Log 的 print 将会打印你传入的值并且返回它
    print(v: V) {
        console.log(v);
        return v;
    }
}

class A {
    private _log: Log; // 私有属性，new A() 时用来存放每个 A 实例的 Log 实例。
    printLog: (v: V) => V // 用来存放 Log 实例上的 print()
    constructor(log: Log) {
        this._log = log; // 将 Log 实例赋值给 _log 属性
        this.printLog = this._log.print // 获取 Log 实例的　print 方法

    }
}
let a = new A(new Log()) // 将 Log 实例注入 A 实例
// A 的实例能够得到 Log 实例拥有的方法。
a.printLog('yomua'); // yomau
```

我们将 Log 实例注入到 A 中，从而使得 A 实例可以使用 Log 实例的方法。
