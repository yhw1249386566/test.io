[TOC]



# 定义

所谓的作用域即某个变量、标识符、代码等能在什么哪个区间内使用,而这个区间即使它们的作用域.

在此,我以标识符作为如同变量,代码的简称.

# 局部作用域 & 块级作用域

## 描述

首先局部作用域和块级作用域它们二者从名字上来看是没有什么区别,即都代表某一个区间内的作用域.

但是为了搞清 `{}`内的作用域和 `函数内部作用域`之间的关系,我们将:

​	块级作用域暂且认为是 `{}`的作用域.

​	局部作用域暂且认为是 `函数内部`的作用域.

## 局部作用域

### 描述

即暂且将函数内部的作用域的名字称为局部作用域.

### let var const在局部作用域中的表现形式

在函数内部的作用域当中其所有变量通常不能被外部所访问,即是一个封闭环境.

```js
function demo() {
	let a = 5;
    var b = 5;
    const c = 5;
	return a;
}
console.log(a); // undefined
console.log(a); // undefined
console.log(c); // undefined
```

- a,b,c在外部都不能被访问,或者说是因为其无用程序收集单元的关系,a,b,c在函数结束执行时被销毁(释放)了.
- 所以对于函数作用域(局部作用域)来说其let var const真没有什么区别.而



## 块级作用域

### 描述

即暂且将{}中的作用域的名字称为块级作用域.

### let var const在块级作用域中的表现形式

#### var

#####  var不存在块级作用域

```js
   	// var不存在块级作用域
	{
        var a = 2;
    }
    console.log(a); // 2
```

##### 重复声明同一个变量

```js
    var a = 1;
    {
        var a = 2;
    }
    console.log(a); // 2
```

- ​    由于var是不存在块级作用域的,所以有没有{}都是对于var关键字来说都是一样的,且被var声明的变量是可以继续使用var重复声明的

  ​	(使用let,const等就不行,会直接报错:已经被声明的变量)

  所以此处的a才会输出2,因为变量a被重新赋值.

#### let 

##### let存在块级作用域

```js
   	// let存在块级作用域
	{
        let a = 2;
    }
    console.log(a); // undefined
```

##### 重复声明同一个变量

```js
    let a = 1;
    {
        let a = 2;
    }
    console.log(a); // 1
```

- 由于let存在块级作用域,所以在{}中声明同一个变量是可行的.所以这里输出1, 块级作用域{}中的2赋值并不会影响到外部的1赋值,你可以将它们看成两个不同的变量,只是名字相同.

  (同一个作用域不允许使用let进行重复的声明)

- 这个和const是一样的.

#### const

##### const和let一样存在块级作用域

```js
   	// const和let一样存在块级作用域
	{
        const a = 2;
    }
    console.log(a); // undefined
```

##### 重复声明同一个变量

```js
    const c = 1;
    {
        const c = 2;
    }
    console.log(c);// 1
```

- 很显然,此处使用const进行重复的声明,和let进行重复声明其得到的结果一样.

  因为它们二者都存在块级作用域,会被{}所限制.

### [let 和 const 也存在提升](https://juejin.cn/post/6844904013599604749)

## for循环的特殊性

### 描述

对于此for(){}循环来讲,()中声明的条件变量可以认为是整个脚本的全局变量,存于全局作用域中;而{}中,可以认为是整个脚本中的块级作用域{}.

所以全局作用域和块级作用域书写let,var,[const]的特点for循环也全都有.

1. 我们可以在for(){}的{}中用var声明的变量是全局作用域(真正的全局作用域,而不是()和{}里面才能使用.

   ```js
   for (let i = 0; i < 3; i++) {
      var b = 1;
    }
     console.log(b); //  1
   ```

2. var    for(){}, ()中使用let声明的变量,不能再{}中用var重新声明,因为var不存在块级作用域,和外部的相同名字的变量会互相冲突.

   ​	但可以用let重新声明,因为let是存在{}块级作用域,其{}中的变量和外部的变量互不影响

   ```js
       for (let i = 0; i < 3; i++) {
           var i = 0;
       }
       console.log(i); 
   /*
   	报错:即i已经被声明.
   */
   ```

   ```js
       for (var i = 0; i < 3; i++) {
           let i = 0;
       }
       console.log(i); // 3
   ```

   ​	注意:此处的例子和前一个例如很相像,但是不要搞混,前一个()中是let,{}中是var

   ​	后一个 ()中是var,大括号中let

   ​	而前一个报错的原因很简单,因为var是不存在块级作用域的,前一个的做法就如同在同一个作用域用不同的关键字声明相同的变量,当然会报错.

   ​	而后一个不报错的原因也很简单,let存在块级作用域,不会影响到开机作用域区间以外的地方,所以即使声明相同的变量没什么事.

3. for(){}, ()中使用var声明的变量依然是全局变量,因为var变量不存在{}块级作用域.

   ```js
     for (var i = 0; i < 3; i++) {
     }
     console.log(i); // 3
   ```

   

# 全局作用域

## 描述

所谓的全局作用域,即不在任何局部/块级作用域当中,在此作用域声明的变量将可以在整个脚本中所使用.

## 尽量不要使用var!

且我想我现在懂了为什么老是说不要使用var进行声明变量了,这是因为若使用var声明变量,

且若在全局和块级作用域中不小心声明了同一个名字的变量,将造成块级作用域中的var声明的变量覆盖全局作用域中的var所声明的变量,导致出现预期结果,

而且还难以检查以及各种可能出现的重大事故.

而是用let显然就不会有这样的意外,即使不小心重复的在块级和全局中声明了同一个变量,它们二者也不会互相影响,因为let存在块级作用域