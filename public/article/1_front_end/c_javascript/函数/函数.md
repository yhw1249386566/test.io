[TOC]

# 定义

一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。

像程序本身一样，一个函数由称为函数体的一系列语句组成。

值可以传递给一个函数，函数将返回一个值。

# 描述

在 JavaScript中，函数是**头等(**first-class**)**对象，因为它们可以像任何其他**对象**一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。

简而言之，函数是`Function`对象,即它们属于Function对象,且typeof运算符运算一个函数时,返回:"function"

那问题来了,函数等于对象吗? 通常认为,是这样的. 因为在JS中,它们与其他对象并没有什么不同,甚至还多了个功能:可以被调用.

而且我们通常认为在JS中,每个函数其实都算是一个Function对象,详情了解请看:<Difficult.md> →  function(){}和new Function();

> 但是若是使用function关键字定义的函数对象和真正的对象还是有些区别的,比如无法直接使用`函数名.属性名/方法名()`使用属性/方法,
> 
> 这是由于function关键词定义的函数并不会被执行,而是会被暂时保存,等待调用后才被执行,详情依然是了解<Difficult.md>

在函数中,若没有使用return语句,则它默认的返回值为undefined.请注意,我这里说的是**该函数本身的返回值**,不包括里面的内容值.

```js
    function func() {
        console.log('Good');
    }
    func(); // Good
/*
    该函数没有return语句,即没有返回值,但是我们调用该函数且执行时,输出Good,这代表此函数的返回值是Good了吗?
    这当然不是,这只是说该函数输出了Good这个内容.
        因为首先这个函数被调用执行了,那么JS就会执行它其中每一条能执行的语句,
        而console.log()就是能被执行的语句,所以在执行过程中,Good就已经被输出了
    而此函数的返回值:仍然是undefined.
*/
```

在调用函数时,若函数的实参是一个对象引用,则与之对应的形参会和实参指向同一个对像,也就是说假如在函数内部改变了对象形参的值,则实参指向的对象的值也会改变***(对象是易变的,参见:<对象.md>).***

当然,若实参为一个原始值***(详情看<基本类型(原始类型).md>)***,则形参值改变不会影响到实参,原因是函数会为实参创建一个副本,即形参,'

在函数内部操作形参时,就等于操作一个副本,怎么操作都不会改变实参的值,除非实参是对象引用,因为形参即使为副本也是指向同一个对象,对象是不会创建副本的.

# 函数的创建

## 函数声明 function关键词

### 描述

函数声明同时也创建了一个和函数名字相同的变量,因此,它与函数表达式的定义不同,以函数声明定义的函数,在函数能使用的作用域内,可以通过函数名访问到函数.

```js
/** 
    以下函数利用函数声明转换成函数表达式时,会被提升到当前顶层作用域,所以该函数是一个立即执行函数.
    void 会将下面的函数声明提升为函数表达式。
    且我们在该函数表达式中继续使用name()调用该函数,形成递归.
    如果是正统的函数表达式则不能这么做.
*/
void function name() {
    if (i == 1) {
        i++
        name()
    }
    console.log(1)
}()
```

而函数表达式则不行,它们只能使用被赋值的变量,而不是函数名.

这和函数声明不同,函数声明可以使用函数名字访问到函数.

需要注意的是: 函数声明非常容易*（经常是意外地）*转换为函数表达式*(这就导致我们可以利用这点写一个立即执行函数(只调用函数))*。

即：当它不再是一个函数声明：

- 成为表达式的一部分

- 不再是函数或者脚本自身的“源元素” （source element）。
  
  “源元素”是脚本或函数体中的非嵌套语句。

```js
// 函数声明
function foo() {}

// 函数表达式
(function bar() {});// 被嵌套了,所不再是函数声明.

// 函数表达式
x = function hello() {}

if (x) {
   // 函数表达式
   function world() {}
}

// 函数声明
function a() {
   // 函数声明
   function b() {}
   if (0) {
      //函数表达式
      function c() {}
   }
}
```

### 语法

```js
function funtionName([arg1,arg2,...,arg255]) {
    statements 
}
```

#### arg

参数,即每个函数最多有255个参数,最少有0个参数.

#### statements

即函数主体包含的一系列语句,几乎可以是任何语句.

## 函数表达式

函数表达式中,其变量的作用域只受限于变量的作用域,而不会受限于函数的作用域,但是反过来却不是这样,即函数的作用域受限于其函数的作用域,同时受限于变量的作用域,可以这么说:变量的作用域包含着函数的作用域.

### 匿名函数的函数表达式

```js
let func = function([arg1,arg2,...,arg255]) {
    ...
}

    /* 实例 */
    let func = function(arg1,arg2) {
        return a + b;
    };
console.log(func(1,2)); // 3
```

很明显的,赋值运算符= 右边的是一个匿名函数,为什么是匿名函数呢?因为通常对于函数表达式来说,函数的名字是能省略的,

而且通常是使用该函数表达式的变量来控制函数,而不是使用函数表达中的函数的名字来控制函数,我们也无法使用函数的名字来控制函数.

### 命名函数的函数表达式

当然也可以为函数表达式中的函数命名

```js
    let func = function name(arg1,arg2) {
        return a + b;
    };

    name(1,1); // × name不是一个函数
    func.name(1,1) // × func.name不是一个函数
```

而命名函数表达式的好处显然是有的,即当我们遇到错误时,堆栈跟踪会显示函数名,容易寻找出错误. 

但是请记住,命名函数表达式,依然不能使用函数名字来调用函数表达中的函数.否则会直接报错.

### 箭头函数表达式

即使用箭头函数来缩减函数表达式的内容,在一些简单的函数表达式上可以使用箭头函数缩减,但是在复杂的函数表达式上请不要使用箭头函数,会导致阅读困难,得不偿失*（好吧，这是因为笔者在记下此内容时，对于箭头函数还不熟悉所导致，实际上，箭头函数会使阅读简单，2020-08-17）*。

```js
    let func = function name(a,b) {
        return a + b;
    };
// 以上函数表达式的形式可以写成以下形式
    let func3 = (a,b) => a + b;
    console.log(func3(2,2)); // 4
```

## Function()构造器

详情了解<difficult.md>

### 描述

注意,使用Function构造器创建的函数表达式,我们无法直接使用其被赋值的变量来访问构造函数的.

```js
var foo = new Function("alert(anonymous);"); 
foo(); // 会报错.
/*
    即Uncaught ReferenceError: anonymous is not defined
*/
```

因为使用构造函数Function()定义的函数,是没有函数名字的,且不能通过变量的方式来访问函数.

且Function构造函数定义的函数不继承任何全局作用域以外的作用域(那些所有函数都继承的)。

也就是说,使用Function定义的函数除了全局作用域之外,其它的作用域都不继承, 包括其余所有函数都继承的作用域,Function定义的函数也不继承.

通过函数表达式定义的函数和通过函数声明定义的函数只会被解析一次，但是Function构造函数定义的函数却不同。

也就是说，每次构造函数被调用，传递给Function构造函数的函数主体字符串都要被解析一次 。

虽然函数表达式每次都创建了一个闭包，但函数主体不会被重复解析，因此函数表达式仍然要快于"`new Function(...)`"。 

所以Function构造函数应尽可能地避免使用。

有一点应该要注意的，在通过解析Function构造函数字符串产生的函数里，内嵌的函数表达式和函数声明不会被重复解析。例如：

```js
    var foo = (
        new Function(
            "var bar = \'FOO!\';"
            "\n return(function(){\n\talert(bar);\n});"
        )
    )();

    foo(); 

// 函数体字符串"function() {\n\talert(bar);\n}"的这一部分不会被重复解析。
```

### 语法

使用Function构造器创建函数.

```js
let func = new Funtion(arg1,...arg254,funtionBody);
```

因为使用函数Function和使用function关键字所达到的效果几乎是一样的,但是考虑到简易性和可读性,所以我建议使用function关键字代替Function构造器,

理所当然的,类似 new String()和new Number(),用构造器的方式也可以被  = '', = 2这样的简易(原始)方式代替 ,详情了解这方面,请看<对象.md>

## 函数生成器function* 语句 先略过

***参见:<迭代器和生成器以及协议.md>***

### 了解function*关键字的必要知识点

详情请搜索JS帮助文档→ 生成器

#### 迭代器和生成器

#### Generator

#### yield

yield关键字用来暂停和恢复一个生成器函数(function * 或 遗留的生成器函数.)

yield关键字后面的表达式的值返回给生成器的调用者,

### 描述

function * 关键字可以在表达式内部定义一个生成器函数.

而且用function * 关键字定义的函数表达式和函数声明比较相似,而且几乎拥有相同的语法,它们二者唯一的区别就是前者(function * 关键字定义的表达式)可以省略函数的名字,而函数的声明 `function * functionName(...){..}`不行.

### 语法

#### 函数表达式

```js
let func = function* [name] ([arg1,arg2,...,arg255]) {
    statments
}
```

##### name

函数的名字,可以省略.

#### 函数声明

```js
function* name([arg1,arg2,...,arg255]) {
    statments
}
```

##### name

函数的名字,在这里无法省略,这体现出函数声明和函数表达式的区别.

### 示例

#### 函数表达式

```js
var x = function*(y) {
   yield y * y;
};
```

#### 函数声明

```js
function* foo() {
  yield 'a';
  yield 'b';
  yield 'c';
}

let str = '';
for (const val of foo()) {
  str = str + val;
}

console.log(str); // "abc"
```

## function VS 函数表达式 VS 构造器 VS function*

function*号就先不说了,因为它与其他三者都是不一样的,它是生成器函数.

```js
// 使用new操作符
var multiply = new Function('x', 'y', 'return x * y');
一个名为multiply的函数声明：

// 使用function关键字
function multiply(x, y) {
   return x * y;
} // 没有分号

// 以下二者显然一个是匿名函数表达式,一个是非匿名函数表达式.
var multiply = function(x, y) {
   return x * y;
 };

var multiply = function func_name(x, y) {
   return x * y;
};
```

以上三者虽然有一些细微的区别,但是所起的作用都是差不多的,即都是得出一个x*y的值.

不过函数表达式中有些地方需要注意: 其函数名在无法被改变(即这条语句若执行完毕后),但使用函数赋值的变量却可以重新被分配

```js
let multiply = function func_name(x, y) {
   return x * y;
};

let mul = multiply;
```

通过以上形式,mul变量中也存在着func_name函数,虽然mul变量中的函数是multiply变量中函数的副本就是了.

而且在函数表达中,函数的名字是不能用于函数外部的,只能用于函数内部.

```js
let y = function x() {};
alert(x); // throws an error
```

## 为什么函数声明能用函数名访问函数,函数表达式则不行呢?

这是因为函数声明同时创建了一个和函数名字相同的变量,这个变量就相当于函数表达式中的被赋值的变量,只不过这个变量和函数名相同而已.

```js
    let x = function(..){..}; // 这个x就是被赋值的变量
    function x(..) {..}; // 会生成一个和x函数名相同的变量x,我们操作函数名其实就是操作变量x,这和函数表达式没什么区别.
// 函数表达式也是通过操作被赋值的变量x来操作整个函数的.
```

因此,以函数声明定义的函数,在函数能使用的作用域内,可以通过函数名访问到函数.

而函数表达式则不行,它们只能使用被赋值的变量,而不是函数名.因为函数表达式中被赋值的变量和函数名字可不相等.

或许有人会问,如果将函数表达中的被赋值的变量,让它和赋值函数的函数名字一样,这样不就达到了函数声明,即用function类似的访问效果了吗?

是的,当然可以这样.

```js
    let func = function func(){
        console.log('Good');
    }
    func(); // Good
```

当然可以这样子,但是意义是什么呢?就为了达到和函数声明那样的效果,那为什么不直接使用function关键字? 

相信我,我们使用函数表达式绝对不会出自于这个原因,不过用也没错.

# 函数的参数

对于函数来说,其参数最多为255个,最少为0个.

若没有值或传传递了未定义的值,则通常使用默认参数,而JS中的默认参数显然是undefined,这意味着函数的参数没有值或传递了未定义的值也不会报错,因为它的值会称为默认参数:undefined.

其实也通用于JS中几乎所有的需要参数的存在.

# 函数的调用

## 自调用函数

所谓的自调用函数,只不过把函数声明变成了函数表达式,如:
let fun = funciton(){}; 接着该函数会被执行,最后直接再使用 `()`调用它罢了.

PS:函数声明在被转为函数表达式时,会自动提上到当前作用于的顶层,所以我们可以在源码中,先调用函数声明再写函数声明,就和val定义的变量一样,而函数表达式则不行.

以下示例是函数声明后立即调用该函数,也就说它会称为执行状态,按照顺序执行的要求来执行.

```js
    console.log('我比下面的selfCall()函数先执行.')
    (function selfCall() {
        console.log('Good')
    })();
/*
    我比下面的selfCall()函数先执行.
    Good
*/
```

诸如以上示例,我们还可以使用很多种方法将之让一个函数声明变成函数表达式,并直接使用 `()`调用,如:

```js
void function name() {
    alert('?');
}()
// 该js代码将会立即被执行.
```

***需要注意的是***:当一个函数声明转换成函数表达式后,就无法继续调用该函数表达式了,否则将会报错,如同上面的say()语句一样.

更多请参见: [可参见](https://segmentfault.com/a/1190000003031456)

## 通过函数构造器调用函数

顾名思义,我们可以通过构造器,即构造函数来调用函数,就好像Java中在new要给类时,其他就会调用类中的构造函数一样.

具体为: 如果函数调用的前面是一个new关键字,那么这是一个构造函数的调用.

```js
// 这是函数构造器：
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// 创建了一个新对象：
var newObj = new myFunction("Bill", "Gates");
newObj.firstName;  // Bill
```

以上的例子显然就是一个典型的使用函数构造器来调用函数.

即 `myFunction`的前面是一个new关键字,(如同Java类中的构造函数在被new时就会被调用),此时myFunction就会被调用,又由于是使用的new关键字,

所以就相当于实例化了myFunction构造函数(器),也就相当于为myFunction创建了一个新对象newObj,并使用这个新对象newObj指向myFunction构造函数所在的内存空间地址.

## 作为方法来调用函数

在JS中,可以将函数看作一个对象的方法.

```js
var myObject = {
    firstName:"Bill",
    lastName: "Gates",
    fullName: function () {
        return this.firstName + " " + this.lastName;
    }
}
myObject.fullName();         // 将返回 "Bill Gates"
```

以上的例子就是使用了创建对象文字的形式,然后创建了一个对象方法,并使用 `对象名.方法名`的形式,将函数看作对象的方法来调用函数.

# 回调函数

## 描述

回调函数指的是: 将一个函数a作为参数,传递到另一个函数b的形参当中.

请注意:函数a是就(被)回调函数.

首先你要明白,什么叫做回调?

​    即,函数a作为参数传递到函数b时,**当函数b开始执行且准备执行参数函数a(也就是函数a)**的这个过程就叫做回调.

​    很显然,函数b调用函数a,函数a是被函数b调用(回调)的一个函数,所以a叫做回调函数. 被调用的一方叫做回调函数.

```js
function data(){...}
function receive(x){...}
let variable = receive(data);
/*
    调用receive(x)函数,将data()函数作为参数传递到receive(x)函数中,
    并让其receive()函数创建一个data()函数的副本,其名为:x
    此时这里,data()是回调函数,receive()回调data()函数的函数.
*/
```

运用到实例,也就是说: 

​    在一个任务中,我们将这个任务分成两段

- 把后半段需要执行的任务单独写在一个函数中
- 然后等到前半段任务执行完毕后,需要执行后半段任务时,再直接调用这个函数,执行后半段任务.

## 回调函函数的作用

***回调函数就如同指针一般,调用者的形参所创建的回调函数副本,指向了回调函数本身空间的内存地址,其内存空间地址的数据再怎么被改变,形参(指针)都能通过内存空间地址操作数据.***

可以把调用者(调用回调函数的函数)与被调用者(回调函数)分开,从而使调用者不必关心谁是被调用者. 

调用者只需要知道有个具有特定原型和限制条件的被调用函数是存在的就行.

简单来说:就是说,调用者不关心它所使用的形参创建的是哪个(回调)函数的副本,只要是在特定情况下可以这个形参能满足我们使用就行.

这样调用者(函数)在以后处理类似的事件的时候,调用者,即该函数可以根据情况灵活的使用各种方法,而不必被回调函数所绑定

这是因为回调函数在调用者那,只是一个形参 ,这个形参链接回调函数,回调函数如何更改调用者本身却不用改变,即使它们是相互耦合也一样,只要改变形参所创建副本的函数本地即可.

## 回调函数的现实举例

比如: 有一个工程需要甲乙二人共同完成:

甲: 通常情况下,我需要A,B,C三个模块才能完成,如今已经有A和C模块,差个B模块,而这个B模块必须符合我的要求.

乙: 那有点巧,我刚好有个B模块,就是不知道符不符合你的要求,等你需要这个B模块的时候,我把B模块的密钥(密码)给你,你再看看行不行.

在上面两段对话中,乙口中的B模块就是回调函数,而甲规定了B模块(回调函数)的一些特定要求.

乙方会根据这些特定的要求以及一些其他的要求(比如项目的要求)送给乙相应B模块,在通常情况下,乙会把自己有的B模块的密钥(密码,即函数指针)送给甲,然后让甲自己去实现,而不是将整个B模块送给甲.

> ​    且请注意: 对于有B模块的密钥的甲来说,甲可以为此密钥做一些限制才能被触发,也就是让甲实现此密钥,不一定要直接使用.

至于为什么送的是密钥(函数指针),而不是整个B模块(函数)呢?可能有两种情况:

1. ​    在完成项目的过程中,项目的要求有可能并不是一成不变的,比如B模块可能会出现朝令夕改,而A和C模块却不需要变等情况,
   
   ​    如果将整个B模块送给甲,那这意味着在B模块需要改要求的时候,A和C模块也要改? 
   
   ​    你或许想问,为什么A,C模块要改,我直接重新改个B模块重新送给甲,然后将甲有的旧的B模块删除,这样不行吗?
   
   ​    很不错的问题,但是你有没有考虑过,在你第一送个甲B模块时,甲就将B模块用起来了,让B模块和A,C模块相互耦合,然后这时候你告诉甲,B模块要变更,你快把你的B模块删除,这现实吗?
   
   ​    B模块和A,C模块都相互耦合了,你更改B模块势必会影响到其他两个模块,这就会造成本来不需要改变的A,C模块改变了,究其原因都是因为你说B模块需要变更了! 
   
   ​    所以为了解决这个问题,乙才会只送甲一个B模块的密钥(函数指针),此密钥链接B模块,这样即使B模块朝令夕改,那么也不要紧.
   
   ​    因为我只需要直接改动B模块,而不需要去改变A和C模块,因为甲有的是B模块的密钥(函数指针),
   
   ​    此密钥直接映射B模块,B模块如何更改都相当于密钥也在动态更改,而密钥却又不需要改变就能操作被改变的B模块,岂不是美哉?

2. ​    在完成这个工程时,有个硬性规定: 此项目的B模块只能由乙拥有,其余任何人无法拥有.
   
   ​    所以很显然,甲必须要B模块才能完成一个任务,而又不能拥有B模块,那么解决办法就是有B模块的密钥(函数指针),然后由甲来实现此密钥即可.
   
   ​    且请注意: 对于有B模块的密钥的甲来说,甲可以为此密钥做一些限制才能被触发,也就是实现此密钥,不一定要直接使用.

面对以上的例子的两种情况,

**第一种情况就是为了解耦**,**也就是让模块与模块之间是低耦合的情况**,方便代码的维护修改等.(具体有关于解耦的请看: H:\All Note\Deep Study Note\SE Introduce,即软件工程导论 的笔记.)

**而第二种情况是为了保障自己特性或一些权限或一些其他情况等.**

比如有个子线程是特定用来获取图像,但是此子线程不能将获取的图像直接显示在它所在的界面上,而是需要显示在主界面上,否则就破坏了它的特定性.毕竟他是用来专门获取图像的.

而主界面是专门用来显示图像的,它不能获取图像,此时主界面的主线程想要显示图像,那么主线程预先给获取图像的子线程一个图像显示的句柄(指针),

告诉子线程,你获取完图像需要显示时,直接告诉我,由我来执行.

而这个图像显示的句柄(指针)其实就是被创建副本的回调函数,一个形参.

# 由于变量提升(var)导致“怪异”的输出

```js
    var a = 1
    function test(a) {
        console.log(a)
        var a = 2;
        function a() {}
        console.log(a)

        // 上面实际上将会变成以下这样，这是因为变量提升及预编译
        var a = function(){}
        console.log()
        a = 2
        console.log(a)
    }
    test(1)
/** 输出结果
    function a(){}
    2
*/
```

函数解析

- **var a = 2**
  
  由于是 text() 函数中使用了 var 去定义了 a 变量，所以被 var 定义的 a 变量，将会被提升到当前作用域的最顶层，
  
  但是请注意：这种变量提升只会提升变量声明，而不会提升值，比如这里的 var a = 2，只有 var a 会被提升到 text() 函数作用域的最顶层，而 a = 2 停留在原地，现请思考以下示例：
  
  ```js
      var a = 1
      function test(a) {
          console.log(a);
          var a = 2;
          console.log(a);
  
          // 上面的 JS 将被预编译成以下形式：
          var a;
          console.log(a); // 1
          a = 2;
          console.log(a); // 2
      }
      test(1)
  ```
  
  - 很明显的，通过以上示例，我们很清楚的能知道，只有 var a 这个函数声明会被提升到当前作用域的最顶层，而 a = 2 这个赋值仍然在原地.

# for 循环的特殊性