# 讲在开头的一些话

在开头我必须得说明些什么

2020/1/16 日之前,我总是迷惑在其英文的大小写上面,当然,这里并不是说大小写并不重要,毕竟JS很尊重大小写的区别嘛。

而是指关于如同返回类型 `number` `Numbe`，`boolean` `Boolean` 的这些的大小写的区别. 。当然不是指在他们作为变量的时候,蒽..它们也无法作为变量,毕竟是关键字.

由于因为 `typeof` 判断一个数据的返回类型时,所返回的类型一直是以字符串的英文全小写的形式返回,从而导致我进入了一个死胡同,即:

​    *例如: 所返回的类型 `string`是和 `String`这个对象有没有关系,这个数据到底属于 `string` 还是 `String` 呢?*

`2023-03-26 21:32`

现在我有了结果:

- `string` 代表一个变量属于的基本类型

- `String` 代表一个变量它对应的 包装器对象 / 构造函数 / 类。

将一个基本值说成：此基本值属于某个包装器对象是**错误**的，只能说此基本值对应的包装器对西那个是什么。

比如：字符串 `a` 它属于 String 包装器 ❌。正确的说法是：一个字符串的来源可以通过 String 包装器对象得到。

构造器函数，类，包装对象概念。（构造器指的就是构造器函数）
它们三个其实都是**指一个东西**，只不过在使用方式不同的情况下，叫法不同。

- 当我们使用 new 操作符去实例化一个 Number 时，我们可以将这个 Number 称之为**类**或者**构造器函数**。
  为什么上面的这种操作可以有两种不同的叫法呢？
  
  这是因为在JavaScript中，类 class 就是使用 js 中的**函数模拟出来**的一个概念JavaScript 在实现 Number 时，可能是使用函数去实现的，或者使用 class 实现的。
  
  ```ts
  // 比如：通过函数实现 Number 构造器函数
  function Number(){}; 
  Number.prototype.xxx=xxx; ts
  ```
  
  ```ts
  // 通过 class 语法糖去实现的 Number 累
  class Number extends Object{
    constructor(){
      super()
    }
  };
  ```
  
  这两种实现方式他们的目的都是一样的，所以我们可以把它称之为实例化一个类，或者实例化一个构造器函数。

- 当我们使用 Number 去将一个类型，转换成数字类型时。
  
  例如 `Number('1')`，我们将这个 Number 称之为包装器对象，这个操作称为封箱。
  
  有封箱就有拆箱，而拆箱和封箱指的也是同一个东西，不过使用场景不同，那么叫法不同：
  
  ```ts
  // 需求是将一个字符串类型转化成数字类型，那么 Number("1") 这个操作叫做封箱
  const value = Number("1") tsts
  ```
  
  ```ts
  // 将它重新转化成字符串类型时，这个操作叫做拆箱
  const value = String(value)
  ```
  
  封箱和拆箱其实是 java 中的一个概念，《大话设计模式》—— 程杰 这书中的第 29 页。

错误的理解：

> ~~因为 `typeof()` 这个方法本身就是这样子的,它是里面的代码让它返回以字符串的且全小写英文的形式,而不关于什么 `String` 和 `string` 是首字母大写或小写的.~~
> 
> ~~也就是说被 `typeof()` 返回的 `string` 和 `String` 这二者,都是数据所属的类型,~~
> 
> ~~我们可以说其数据是String类型或者属于String对象**(在没有被new String('xxx')这样之前,不能说这个数据是属于对象)**,也可以说是string类型.~~
> 
> ~~2020-12-10：我们可以说数据是 string 基本类型，或者说数据属于 String 包装对象。（string 基本类型的包装对象为 String，包装对象可以使我们调用在它身上的各种方法和属性，而 string 基本类型由于不是对象，所以它并不存在属性和方法）~~
> 
> ~~2022-08-10 17:41：实际上，`'string'` 就是 `typeof()` 方法返回的结果，这个结果代表着调用 `typeof()` 方法的变量是一个 `string` 基本类型的数据。~~
> 
> ~~当然 `string` 和 `String` 是有区别的,比如 `String` 可以是对象的标识符,而 `string` 显然不行.~~
> 
> ~~这是因为 `String` 包装了 `string` 此基本类型.同样 `String` 构造器（`new String()` ）也是 `string` 基本类型的包装对象.(请往下看关于更多包装对象的知识或互联网搜索),即`string` 类型可以称为 `String` 的对象.~~
> 
> ~~且 `let a = 'a';` 诸如这样的声明,我们不能说变量 `a` 是属于一个 `String`类的,只能说属于`String` 包装对象或者说 `'a'` 是一个 `string` 基本类型。~~
> 
> ~~因为 `String` '类'在 JS 中可以理解为对象. 2020/1/23: 理解成对象是错误的，应该是`包装对象` 或理解为 `构造器`（`String()` ）=> 构造函数, 而对象是~~
> 
> ~~但是没有被 new 过,就不能说它是对象,即不能说此变量a是`String` 类,顶多是 `String` 类型.~~
> 
> ~~恍然大悟了吗?还纠结什么吗?~~

# 定义

## 概念

> 详情：[MDN——原始数据](https://developer.mozilla.org/zh-CN/docs/Glossary/primitive)。

在 [JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript) 中，**基本类型**（基本数值、基本数据类型）是一种既非[对象](https://developer.mozilla.org/zh-CN/docs/Glossary/Object)也无[方法](https://developer.mozilla.org/zh-CN/docs/Glossary/Method)或[属性](https://developer.mozilla.org/zh-CN/docs/Glossary/Property/JavaScript)的数据。

有 7 种原始数据类型：

1. [string](https://developer.mozilla.org/zh-CN/docs/Glossary/String) 
2. [number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number) 
3. [bigint](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt) 
4. [boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean) 
5. [undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/Undefined) 
6. [symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 
7. [null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null) 

多数情况下，基本类型直接代表了最底层的语言实现。

所有基本类型的值都是**不可改变**的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而基本类型不能像数组、对象以及函数那样被改变。

基本类型没有方法，但仍然表现得像有方法一样。当在基本类型上访问属性/方法时，JavaScript 自动将值装入包装器对象中，并访问该对象上的属性/方法。

- 例如：`"foo".includes("f")` 隐式创建了一个 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 包装对象，并在该对象上调用 `String.prototype.includes()`。

这种自动装箱行为在 JavaScript 代码中是无法观察到的，但却是各种行为的一个很好的心理模型——例如，为什么“改变”基本类型不起作用，下面是个例子：

```ts
const test = 'abc'
test.at = 1 // 将 at 方法重新赋值为 1，是没用的，
// 因为这个操作相当于让 JavaScript 将它临时植入包装器对象上的 at 方法赋值为 1 
// 而不是使 test 本身的 at 方法赋值为 1（注：基本类型是没有方法的）
// 可是当下面再调用 at 时，相当于又重新植入一个全新的临时包装器对象。
test.at(0) // a
```

## 概念拓展

### 为什么基本类型的值不可改变

> 所有基本类型的值都是**不可改变**的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而基本类型不能像数组、对象以及函数那样被改变。

将基本类型的值赋值给一个变量，然后再重新将此变量赋值，这不叫改变了基本类型的值，这只是将此变量所对应的栈内存地址的值改变了。

```ts
let name = 'yomua'
name = 'yhw'
```

上面代码中，并不是在改变原始值，而是创建了一个新的字符串值 `'yhw'`，并将其赋值给变量 `name`，从而替换了原来的值 `'yomua'`。

即：`yomua` 并没有被改变，而是被覆盖了 => `name` 变量所在的栈内存的地址，从 `yomua` 被覆盖成 `yhw`

- 需要注意的是，对于对象类型的值，其实是存储在堆内存中的。
  
  当我们对一个对象类型的值进行修改时，实际上是在修改存储在堆内存中的值的属性或者方法。
  
  因此，在 JavaScript 中，对象类型的值是可变的。

### 堆内存和栈内存的区别

可以同时参考：\<JS并发模型与事件循环-堆-栈-队列-同步异步任务-宏观微任务.md>

在计算机内存管理中，堆内存和栈内存是两种不同的内存分配方式。

- 栈内存（Stack）是指用于存放程序临时创建的变量，以及函数调用的上下文等信息的一块内存区域。
  
  每当函数被调用时，都会在栈内存中分配一个新的区域来存储该函数的局部变量、函数参数、返回地址等信息。当函数执行完毕后，这个区域就会被释放，变量也会被销毁。
  
  栈内存的特点是分配和释放速度很快，但容量有限，因为它的大小是在编译时就确定好了。

- 堆内存（Heap）是指用于存放程序运行中动态分配的数据的一块内存区域。
  
  在 JavaScript 中，所有对象都是存放在堆内存中的，包括普通对象、数组、函数等等。
  
  堆内存的特点是容量大，但分配和释放速度较慢，因为它的大小是动态变化的，需要在运行时动态分配和回收。

在 JavaScript 中，基本类型的数据是存放在栈内存中的，因为它们的值是固定的，大小也是确定的。

而对象类型的数据是存放在堆内存中的，因为对象的大小是不确定的，需要动态分配空间来存储。

需要注意的是，在 JavaScript 中，除了基本类型的数据，变量存储的都是对象的引用（指针），即：在栈内存中存储的是对象在堆内存中的地址。

因此，当我们复制一个对象类型的变量时，实际上是复制了对象的引用，而不是对象本身。

- 即：当你创建一个对象，此对象将被分配在堆内存中，而你将此对象赋值给的那个变量，将会被分配于栈内存中。
  
  而此变量的栈内存中的值为：对象在堆内存中的地址。

二者的区别：

1. 存储位置：堆和栈分别位于计算机内存的不同区域。
   
   栈内存通常位于计算机内存的较高地址区域，
   
   堆内存通常位于较低地址区域。

2. 管理方式：
   
   栈内存是由操作系统自动分配和释放的，不需要程序员手动管理。程序在调用函数时，函数的参数和局部变量都存储在栈内存中，函数执行结束时，这些数据也会自动从栈中弹出。
   
   堆内存则需要程序员手动分配和释放，当我们使用 JavaScript 中的 `new` 操作符创建一个对象时，JavaScript 引擎会在堆内存中分配一块内存来存储这个对象，当这个对象不再被引用时，我们需要手动释放这块内存。

3. 内存分配方式：
   
   栈内存的分配方式是连续的，每次分配的内存大小是固定的。
   
   堆内存则是不连续的，大小也不是固定的，分配的内存大小由需要存储

## 称呼

其基本类型可以称之为

1. 元数据
2. 元类型
3. 原始类型
4. 原始数据
5. 基本数值
6. 基本类型
7. 基本数据类型

这些称呼都不是很重要,它们都反映了一种意思,即最为基础的一种类型.我们在这里就称之为基本类型吧.

所谓基本类型是一种既非对象也无方法的数据.

- ​    ~~这里指的无方法是MDN说的,但是在JS帮助文档或者我了解中,它们是有方法的,例如String,有fromCharCode()方法等.~~

- 2020/1/16,我懂了,所谓的基本类型没有方法指的就是基本类型本身,例如:2,'string',true,null,2n等.而不是指String()构造器,或者说String()构造函数，即：<time datatime="2020-12-10 11:00">不是指各个基本类型的包装对象。</time>
  
  ​    这些数据本身不存在方法,但是它们所对应的包装对象拥有方法,而这些数据本身存于某些变量当中,
  
  ​    而这些变量又是其所对应的包装对象的实例(对象),所以这些变量就可以使用包装对象的方法,这样貌似看上去就变成了基本类型本身拥有方法了..请看以下例子
  
  ​    以创建"文字"的方式声明一个数据内容为基本类型的变量,然后这个变量可以使用一些方法.
  
  ```js
  let x = '1';
  x.toUpperCase();
  ```
  
  ​    虽然这样看好似基本类型'1'有了方法toUpperCase(),但是很显然,这不是'1'的方法,而是变量x的,变量x隐式的继承了许多其他构造器(对象)的属性/方法,
  
  ​    而变量x就可以使用这些属性/方法,但是基本类型'1'是不能使用的,你总不能直接使用'1'.xxx(); 吧?
  
  *在下面会解释什么是包装对象.*

在JS中,现(2020/1/14)共有7种基本类型,若使用typeof运算返回的值分别为:

[string](https://developer.mozilla.org/en-US/docs/Glossary/string)，[number](https://developer.mozilla.org/en-US/docs/Glossary/number)，[bigint](https://developer.mozilla.org/en-US/docs/Glossary/bigint)，[boolean](https://developer.mozilla.org/en-US/docs/Glossary/boolean)，[null](https://developer.mozilla.org/en-US/docs/Glossary/null)，[undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined)，[symbol](https://developer.mozilla.org/en-US/docs/Glossary/symbol) ([ECMAScript](https://developer.mozilla.org/en-US/docs/Glossary/ECMAScript)2016新增)。

且基本类型本身不可被改变,但可以为一个被赋值为基本类型的变量改变其存储(指向)的数据.

并且每一个基本数据类型都有之对应的构造器,也就是构造函数,它们是基本数据类型名字的大写驼峰形,例如: string基本数据类型的构造器为String(),boolean为Boolean()等等.

# 解析

## 描述

需要注意的是:基本类型本身和一个赋值为基本类型的变量的区别. 即基本类型本身是不会被改变,

但是其指向基本类型的变量实可以被赋予新值,但是这并不是改变基本类型本身的值.

### Example

```js
       // 使用字符串方法不会改变一个字符串本身
    let x = 'a';
    console.log(x); // a
    x.toUpperCase();
    console.log(x.toUpperCase()) // A
    console.log(x); // a
    x = x.toUpperCase();
    console.log(x); // A
```

1. ​     **xtoUpperCase();**
   
   ​    请注意第4行:`x.toUpperCase();` 这里调用了字符串方法,让a这个字符串变量变成大写
   
   ​     (~~同时打脸了MDN自己说的基本类型既非对象也无方法的说法,因为这个例子可以说是MDN自己举得~~.[MDN——原始数据](https://developer.mozilla.org/zh-CN/docs/Glossary/primitive))
   
   2333，2020-12-10：好吧，我错了，基本类型确实既非对象也无方法，这里之所以 x 能调用 toUpperCae()，是因为 x 实际上指向的是一个基本类型 string 的包装对象 String，而包装对象 String 是存在 toUpperCase() 的。

2. ​    **console.log(x.toUpperCase()) & console.log(x);**
   
   ​    前者输出大写A,后者输出小写a.
   
   ​        前者之所以输出大写A是因为调用字符串的此方法后,其变量x存储的数据a会被转为大写,类似重新给x了一直新值大写A替代了小写a,然后将此替代a的A输出出来,所以输出: A
   
   ​        后者之所以输出小写a,很简单,基本类型本身是不可被改变的.
   
   ​        什么意思呢? 这里输出变量x,仍然指的是 `let x = 'a';`此声明将'a'赋值给x的x.,即此x仍然存储'a'. 
   
   ​        而基本类型本身是不可被改变的,所以'a'依然是'a'',而不是'A',除非重新赋一个新值给x,
   
   ​        但是我们这里 `x.toUpperCase();`调用此方法时并没有将此方法得出新值赋值给x,所以 `console.log(x);`依然是a.

3. ​    **x = x.toUpperCase(); & console.log(x);** 
   
   ​    `x = x.toUpperCase();` 这是为x变量赋一个新值,而不是单纯的调用字符串的方法.
   
   ​    `console.log(x);`此输出: A. 因为x是被赋予了将'a'→'A'所得到的'A'值, 所以此时输出x,自然是'A',而不是a变成了A!

```js
    // 使用数组方法可以改变一个数组本身
    var foo = [];
    console.log(foo);               // []
    foo.push("plugh");
    console.log(foo);               // ["plugh"]
```

- ​    很明显,除了基本类型之外的数据本身,是可以被改变的,如同以上的例子.
  
  ​    foo数组本身是一个空数组,调用 push()方法之后,也没有进行赋值,直接输出foo, 却输出:["plugh"]
  
  ​    这代表数组本身被改变了.

## 貌似可以改变基本类型的方法

### 描述

有些方法看似可以改变某个基本类型的值,但是终究只是看似,基本类型的值不可被改改变

#### Example

```js
    let x = 5;
    function add(x) {
        x += 2;
        return x;
    }
    add(x); // 调用方法add
    console.log(x); // 5,而不是7
```

**function add(){}**

​    此方法看上去可以改变传过来的参数的值,包括基本类型的值看上去也可以改变.

​    但是真的是如此吗?很显然,既然我这里放到这里来讲,就不可能是真的. 再强调一遍:基本类型本身是不可被改变的.

​    要想知道为什么,我们需从整个JS程序的执行过程开始讲解

1. ​    首先程序会先执行 `let x = 5;`知道程序中包含有此声明(变量)
2. ​    接着 程序会跳过这些"语法糖",即不是声明语句或者输出语句(alert())等, 所以会执行`add(x)`此方法.
3. ​    当调用此方法时,JS会检查标识符x(函数的形参)的值及是哪个变量的值, 
4. ​    这样就可以从而准确无误的找到此形参接收的值的那个变量的声明语句,即找到第一行 `let x = 5;`此声明语句.
5. ​    找到此声明之后,会将其变量作为参数传递给函数的形参. 当然变量肯定也存储了其值.
6. ​    注意: 在执行函数语句之前**,JS会将其传递进来的参数复制一份(即基本类型的值或者说任何参数都复制一份),变成类似副本一样的东西,**
7. ​    而谁是副本呢?很显然,形参就是副本,就是传递进来的参数的副本.
8. ​    然后在执行其函数语句.而在其函数中,操作的所有副本(即形参)都是与外部的x变量无关,即与传递进来的参数无关.
9. ​    也就是说这个形参并不是x本身,只是一个副本而已.而外部的x实体变量是不存在能被函数内部以任何方式访问的.
10. ​    这是因为JavaScript的词法作用域所导致的变量覆盖,本地的变量(形参)覆盖了外部的变量(实体变量x).

所以以上所述,都不可能导致函数内部用任何方式或者任何操作访问到外部的变量x,因为我们操作的只是外部变量x的副本 形参x罢了.

这时候你可能会问闭包不行吗? 当然..不行,因为闭包也只不过是通过传递参数来使用实体变量的内存空间地址中的数据罢了, 也会为之创建副本,也无法操作实体变量本身.

而不用函数的方法,直接使用 **描述-Example**中的例子也无法改变其基本类型本身的数据,因为说到底, **描述-Example**中的例子也只不过是调用方法, 也会为之创建副本~

虽然无法改变基本类型本身的值,但是我们可以改变 变量所存储的值,只需要重新赋值即可(不是重新声明),也可将其基本类型本身的值销毁(释放)

**<u>所以,基本类型本身的值无法改变, 如何改变!这就是为什么说所有基本类型的值都是无法改变的。</u>**

# 基本类型对应的包装对象

## 描述

除了null和undefined以外的其他5中基本类型都有其对应的包装对象.

## 基本类型对应的包装对象

1. string 的包装对象为         String**, new String();**
2. number 的包装对象为      Number**, new Number();**
3. bigint 的包装对象为         BigInt**, new BigInt();**
4. boolean的包装对象为      Boolean**, new Boolean();**
5. symbol 的包装对象为:     Symbol**, new Symbol();**

这和在以下[7种基本类型详解]种所说的string和String是不一样的意思是差不多的.

即基本类型typeof以字符串且全小写英文的形式返回的值,如string.

​    而基本类型所对应的对象为大写,如string→String.

**而所谓的包装对象也就是说可以将基本类型变为对象,而能被包装成对象的基本类型,其返回类型都为对象,即object**

注:小写object不是一个基本类型, 这里所说的object是一个返回类型,也就是它属于什么类型,而大写Object是一个对象包装器.

请往下看:

## Example

```js
let string = new String('String');
let number = new Number('666');
typeof(string); // object
typeof(number); // object
console.log(string); // String {"yomua"}
console.log(number); // Number {666}
console.log(number.toFixed(2)); // 666.00
console.log(number); // Number {666}
...
```

- String和Number两个对象
  
  > (构造函数则是实例化/调用一个对象自动会调用的构造方法,即没有任何参数,但名字和对象名字一样的方法.)
  
  将参数String和666,这两个原始值转换(包装)成了其返回类型为object的类型.即从基本类型string number变成了object类型.

- 注意: 虽然其基本类型被包装对象包装之后变成了objec类型,但是我们可以细分的详细一些:
  
  ​    即: new String('xx')其所返回的变量的类型是属于String对象,因为返回类型object就是指Object对象.

- **console.log(string); // String {"yomua"}**
  **console.log(number); // Number {666}**
  
  ​    请注意这两个的输出结果,也侧面正面了其值是一个对象,而不是一个原始值.

- **console.log(number.toFixed(2)); // 666.00**
  **console.log(number); // Number {666}**
  
  ​    原始值即使被包装成了 对象,那么原始值依然不能被改变,只能将值赋值一个新的变量使用,而原始值不可被改变.

但是若以创建"文字（字面量字符串）"的方式声明一个数据内容为基本类型的变量,typeof返回的仍然基本类型,而不是object,因为此时的 x 指向的是一个基本类型，所以 typeof x 时，仍会返回一个基本类型：string。

但是请注意：x 变量始终并非本身就是基本类型，它只是指向基本类型而已，所以变量 x 仍可以使用基本类型所对应的包装对象 String 的属性和方法以及原型链上的任何方法/属性。

```js
let x = '1';
typeof x; // string，x 指向基本类型:string，所以它属于 string 基本类型
x.length; // 1，由于 x 并非 string 基本类型本身，所以它仍可以使用 string 的包装对象 String 的属性和方法以及原型链上的任何方法/属性。
```

# 7种基本类型详解

## 描述

请记住JavaScript是区分大小写的,string和String是不一样的意思,但是某个字符串数据是string类型或者String类型(但是不是属于或者是String对象)都是一样的意思,请看[讲在开头的一些话]

```js
let s = 's';
alert(typeof(s)); // string
```

且由于若使用typeof(返回一个字符串,使用字符串表示其未经计算的操作数的类型),则返回的是小写的string,代表a是string类型.同时也是String类型,请看[讲在开头的一些话]

但是 我们统一使用开头小写代表其操作数的返回类型,~~大写代表操作数所属的'类'~~

> ​    (但是有例外,因为基本本类型中有不是'类'的,例如BigInt,它是一个内置对象,是对象,不是'类'
> 
> ​    请注意,我这里所说的类,就是可以被new的对象(构造函数),因为JS本身没有类)
> 
> ​    而且我这里所说的'类',并不是类似Java中的类,只是为了便于理解而已,我们可以将我所说的类全换为对象也是都行的. 因为JS中其实并没有类,不是吗?

​    并且你也可以将类如 `let a = new String();` new String()这样创建的对象当作是在new一个构造函数,毕竟String()会自动调用其String函数/'类'的构造方法.

> ​    [在JS种,String就是一个函数,一个构造函数的表现形式,只是为了方便理解,将之看成'类'] 

## string

### 描述

这里用的是小写的string,代表了类型,String也可以代表. ~~而大写的String代表所属'类'.~~

## number

## bigint

### 描述

详情请看<JS帮助文档>,搜索BigInt

在JS种,BigInt是一种数字类型的数据,它可以表示任意精度格式的整数

​    注意:这里的BigInt是**<u>B和I是大写</u>**,即代表bigint返回类型,所属BigInt类型.

> 而在其他编程语言中,可以存在不同的数字类型，例如:整数、浮点数、双精度数或大斐波数。

BigInt是一种内置对象,可以表示大于2^53的整数.注意,它不属于'类',就是说它是对象,但是不是构造函数,所以不能使用new 操作符.

在JS种,Number基本类型可以精确的表示的最大整数就是2^53,而Bigint则可以表示任意大的整数.

**且BigInt变量必须是一个整数!不能是浮点数.**

### 语法

BigInt(value);

#### Example

```js
let a = BigInt(2);
typeof(a); // bigint
```

#### 解析

##### BigInt()

BigInt()不是构造函数(即不是一个类),因此不能使用new操作符.

##### Value

其创建对象的数值.可以是字符串或者数值.

### 创建bigint类型的整数

1. ​    我们可以在一个整数字面量后面加一个n的方式定义一个所属类为BigInt,返回类型为bigint的n整数. 其如同调用了BigInt()函数.
   
   ```js
       let a = 10n;
       console.log(typeof(a)); // bigint
   ```

2. 使用BigInt()函数
   
   ```js
   let a = BigInt(10);
   typeof a; // bigint
   ```

### BigInt和Number的区别

由于BigInt类型和Number类型实在是太像了,因为它们确实在某些方很类似,但是它们也有几个关键的不同点.

1. BigInt不能用于Math对象(Math也不是'类',它是一个内置对象)中的方法,因为Math不支持BigInt,Math适用于Number类型的数值.

2. ​    不能和任何Number实例(即Number对象)混合运算,除非二者都转为同一种类型,例如都转为BigInt或Number.
   
   ​    转换时需要小心,因为BigInt再转为Number变量时可能会丢失精度.这和JS进行浮点数的+法一样蠢, 0.1+0.2 = 0.30000000000000004;

#### 一些相同点

1. 都可以使用Boolean转换为boolean值
2. 二者可以互相比较

### 适用于BigInt对象的运算符

1. +

2. *

3. -

4. **

5. % 

6. ​    除 >>> （无符号右移）之外的 位操作 也可以支持。因为 BigInt 都是有符号的,  >>> （无符号右移）不能用于 BigInt。
   
   ​    为了兼容 asm.js ，.BigInt 不支持单目 (+) 运算符。

#### 使用BigInt运算

1. 若使用属于BigInt对象的变量,则带小数的运算会被取整.
   
   ```js
       const b = 5/2;
       const c = 5n/2n;
       console.log(b,c); 
       console.log(typeof(b),typeof(c));
   /*
       2.5 2n
       number bigint
   */
   ```

### 比较

#### 描述

对于BigInt和Number来说它们是可以进行比较的.

1. BigInt和Number 不严格 ===相等,BigInt和Number宽松相等 ==
   
   即在不执行类型转为时,它们二者不相等.
   
   ```js
   0n === 0; // false
   ```
   
   ```js
   0n == 0; // true
   ```

2. BigInt和Number的各自变量可以进行比较.
   
   请记住:BigInt只能是整数,若写其它浮点数则会报错:
   
   ​    A bigint literal must be an integer
   
   ```js
    console.log(1n < 2); // true
   ```

3. BigInt和Number也可以混在一个数组内并排序。
   
   ```js
   const mixNumber = [4n, 6, -12n, 10, 4, 0, 0n];
   // ↪  [4n, 6, -12n, 10, 4, 0, 0n]
   
   mixed.sort();
   // ↪ [-12n, 0, 0n, 10, 4n, 4, 6]
   ```

4. ​    被  Object构造函数('类')包装的 BigInt对象 使用 object 的比较规则进行比较，只用同一个对象在比较时才会相等.
   
   ​    即被Object包装之后,它只能严格等于它自己
   
   ```js
   0n === Object(0n); // false
   Object(0n) === Object(0n); // false
   
   const o = Object(0n);
   o === o // true
   /*
       很显然,被Object构造     函数包装的BigInt对象的变量,只有在同一个对象进行比较时才会严格相等.
       这里不讨论非严格相等==,因为没有意义,即非严格相等的情况下BigInt变量肯定都等于Number变量.前提是数值一样且为整数.
   */
   ```

### 条件

对于BigInt变量来说,在其需要转换为Boolean值时,其表现(行为)和Number类似.

```js
Boolean(0n); // fase 非0为真
Boolean(1n); // true
Boolean(-1n); // true
/* || &&再进行运算时需要转为|数值|的补码在进行判断运算 */
0n || 12n// ↪ 12n
0n && 12n// ↪ 0n
!1n// ↪ false
!0n// ↪ true
```

### 方法

1. [`BigInt.asIntN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asIntN)
   
   将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。

2. [`BigInt.asUintN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/asUintN)
   
   将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。

3. [`BigInt.prototype.toLocaleString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toLocaleString)

4. [`BigInt.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/toString)

5. [`BigInt.prototype.valueOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/valueOf)

### 属性

1. ​    BigInt.prototype
   
   ​    很显然,prototype属性是除了null之外的任何对象都拥有的属性,所以理当prototype能做的事当然BigInt也可以用它来做.
   
   ​    来为它添加属性/方法.

### 使用建议

1. 由于在Number和BigInt之间进行转换会损失精度,所以我建议只有值可能大于2^53 时仅才使用 BigInt 类型,并且不在两种类型之间进行相互转换。
2. 由于对 `BigInt` 的操作不是常数时间的，因而 `BigInt` [不适合用于密码学](https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html)。

## boolean

## null

## undefined

## symbol(2016新增)

### 描述

不用说,我想大家也都知道symbol是一个基本数据类型,但是这里我还要在全面讲解以下symbol类型.

每一个基本数据类型都有之对应的构造器,也就是构造函数,它们是基本数据类型名字的大写驼峰形,很显然,symbol基本类型也不例外.

Symbol(): 这是一个构造函数,但是它和其它基本类型对应的构造函数有所不同,因为它并不是一个完整的构造函数,Symbol()构造器无法被new,即不支持:
`new Symbol()` 这样的语法.

若使用Symbol()这个不完整的构造函数会返回symbol类型的值,该类型的值具有静态属性和静态方法.

​    它的静态属性会暴露几个内建对象;

​    它的静态方法会暴露全局的symbol注册,且类似于内建对象类.

看到这里,可能会有人问,那Symbo()构造函数有什么用处呢?不能被new,还会暴露内建对象和全局的symbol注册,新增这个基本类型和构造器的目的是什么?

**它唯一的作用和目的就是每一个使用Symbol()构造函数所返回的symbol类型的值,都能作为对象属性的标识符(对象的名字),因为此值是唯一的**,即:

```js
console.log(Symbol('foo') === Symbol('foo')); // false
```

### 语法

#### 定义

在描述中我们也稍微提到了语法表现形式,即:

`Symbol([description])`

#### 返回值

返回值就是 Symbol(description)，如：

```js
    let sym = Symbol('foo') 
    console.log(sym) // 输出： Symbol('foo') 
    console.log(typeof sym) // 输出：symbol
```

#### 参数解析

##### description 可选

可选的,字符串类型.

该参数对symbol的描述,可用于调试但不是访问symbol本身.

### 属性

众所周知,除了我们自己创建的symbol类型的值以外,JavaScript还内建了一些在ES5之前(不是ES6之前)没有暴露给开发者的symbol,它们代表了内部语言行为,

它们可以使用以下属性访问:

#### 迭代 symbols

[`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)

返回一个对象默认迭代器的方法。被 `for...of` 使用。

[`Symbol.asyncIterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator) (2020/3/9,实验性API,不要在生产环境中使用)

返回对象默认的异步迭代器的方法。被 `for await of` 使用。

### 示例

```js
const symbol1 = Symbol();
const symbol2 = Symbol(42);
const symbol3 = Symbol('foo');

console.log(typeof symbol1); // symbol
console.log(symbol3.toString()); // Symbol(foo)
console.log(Symbol('foo') === Symbol('foo')); // false 
console.log(new Symbol()); // TypeError
```

通过以上示例,我们很明显的可以发现,使用Symbol()构造函数返回的symbol基本类型的值是唯一的,且不能使用new操作符创建Symbol()构造器的实例(对象).

这里我要强调一点: Symbol()构造函数不会强制将其他基本类型转为symbol类型,因Symbol()构造函数会在你指定的description基本类型值的基础上创建一个新的值,将此值作为返回的symbol类型的值.

比如: `const symbol3 = Symbol('foo');`即'foo'这个字符串即使执行了Symbol('foo')函数,也仍然是字符串,而变量symbol3得到的是在'foo'这个字符串值的基础上创建的一个新的symbol类型的值.

在以上示例中,我们说 new Symbol();在JS编译过程中会报类型错误,因为JS会阻止创建一个显式的 Symbol 包装器对象.

即我们无法使用new操作符创建Symbol()构造器的对象,只能使用Symbol()函数创建一个新的symbol类型的值.

我提这点的原因在于: 从ES6开始,围绕原始数据类型创建一个显式包装器对象将不再被支持, 即 new String(); new Boolean; new Number()将无法创建string,boolean,number基本类型的包装器对象.

但是,因为历史遗留的原因,现如今仍然可这样创建这些基本的类型包装器对象.

- 毕竟以前的人使用new String();等基于这样的操作创建的web网页,总不能说没就没吧..这个互联网会乱套的!!!

不过,如果我们真的非常想创建一个symbol类型的包装对象 Symbol对象,该如何做呢,也很简单,使用Object()构造函数即可.

```js
var sym = Symbol("foo");
typeof sym;     // "symbol"
var symObj = Object(sym);
typeof symObj;  // "object"
```

- Object()构造函数和String(),Number()这些构造函数没什么不同,都是将指定的参数转为对应的对象.
  
  而Object()就是将指定的参数转为object类型的一个构造函数.

### 全局可用的Symbol

在示例中,使用`Symbol()` 函数的语法，不会在你的整个代码库中创建一个可用的全局?symbol类型。 

要创建跨文件可用的symbol，甚至跨域（每个都有它自己的全局作用域） , 使用 [`Symbol.for()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for)方法和  [`Symbol.keyFor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor) 方法从全局的symbol注册表设置和取得symbol。

### 在对象中查找 Symbol 属性

[`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 方法让你在查找一个给定对象的符号属性时返回一个?symbol类型的数组。

注意，每个初始化的对象都是没有自己的symbol属性的，因此这个数组可能为空，除非你已经在对象上设置了symbol属性。
