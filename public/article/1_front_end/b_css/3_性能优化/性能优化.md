# 性能优化

## [content-visibility](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility)

### 应用

- `content-visibility` 应用于要使用此属性的元素本身，而非父元素。

### 例子

```html
<style>
   .paragraph {
      contain-intrinsic-size: 110px;
      content-visibility: auto;
    }
</style>

<div class='box'>
  <div class='paragraph'> 
        1
        2
        3 
        4
        6
        7
        8
        9
 </div>
  <!-- 存在 N 个  paragraph -->
</div>
```

- 如果将 `content-visibility` 使用在 `.box` 元素上，则 `content-visibility` 不会对  `.paragraph` 元素生效，那么也就无法优化渲染。

<img title="" src="file:///Users/yanghongwei/Desktop/all/own/privatenotes/1_front_end/b_css/3_性能优化//picture/使用content- visibility但没有预估大小.gif" alt="">

*(使用content- visibility但没有预估大小)* 

- 如果没有 `contain-intrinsic-size`，用户代理不会知道未渲染的元素的大小，所以滚动条会出现忽大忽小的情况。

<img title="" src="../3_性能优化//picture/使用content- visibility并预估大小.gif" alt="">

*(使用content- visibility并预估大小)* 

如果存在 `contain-intrinsic-size`，那么即使用户代理还未渲染元素，也能预估元素大小，所以就会保持滚动条的不便。

### 总结

- 在一些需要被频繁切换显示、隐藏状态的元素上，使用 `content-visibility: hidden`，用户代理无需重头开始渲染它和它的子元素，能有效的提升切换时的渲染性能；
- `content-visibility: auto` 的作用更加类似于虚拟列表，使用它能极大的提升长列表、长文本页面的渲染性能； 
- 合理使用 `contain-intrinsic-size` 预估设置了`content-visibility: auto` 元素的高宽，可以有效的避免滚动条在滚动过程中的抖动；
- `content-visibility: auto` 无法直接替代 LazyLoad，设置了 `content-visibility: auto` 的元素在可视区外只是未被渲染，但是其中的静态资源仍旧会在页面初始化的时候被全部加载；
- 即便存在设置了 `content-visibility: auto` 的未被渲染的元素，但是它并不会影响全局的搜索功能。

#### FAQ

- `content-visibility` 对 `table` 元素及其子内容不生效。

## 更好地使用选择器

选择器是 从右->左 进行判断，如：`#a #b #c {}`，会先查找所有 `#c` 元素，然后排除掉 `#c` 的祖先元素不是 `#b` 的，最后排除掉 `#b #c` 的祖先元素不是 `#a` 的。因此，这选择器的性能没有 `#a-b-c` 好。

但是 `#a #b #c` 的权重高于 `#a-b-c`，所以，有舍有得，根据合适的情况使用选择器才是优秀的做法，而不是一刀切。

## Reference

- [掘金-性能优化](https://juejin.cn/post/6844903649605320711)
