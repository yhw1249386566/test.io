[TOC]

# 动画 P897

## 概述

CSS的过渡***(参见:<过渡.md>)***也是一种动画: 一个值变化到另一个值,中间有个过渡的过程.即:**动画包含过渡.**

虽然过渡也是动画,perspective但是过渡相对于动画来说,存在较大的局限性: 对过渡的过程没有什么控制权,只是单纯的从初始值 -> 终止,中间由系统默认,且过渡通常只持续一次,还要人为触发等.    

CSS动画和过渡的**相同点**: 元素的CSS属性值都在一段时间内发生变化,**不同点**是前者对值发生变化的过程中有较大的控制权,后者几乎没有什么控制权.

如:  从白色 -> 黑色, 过渡效果,只能眼睁睁的看着白色到黑色的过程中的颜色变化由系统决定(通常是灰色),但是**动画**则可以人为决定,即:可以控制白色 -> 黄色 -> 绿色 ->蓝色 ->... -> 黑色. **中间的过程可以任意变化**.

## 简介

- 通过CSS添加动画效果,依靠的是@keyframes规则,设置关键帧,并在关键帧设置需要应用动画的属性.

- 在@keyframes规则中,可以设置多个关键帧,每个关键帧都代表一个时间点,在每个关键帧中都可以设置需要应用动画的CSS属性,

- 每当从一个时间点到另一个时间点时(关键帧),里面的值都会发生过渡效果(可应用动画的值),直到最后一个时间点结束,那么整个动画就执行完一次.

- 动画都是应用于元素的,元素属性被改变,元素也被改变.

- **动画一旦被附加到元素上,如果没有设置animation-delay,则动画会在页面加载完毕后,就立即播放.**
  
  ​    从动画的最开始的时间点->结束的时间点
  
  PS:**如果使用JS创建动画,则当那个JS脚本被User Agent加载完毕后,则动画将立即播放,即使浏览器仍然加载中**,
  
  这很可能导致因为浏览器加载时间过长,从而导致动画已经在加载中时播放完毕. P946,倒数第4行

## 其他概念

### 定义动画和关键帧 P898

- 动画的存在是存在关键帧的前提,即:**关键帧是定义在动画中**的.

- 通过@keyframes可以定义一个动画并为之添加名字(必须的),该名字称之为动画标识符; 
  
  **每个动画都存在1个/多个关键帧块,每个关键帧块都需要有个选择符(可以理解为标识符)用来作为动画的时间点,且内部有应用动画的属性和值. ** P898

- 所谓的**关键帧块就是一个动画的生命周期内的时间点**(甚至可以认为是生命周期钩子函数),即:当在动画的持续过程中的时间点. 
  
  关键帧块的标识符的取值为:**关键字或百分数,用来作为时间点**.P898
  
  若使用其他数值,如:1s,则整个声明无效.P899

- 整个**@keyframes规则设置一个动画效果的完整迭代过程,**且迭代次数可以0次,多次,无限次.取决于:animation-iteration-count属性.  P898

- 动画的一般结构如下 P898
  
  **使用关键字作为关键帧选择符**,作为动画的时间点 P898
  
  ```css
  /** 动画开始时的值为xx,结束时为xxx,中间的过程以过渡形式展现.*/
  @keyframes anmiationName {
      from {property:value}
      to或都行 {property:value}
  }
  ```
  
  **使用百分数作为关键帧选择符**
  
  ```css
  /** 
  动画开始时,元素呈现透明状态 
  慢慢由透明状态->半透明状态
  再由半透明状态 -> 不透明状态
  */
  @keyframes anmiationName {
      0% {opacity:0}
      33% {opacity:0.5}
      100% {opacity:1}
  }
  ```
  
  **关键字和百分数混合作为关键字选择符**
  
  ```css
  /** 
  动画开始时,元素从灰色 -> 红色 
  由于该动画只存在开始和结束,所以中间效果由系统决定.
  */
  @keyframes anmiationName {
      from {background-color:gray}
      100% {background-color:red}
  }
  ```

- 关键帧并不指明动画的持续时间,那是由animation-duration属性决定.
  
  关键帧的目的只是设置:**在播放动画的某个时刻应该呈现某个状态.**

- 关键帧的选择符: from = 0%, to =  = 100%

### 关键帧选择符 P900

- 关键帧选择符指明当前关键帧块中的属性值应该应用到动画的哪个时间点上,即:动画播放到某个时刻时,希望属性为什么值. P900

- 取值为:百分数(小数或整数,不能为负值或超过100%),关键字(**不存在end关键字**,P900是错误的)
  
  若取值为百分数小数,如36.66%,表示:时间点为36.66%时,指定内部属性. :P902

- ```css
  @keyframes w {
      from {
          left:0;
          top:0
      }
  
      25%,
      75% {top:100%}
  
      50% {top:50%}
  
      to {
          left:100%;
          top:0
      }
  }
  ```
  
  注意：`animation-duration` 默认值是 0s，即动画瞬间从开始到结束。
  
  当这段动画应用到非静态定位的元素时,元素将沿着w动画指定的时间点移动. 其中w动画具有5个关键帧: from(0%),25%,50%,75%, to(100%);
  
  注意**25%和75%**这两个时间点,由于它们的**内部属性及属性值相同**,所以我将之**写在一起**, 虽然它们写在一起,
  
  但是**动画的播放顺序仍然是从低的那个时间点->高的那个时间点**(默认请情况下,即:from(0%) -> 25% -> 50% -> 75% -> to(100%); P901

- 从以上的示例中,显然得出:**动画的关键帧选择符无须按照升序排列**,你可以任意组合选择符(如果有必要的话),
  
  默认情况下,**动画依旧自己以升序方式执行动画**,就和25%和75%写在一起一样,动画并不会将75%和25%时间点中的属性执行. P901
  
  但是为了易于辨别,强烈**建议以升序方式书写关键帧选择符**.

### 省略form/0%或to/100%值 P901

- **省略开始**关键帧和**结束**关键帧**并不使动画失效**,**省略任何关键帧都不会**,只是如果0个关键帧,则动画即如同没有一样.

- 省略开始关键帧和结束关键帧,则**用户代理(浏览器)会主动自己构建开始关键帧和结束关键字,里面的属性都是可应用动画属性的初始属性值(始态).**
  
  唯一和开发者定义的开始与结束关键字有**区别的在于**: **没有人为更改**开始和结束关键帧中的属性值罢了.P901

- ```css
  div {
      backgound-color:gray
          animation-name:div;
      animation-duration:1s;
  }
  @keyframes div {
      100% {
          backgound-color:red;
      }
  }
  ```
  
  以上示例省略了开始关键帧,这代表着浏览器会构造一个里面都是(可以用动画的)初始状态属性的开始关键帧.
  
  即:当动画播放时,div元素会从灰色,经过1s的时间,过渡到红色.

### 重复的关键帧即其属性 P903

- **最初的浏览器版本中,**每个关键帧都只能存在一个,如果存在多个,则后面的覆盖前面的,
  
  **现在则不同**,如果存在多个相同的关键帧选择符,则后面的关键帧将会和前面的关键帧层叠,
  
  即: **如果两个关键帧中存在一样的属性,则后面覆盖前面的属性,如果不存在一样的属性,则它们两个层叠.** P903

- ```css
  @keyframes div {
      from,
      to {
          top:0;
          left:0
      }
      100% {
          top:100px;
      }
  }
  ```
  
  以上示例中,to和100%两个关键帧是同一个时间点,所以它们两个会层叠,即:相同的属性,后面覆盖前面; 不同的属性,则层叠.
  
  在这里: 100%中的top将会覆盖to中的top, 而left不会被覆盖,也仍然被100%使用.
  
  这里的100%将覆盖to里面的相同属性,层叠不同属性.P903

### 支持动画的属性P903-P904

### 不支持动画但不被忽略的属性 P905

- 通常来说,对于不支持动画的属性,将被浏览器直接忽略.但是存在不支持动画,也不会被浏览器忽略的属性.
  
  即:visibility和animation-timing-function属性. P905

- visibility:hidden和visibility:visible之间没有中间点,按理说会被浏览器忽略,但却没有被忽略.
  
  当该属性被应用于关键帧中时,它会直接从hidde 跳转到visible,但是反过来visible->hidden却不成立,即它会永远为visible. P905
  
  ```css
      @keyframes visible {
          0% {
              visibility: hidden;
          }
  
          25%  {...}
  
          100% {
              visibility: visible;
          }
      }
  ```
  
  使用visible动画的元素,将会忽视时间点,直接从第一个开始且存在visibility属性的关键帧 跳转到下一个存在该属性的关键帧中.
  
  简而言之: **只要存在visibility:visbile则,元素就不会hidden,即使最后一个关键帧的visibility:hidden也一样;**
  
  **反之不存在visible,只存在hidden元素就会隐藏.**
  
  PS: hidden ->visible,会导致元素会闪一下,而visible->hidden则不会.

- animation-timing-function也不支持动画,但是不会被忽略. P905
  
  因为**该属性可以在关键帧中,设置当前属性的值到下一个属性的值时,应该用什么时序函数来进行过渡**. P934

### 通过脚本编辑的@keyframes动画 P905-P906

暂时不需要.2020-5-31

- 可以使用appendRule("时间点{属性:值}")和deleteRule("时间点") API 对一个元素的动画中添加关键帧及里面的属性.

### 把动画应用元素上 P906

- 上面我们已经知道如何创建动画以及关键帧,知道动画的完整执行过程,现在我们需要将动画附加到元素上,否则动画将不会被执行,因为没有宿主.

- 把动画附加到元素上才存在两种方式: 
  
  通过JS方法
  
  通过CSS方法
  
  ​    CSS方法又分为两种:
  
  ​        简写的animation属性
  
  ​        单独的animation-XXX属性
  
  ​        这种情况和transition及transition-XXX类似,注意:过渡的简写属性无法单独的属性混合写, 动画也是如此.

- 详见下一节.

### 动画链 P918

- 动画链指: 使用**animation-delay属性**,将多个串在一起的动画(animation-name)使用延迟,让后一个动画在前一个动画结束后播放.
  
  从而**让多个串在一起的动画一个个播放**,而这种播放形式就是动画链.

- ```css
  div[class$=.png] {
      animation-name:a, b, c;
      animation-duration:1s, 3s, 5s;
      /** 每个动画在前一个动画结束后播放 */
      animation-delay:0s, 1s, 4s;
  }
  ```
  
  显然的, a动画立即播放,持续1s; b动画延迟1s,再播放,持续3s; 
  
  c动画延迟4s,持续5s; 这样每当前一个动画结束后,后一个动画就会刚好开始.

- 下面使用简写属性,实现动画链(这个更简单,更清晰)
  
  ```css
  div[class$=.png] {
          animation:
              a 3s 0s 1 linear forwards,
              b 5s 3s 1 linear forwards,
              c 7s 8s 1 linear forwards;
  }
  ```
  
  显然的,我们发现,实现**动画链**很简单,只需要**后一个动画的延迟时间 = 前一个动画的持续时间 + 延迟时间** 即可. P919

- 使用这种方式,我们可以做到多个串在一起的动画,中间可以有着不同的延迟时间,同样的,也只需要改变delay属性的值即可.

- 除了使用animation-delay这种CSS属性的方式做到动画链,同时,我们也能**使用JS的方式做到动画链**.
  
  即: 使用**animationend事件, 判断每个动画结束后,再为同一个元素附加下一个动画**,以此类推,这样就能形成动画链.
  
  不过使用**CSS的方式实现的动画链性能更好,也更合适**P919

### 动画的性能 P919

- **动画在UI线程中的优先级最低**,因此,如果运行的脚本占用了用户界面(UI)线程,
  
  **特定**的浏览器在处理有动画效果的特定属性和值时**将忽略延迟**(animation-delay),**等到UI线程空闲时才开始播放更多的动画**.P919
  
  即:即使**延迟时间到了,也不会播放动画,需要等到UI线程空闲**.

- 对于动画来说,并不是所有动画都在UI线程中执行,即由CPU执行动画,
  
  多数浏览器中,应用**opacity和transform属性制作的动画,它们会由GPU执行**,
  
  这也就是说,这两个属性制作的动画将**不受到UI线程的影响**.P919

- 如果在**支持3d变形**的浏览器或设备中,**把一个元素放入3d空间**(transform-style:preserve-3d),那么**它会处于一个单独的层中**,由**GPU去执行这个层中动画效果(即transform)**. P919

- 你可以使用**一些技巧将元素放入3d空间**,从而**让该元素的动画被GPU执行**,从而不受到UI线程影响,这样**动画效果将不存在卡顿(不会受UI线程被脚本阻塞影响）**.P919
  
  但是**不要使用以下技巧:**
  
  ```css
  /** 所有元素都放入了3d空间 */
  * {
      transform:translateZ(0);
  }
  ```
  
  我们可以将部分元素放入3d空间,让GPU去执行动画效果,但是如果把太多的元素放入3d空间,你要知道,有些设备的视频内存是有限的,
  
  而**每个单独的3d空间都要消耗视频内**存,而且**每一次将元素放入3d空间,都需要花费一定的时间从UI线程中移到GPU合成的层里**(3d空间里) 
  
  所以太多的元素放入3d空间,会导致视频内存被消耗一空,且会花费大量时间将元素移入GPU制造的层中,从而大致卡顿.
  
  P919

- 为了**提升性能**,只要可能,就**应该把transform和opacity放入动画之中**,而**top,left,right,bottom,visibility则不要这么做.** P919
  
  因为**如果修改盒模型属性(就是以上的这些属性),浏览器都要重新排布和绘制整个页面,这对性能是不利的**.
  
  **不要一股脑的将所有属性都给GPU,这会遇到新的问题.** P919

### 模拟动画间迭代的延迟 P922

- 意思为: 假如我们想**播放多次动画**,但是想让**每次迭代之间(第1次到第2次迭代中),存在一定延迟,而不是上一个迭代完,下一个就立马迭代.** P922

- 动画之间的迭代不存在延迟,即不存在animation-iteration-delay这样的属性,但是我们可以通过一些技巧赋予迭代之间存在延迟.P922

- 可以通过在动画中巧妙的设置时间点和内部属性的方式,达到每个迭代中有延迟的效果.
  
  ```css
  div {
      animation:dmeo 5s 0s 3;
  }
  @keyframes demo {
      80% {
          transofrm:scale(1);
      }
      80.1% {
          transofrm:scale(1);
      }
      100% {
          transofrm:scale(3);
      }
  }
  ```
  
  以上示例: 当div元素播放动画时,前面的**0% -> 80%的过程中,元素将不会被改变**,只有到**80.1%->100%这个过程中,元素才开始被改变.**
  
  这样该动画的**第二次迭代**(如果animation-timing-function:normal)时,**也要等到0%->80%的时间,元素才会开始变化.**
  
  这样在**体验时,就相当于动画的每次迭代中,存在0%->80%这个时间延迟.** P923

- 以上的办法是可以做到迭代间存在延迟,但是这样会造成动画中有一段时间是空白的,没有用的,而这是浪费资源的行为.
  
  所以我们除了以上办法,还可以**通过重复使用同一个动画,然后巧妙地使用animation-delay属性的值**,这样**就可以造成类似于动画的迭代间存在的延迟效果.** P924
  
  ```css
  div {
      animation:
          dmeo 5s 0s 1,
          /** 等待上一个动画结束10-5=5s后播放 */
          dmeo 5s 10s 1, 
          /** 等待上一个动画结束15-10=5s后播放 */
          dmeo 5s 15s 1;
  }
  @keyframes demo {
      to {
          transform:scale(2);
      }
  }
  ```
  
  以上示例: **重复应用同一个动画**, 并使得animation-delay属性值为0s,10s,15s; 这样根据动画的持续时间判断, 下一个动画需要等到上一个动画结束完成,再等待5s后,才能开始播放.
  
  这样**由于都是同一个动画在播放,就当与一个动画中迭代了3次一样,而每一次之间都有5s的延迟**. P924

- 使用**重复应用多次动画,通过animation-delay设置每次动画中间播放的延迟时间,从而达到类似于一个动画中迭代之间的延迟效果** 的方式,**是最为安全,最为可靠的方式.** P925

- 当然了,也可以**通过animationend事件,在该事件处理程序中,拆离某个元素上的动画**,再通过如setTimeout函数,**隔n毫秒后,再重新附加动画,这样就重启了该元素上的动画,延迟为n毫秒.** P925
  
  也是类似于以上的方式,但是**通过脚本可以无限的让一个动画播放,并且迭代之间存在延迟时间.**
  
  ```html
  <div class="iterationDelay" id="div"></div>
  
  <style>
      .iterationDelay {
          animation:
              iterationDelay 5s 0s 1;
      }
  </style>
  
  <script>
      let iteration = 0;
      let el = doucument.querySelector('#div');
      el.addEventListenr('animationend',()={
          // 每隔多少毫秒重启动画,
          // 相当于动画中两个相邻的迭代之间有多少延迟.
          var time = ++iteration * 1000;
          // 当动画结束后类选择符,即删除动画,因为在类选择符中使用了动画属性,为元素附加动画.
          el.classList.remove('iterationDelay');
          // time毫秒后,重新添加类选择,即重新添加动画.
          window.setTimeout(()={
              el.classList.add('iterationDelay')
          }, time)
      },{'capture':false})
  </script>
  ```
  
  通过以上的示例,我们**使得相同的动画每隔time毫秒**后*(这里每次重启动画,动画之间的延迟都加1s)* **被重启**,
  
  这样就**相当于每隔time毫秒后,动画又再一次被迭代,使得两个迭代之间存在延迟.** P925
  
  并且这里通过JS，实现了无限迭代动画,并且每次迭代之间有延迟.

### 动画的优先级 P945

- **动画中的关键帧中的属性默认行内声明的优先级**,即1 0 0 0
  
  **所以关键帧中的属性能被外面的属性!important 覆盖**
  
  但是**截至2020-5-21,并不是所有浏览器都这么做,只有Firefox会这么做**
  
  PS:**这是规范要求的行为,但不是所有浏览器都实现了**. P945
  
  **这是个bug,我相信以后会解决的.**
  
  注意**:不要在动画中使用!important,会导致整个属性声明失效**(没有意义)

### 癫痫和前庭功能失调 P947

- **动态变化的内容可能导致某些用户癫痫发作 ,所以为了避免这一点,请使用:媒体查询符号:prefers-reduced-motion**
  
  ```css
  @media (prefers-reduced-motion) {
      * {
          animation:none!important;
          transition:none!important;
      }
  }
  ```
  
  prefers-reduced-motion:  查询用户设备是否设置了 "减少运动效果"或类似偏好的设置.
  
  如果有设置,则将动画和过渡效果全部设置为none.

- 当然了,我们还可以只为没有设置prefers-reduced-motion的用户,添加动画和过渡
  
  ```css
  @media not (prefers-reduced-motion) {
      * {
          animation:none!important;
          transition:none!important;
      }
  }
  ```
  
  如果你想了解媒体查询,***参见:\<页面的适配@media和@support.md>***

### 动画及事件前缀 P947 - P949

## 动画的八大属性

1. animation-name
2. animation-duration
3. animation-iteration-count
4. animation-direction
5. animation-dealy
6. animation-timing-function
7. animation-paly-state
8. animation-fill-mode

### animation-name

- 指定元素需要附加动画的名字.
  
  取值: **1个或多个动画名字 | none**.
  
  当应用多个动画名字时,需要**以逗号分割**,且**每个动画在默认情况i啊同时播放,并且该属性允许应用多个同一个动画名字**(目的是:如果能在每个动画之间添加延迟,则可以重复使用相同的动画效果,又或者其他目的) P907
  
  `animation-name: a, a, b, c;`

- 如果使用多个动画名字,当有**两个及以上的动画同时播放时**,如果存在不同的动画之间,**相同的时刻有着同样的属性值一起应用动画效果**,则在**逗号分隔的列表中**排名**较后的会覆盖前面的相同属性**. P908
  
  ```css
  @keyframes a{from {width:200px}}
  @keyframes b{from {width:300px}}
  div {
      /** a中的width属性值将覆盖b中的width属性值.*/
      animation:b, a;
  }
  ```

- 如果在该属性的逗号分隔列表中,**存在一个无效声明动画名字**(标识符),**不会导致所有动画都无法应用,只是无效/不存在的动画不能使用.**
  
  但是如果**通过某种方式(如JS),导致那个动画可以使用**,则在**变有效的那一刻起,那个动画又会开始应用**. P907

- 当使用animation-name属性应用的动画**不存在开始或结束帧时**,
  
  则**旧版浏览器在播放那个动画**,默认情况下: 从**初始值->0% 或 100%->初始值**时, 这**一瞬间会是透明的**,表现形式为:闪烁一次*(这和在关键帧中应用visibility属性差不多,**详见:不支持动画但不被忽略的属性**)*
  
  而**新版浏览器,则不会显示透明**,而是**将动画属性的中间值作为过渡值**使用在 初始值->0% 或 100%->初始值 这一过程中. P909

- 如果**只为元素附加动画**,而**不添加动画持续时间**,则动**画会瞬间结束**,**即使动画可以迭代无数次并且能触发animationstart和animationend事件也一样**. P909

### animation-duration P910

- **指定一个动画从开始到结束,需要花费多久,即动画的持续时间.**`
  
  取值: **1个或多个以逗号分隔的时间**,单位: 秒或毫秒. P910
  
  **默认值为0s**,即动画**瞬间开始和瞬间结束**,会**触发animationstart和animationend事件.**
  
  其功能类似于transition-duration. P874
  
  `animation-duration: 1s,2s,3s,400ms;`

- 不能存在没有单位的值,如:0,1,2这些都是错误的,会使整个声明无效P910

- 如果animation-**duration的值 < animation-name的值,则会成组复制duration的值,然后从左->右开始使用复制的值**.
  
  如果**duration > name值,则忽略多余的部分**. P910.
  
  注意**:animation-delay,animation-iteration-count属性也是如此P912** (亲测) . P910
  
  这和transition-duration/delay/property一样,过渡属性也是一一对应的. P876
  
  ```css
  div {
      /** height和width都持续5s和延迟1s播放 */
      animation-name: height, width;
      animation-duration: 5s;
      animation-delay: 1s;
  }
  ```

- **animation-duration及animation-delay**属性和**animation-name是一一对应关系**. 
  
  ​    *这和transition-duration及transition-delay和transition-property一样* ***(参见:<过渡.md>)***
  
  ```css
  aside {
      animation-name:a,b,c;
      animation-duration:1s,2s,3s;
      animation-delay:1s,2s,3s;
  }
  ```
  
  以上示例中:三个动画分别持续1s,2s,3s,分别延迟1s,2s,3s 

- 使用animation-duration属性值,若**值中存在一个无效值,则整个声明无效** P910
  
  ​    这和animation-name不同*(一个值无效,只是会忽略那个无效值,其余有效值仍被应用)*

- 如果animation-duration**对应的animation-name的动画名不存在**,animation-**duration和name属性不会失效**,不存在的动画及持续时间将**被忽略**,**其余有效值仍然继续被使用**. P910
  
  ```css
  div {
      /** b动画不存在 */
      animation-name:a,b,c;
      animation-duration:1s,2s,3s;
      animation-delay:1s,2s,3s;
  }
  ```
  
  假设这个示例中,b动画不存在,则持续时间和延迟时间的2s都会被忽略,b动画也会被忽略,但是它们所在的属性不会失效,其余有效值仍然将被应用.
  
  如果后来**b动画又出现了**,则**对应的持续时间和延迟时间都将重新应用到div元素的动画上**. P910

### animation-iteration-count P911

- 该属性指明**动画播放几次**,即动画的迭代次数.

- 取值: [number | infinite]#,多个值之间以逗号分隔,且number类型的值**可以为小数**,如2.5,3.33等.
  
  **默认值为:1**. P911.
  
  如果**取值不为整数**,则**动画会在最后一迭代中途结束**,**中途的哪个时候取决于小数部分**,如 x.5,则在最后一次迭代的一半结束; 0.3,就是1/3时结束. P911
  
  不能负数,也不能有无效值,否则将整个属性重置为默认值: 1. P912

- 该属性值为**0也是有效值,只不过动画依然播放**,**不过会瞬间结束**,**如同animation-duration:0s一样**,也会**触发animationstart和animationend事件.** P911

- 可以通过该属性**使同一时间播放但持续时间不同的动画,在同一时间结**束,只需要让它们的 **持续时间*迭代次数+延迟时间都相等**即可.
  
  ```css
  .flag {
      animation-name:a, b, c;
      animation-duration:2s, 4s, 6s;
      animation-iteration-count:6, 3, 2;
      animation-delay:0s;
  }
  ```
  
  以上示例中,a, b, c动画都延迟0s, 总共播放12s => 2 * 6 = 4 * 3 = 6 * 2;
  
  P912
  
  PS: 对每**个动画单独使用延迟也可以做到这一点**, 只需要让它们的 持续时间*迭代次数 + 延迟 相等即可(我们只需要改变延迟).

### animation-direction P912

- 该属性指定动画的播放方向.

- 使用animation-direction属性能控制动画是从(取值):
  
  *0%->100%*,**normal**
  
  还是*100%->0%*开始播放, ** **
  
  或者是*奇数次播放从0%->100%,偶数次播放从100%->0%*,**alternate**
  
  又或反过来: *奇数次100%->0%,偶数次0%->100%*.**alternate-reverse**
  
  这些都可以通过我加粗的关键字控制. P913

- 如果想让动画从开始->结束，并从结束->开始，则：
  
  ```css
  .flag {
      animation-name:test;
      animation-duration:1s;
    animation-iteration-count:2; // 迭代两次
    animation-timing-function:alternate; // 第一次 0%->100%, 第二次 100%->0%
  }
  ```

### animation-delay

- 该属性指定将动画附加到元素上时,需要等待多久才开始第一次迭代.

- 使用**该属性可实现"动画链"**P918. ***详见:其他概念 - 动画链***

- 取值和animation-duration一样,是时间值,单位必须为s / ms,且能为小数.
  
  但是有一点取值和duration不同,**delay的取值可以为负数.**
  
  如: -2s, -2000ms;

- 如果该属性的**取值为负数**,则动画**立即开始播放,并触发animationstart事件**,
  
  有意思的是,虽然**动画立即开始播放,但是却是从动画的中途开始**. P915
  
  ```css
  div {
      animation-delay:-4s;
      animation-duration:10s;
  }
  ```
  
  div元素的动画,将从40%(4s)的时间点开始播放,并在6s后结束. 
  
  动画**因为负延迟还能持续多久计算方式**为: **负延迟时间 + 持续时间 = 动画还能持续多久.**
  
  所以这个示例,动画还能持续: -4s + 10s = 6s*(即:6s后动画结束).*  
  
  **延迟为负几秒,就从动画的几秒开始播放,结束时间则是它们两个之和**. P915

- 如果**存在迭代次数,delay为负值,则可能会减少迭代次数.**
  
  ```css
  div {
      animation-delay:-600ms;
      animation-iteration-count:10;
      animation-duration:200ms;
  }
  ```
  
  在以上示例中, 迭代次数为10次,持续时间200ms,即总共持续:2000ms;
  
  由于延迟时间为-600ms, 即-600ms + 2000ms = 1400ms*(动画还能持续1400ms,即:动画1400ms后结束).*
  
  而-600ms / 200ms = -3*(600ms中能迭代200ms的动画3次)* , 所以该示例的动画将从**第4次开始迭代***(第1,2,3次已经迭代完成了)*.
  
  所以:
  
  ​    如果**存在迭代次数,且延迟时间为负数**,则:
  
  ​    **想求因为负延迟已经迭代完成的次数的公式**为: 
  
  ​        **负延迟时间 / 持续时间 = 负延迟时间中能迭代持续时间为n(s/ms)的动画几次**. P915
  
  ​        这里求出的答案,是会直接因为负延迟而被迭代的动画的次数.当然了,如果**动画迭代无限次,这个公式就没有意义**.

### animation-timing-function P925

- 该属性**指定动画的时序**,即指定动画**播放过程以什么样的方式**(**贝塞尔或步进函数)进行播放**. P925
  
  和transition-timing-funcition是差不过的. P877

- 取值
  
  ease 先慢 再快 再慢
  
  linear 匀速播放动画
  
  ease-in 缓入快出
  
  ease-out 快入缓出
  
  ease-in-out 缓入缓出
  
  cubic-bezier(number,number,number,number); 贝塞尔曲线
  
  steps(integer,end/start) 步进函数
  
  step-end/start  步进函数
  
  看似取值很多,实际本质就两个**: 贝塞尔曲线**和**步进函数.**
  
  **从ease -> ease-in-out实则是贝塞尔曲线,只不过CSS内置了而已.**
  
  s**tep-end/start实则是steps(1,end/start)**罢了,不过是看着清楚一点罢了. P926

- 时序函数不支持动画,但是它不会被忽略,它可以改变一个关键帧中的属性应用的时序函数. P934-P938
  
  ```css
      @keyframes timing {
          0% {
              width: 200px;
              animation-timing-function: linear;
          }
          50% {
              width: 400px;
              animation-timing-function: 
                  cubic-bezier(1, -0.24, 1, 1);
          }
  
          100% {
              width: 600px;
          }
      }
  ```
  
  在**关键帧中改变当前动画的时序**,则时序函数会在 **当前值 -> 目标值的过程中触发**,**用的是当前关键帧中的时序函数**.
  
  且时序函数**只会应用在当前关键帧中已经存在的(动画)属性上.**
  
  ​    也就是说:如果当前**关键帧中有时序函数X,存在A属性,不存在B属性**,那么当下一个关键帧的**具有**另一个值变化的**A属性**,
  
  ​    和一个值变化的**B属性时**,**只有A属性会使用时序函数X,**而**B属性仍然使用的是初始时序函数**(可能是在元素本身上定义的)

- 在动画的关键帧中改变时序函数有什么用呢? 它可以让有些动画更加真实,让有些动画更加具有趣味性等P937

#### 贝塞尔曲线

- 贝塞尔曲线很简单,它是一条二维线条,从一端->另一端,中间可以呈现弧度,可以参见:[该网站](https://cubic-bezier.com).

- 贝塞尔曲线cubic-bezier(x,y,x,y)的**x值只能为[0,1],超出该值无效.**
  
  而**y值可以是任意值**,只要是数值就行,即使为负数也可以.
  
  **负数的y值会让贝塞尔曲线往下沉,导致在播放动画时,元素属性的值会忽大忽小.** P927
  
  cubic-bezier(.44,1.71,.74,-0.93)
  
  以下的贝塞尔曲线中**红色圆圈的部分,就是-0.93**,这会导致应用该贝塞尔函数的关键帧中的属性值变小.*(是的,虽然时序函数不支持动画,但是它不会被忽略,它可以改变一个关键帧中的属性应用的时序)*
  
  ![](/picture/贝塞尔曲线的y值为负.png)

#### 步进函数

- 步进函数是非常有意思的时序函数**,它的功能就如同连环画一般**,让**上一帧到下一帧之间的过程,使用连环画的形式进行播放**,而不是用一种很平滑的方式进行过渡. P930

- 或者你可以**将步进函数理解成翻书**, 书的**封面和尾面是两个关键帧**,而**中间的页面则是过程**,
  
   当**从书的封面快速翻页到书的尾面时**,**翻页过程中的每张页面都会被快速翻过**, 
  
  此时**如果每张页面存在一张相同人物但是动作不同的照片**, 那么**在快速翻页的过程中,就会形成连环画的效果**.
  
  你可以观察以下动图中的红色矩阵,实际上红色矩阵并没有动,动的是小人,这样**每次翻页只翻一个小人的宽度,就可以形成小人好像在动一样.** P930
  
  ![](/picture/步进函数示例.gif)
  
  ```css
  img {
      animation: 
          dance_in_place 5s 0s infinite 
          steps(22, end);
          position: relative;
  }
  
  @keyframes dance_in_place {
      from {left: 0;}
      to {left: -1232px;}
  }
  ```

- 我们通常将上面的小人图片(**稍有不同的多张途相放在一张大图中),称之为子图集**. **子图集中的每个图像是动画中的每一帧.** P930

- 请注意**steps(22,end)** 这个步进时序函数,
  
  它的**第一个参数**,通常是**子图集中存在多少图像的数量**,
  
  **第二个参数则是指明动画会直接播放0%->下一帧**,还是**等 每翻一次页(执行的步长时间)需要执行的时间 后,在开始播放动画.** 
  
  ​    即start / end
  
  ​    **start: 动画开始后立即进行播放动画**
  
  ​    **end:动画开始后,先等待 每翻一次页需要执行的时间 后,在开始播放动画**
  
  P931 , P932

- step-start == steps(1,start); step-end == steps(1,end);

### animation-play-state P938

- 该属性指定动画的播放状态,即暂停还是播放.

- 取值: running | paused
  
  如果存在多个值,则要以逗号分隔. P938

- 该属性只能使用在元素或为元素上,而不能使用在动画的关键帧中.

- running: 动画继续播放 (也是默认值)
  
  paused: **使元素上指定的动画暂停**, 如果在迭代中途通过JS在暂停了动画,那么**已经发生变化的属性停在当前的值**. 
  
  **并且如果再次将设置paused的动画变成running,则动画会从停止的位置继续播放**. P938

### animation-fill-mode

- 该属性指定动画的填充模式.
  
  取值为: none | forwards | backwards | both 
  
  如果存在多个值,则以逗号分割.

- 指定动画的填充模式的意思是什么呢,即:一个动画在播放完毕后,它的属性将会回到初始状态(页面刚加载时的值).
  
  但是通过animation-fill-mode属性,我们可以更改这一设置,**让动画在结束并触发animationend事件后,使元素的属性保留在最后执行的关键帧上. 即通过: forwards.** P939

- **backwardes**: 让**动画中的开始帧**: 0%或from关键帧(如果有的话)**中的属性立即应用在元素上,无视animation-delay属性.** P939
  
  默认情况下: 需要等待animation-delay属性过后,触发animationstart事件,动画的第一帧才会被应用.

- **both**:  使动画即有forwards效果也有backwards.

- **none**: 没有填充模式.
  
  - 注意: **如果动画通过animation-direction属性改变了动画的方向,reverse值**
    
    **backwardes**: **让动画的开始帧无视animation-delay的值立即应用的元素上**. (在这里即开始帧为: to或100%)
    
    **forwards:** **动画结束触发animationend事件后,让元素保留在动画的最后指定的关键帧中**. (这里为0%或from)

## 将八大属性写为一个属性animation P941

- animation, 取值为:
  
  八大属性的取值, 如果存在多个值则以逗号分隔（下面末尾的逗号）
  
  注意:这里指定多个值,**是指应用了 多个 不同的八大属性值**.
  
  如:
  
  ```css
  animation: 
      name 1s infinite normal 0s ease-in-out running none,
      yomua 1s infinite normal 0s ease-in-out running none
  ...
  ```
  
  P942

- 该简写属性类似于transition P885, 第一个出现的时间单位参数代表动画的持续时间,第二个出现的代表延迟时间.
  
  如果只是单独的数字,没有单位,则代表迭代次数.

- animation属性中的取值不需要全写出来, 省略不写的会自动使用默认值, 且animation属性中的值的顺序是任意的. P942

- 正**由于存在animation属性,所以我始终不建议将animation-name的名字设置为关键字**,如none或ease,pasued等,虽然你可以这么干,
  
  但是这**可能会导致浏览器再识别你这个属性值时,将你这个属性值认为是别的属性的关键字**:
  
  ```css
  div {
      animation:e
          ease 1s 2s 3;
  }
  ```
  
  以上示例中,ease是这个动画的名字,但是浏览器会认为ease是animation-timing-function属性的值,这会导致出现预料之外的后果.
  
  **把动画的名字(@keyframes identifier)的值设置为关键字,除非你是疯了** P942,P943

- 如果开发者不小心把动画名字设置为如:running这样的关键字(虽然开发者可能不知道),可能会导致浏览器错误的识别,
  
  而解决这种问题的方式时,将animation所有的取值列出来,并将动画名字写在最后*(很多人喜欢写在最前面,这样更容易阅读),* 
  
  因为如果动画名字和关键字相同,则**浏览器会将第一次出现的值认为是关键字,第二个才会认为是动画名字**. P944
  
  如果你觉得麻烦的话,就小心使用动画名字,不要将之设置为关键字.

## 动画的三个事件 P916

1. animationstart
2. animationend
3. animationiteration

### animationstart事件 P916

- **animationstart事件在动画开始时进行播放,如果有延迟(animation-delay),那么就等延迟过后,动画开始播放时才触发.**
- 如果animation-delay的值为负值,则animationstart事件立即被触发. 即:

### animationend事件 P917

- **animationend事件在动画结束时触发.**
- 如果animatin-iteration-count的值为infinite,则该事件永不触发.
- 如果animation-duration的值为0s,则通常来说,animationstart事件和animationend事件同时触发.(即使迭代无数次也一样)
- animationend事件不会和animationiteration事件痛时触发,animationend事件的优先级>animationiteration事件. P917

### animationiteration事件 P917

- animationiteration事件在一个动画的两次迭代之间触发,也就是说:动画第一次迭代完后,第二次迭代前,会触发该事件.
- 如果再一次迭代之后会触发animationend事件,则animationiteration事件不会触发,也就是说:animationiteration事件和animationend事件不会同时触发.
- **只要一次迭代(即使不是完整的迭代)结束后又开始下一次迭代,并且这个新迭代的持续>0s,那么animationiteration事件就会触发** P917
- 如果**因为**animation**-delay的值为负值**,导致**动画实际的迭代次数小于animation-iteration-count的**值,则**没有被实际迭代的循环不会触发animationiteration事件.**
