# [类型操作](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)

## [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)

取出指定类型的 key。

keyof Type 将是一个联合类型（`a | b`）

```typescript
type Point = { x: number; y: number };
type P = keyof Point;
// type P = 'x' | 'y'
```

## [typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)

在 TS 中，使用 typeof 引用变量/属性的名称将得到它们的类型。

```typescript
const s = "hello";
let n: typeof s;
// let n: string
```

NOTICE: 对于 TS 的 typeof 来说，仅在变量名上使用是合法的，这表明以下 typeof 的使用是错误的：

```typescript
let shouldContinue: typeof msgbox("Are you sure you want to continue?"); // ❌
```

## [索引访问类型](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

### 正常使用

你可以通过类似获取对象的值的方式，用在类型上，从而得到指定类型键的类型：

```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
// type Age = number
```

### 使用关键字 `number` 访问类型

关键字 number 用于获取数组中每个项的类型，它会取出数组中每一个值的类型，用 | 分隔(即把它们认为是联合类型)，取出每个值类型时存在两种情况。

1. 如果数组中值的类型一模一样，那么就认为是一个类型。

```typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
];
// 使用关键字 number
type Person = typeof MyArray[number];
/**
  type Person = {
      name: string;
      age: number;
  }
*/
```

2. 如果有多个属于同一个类型的值，但它们子项的类型不同，则使它们的类型趋于一致，并用 `|` 分割。
   
   即：将它们所有的类型整合，并合并到每个项，合并时，将当前子类型中**不存在的类型认作是可选类型**。
   
   如下所示：

```typescript
const MyArray = [
  666, // number
  'yomua' // string
  [], // any[]
  { love:'yhw' }, // object{love: stirng}
  { name: "Eve", age: 38 }, // object{name: string, age: number}
];
type Person = typeof MyArray[number];
/**
  type Person = number | string | any[] 
    | {love:string, name?:string, age?:number} 
    | {name:string, age:number, love?:string}
*/
```

- `{ love:'yhw' }` 和 `{ name: "Eve", age: 38 }` 是属于一个类型：object，但它们的子类型不同。
  
  所以 `number`  访问数组类型时，将让它们趋于一致，并以 `|` 分割 -> 
  
  `{love:string, name?:string, age?:number} ` 和 `{name:string, age:number, love?:string}`

## [映射类型](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

### 概念

映射类型是一种泛型。

我们可以将之理解为：**让指定 key 转成指定类型。 key 只能 number | string | symbol（一个确定的唯一值）** 

映射类型使用关键字 `in` ，基于【索引签名】，并且只能使用于 `type` 声明的类型中。

```typescript
// 将字符串索引签名匹配的值转为 boolean 类型。
type Yomua = {
  // AnyName 相当于一个临时变量，它代表 Info 中的每一个 key
  [AnyName in string]: boolean // 匹配 key 类型是 string 的值，将之转为 boolean 
                                                           // 这其实等同于：[key:string]: boolean
}

let data: Yomua
data = [] // ERROR 这里的是字符串索引签名, key 只能是 string，而不能是 number
data = {
  a: true, 
  b: false,
  c: 'yhw', // ERROR, 只允许 boolean 值
}
```

通常情况下，映射类型和 `keyof` 一起使用：

```typescript
type Options<Info> = {
  // 遍历 Info 的每个 key, 并用 value 本身的类型作为类型。
  // e.g. [Property in name]: string； 即：匹配 key 类型是 name 或 hobby（此处 name, hobby 指的是 key，即：用 key 作为类型），并将值的类型转为其值本身类型
  // 即：也就是使用 【索引访问类型】获取到 指定类型的 键的类型。
  [Property in keyof Info]: Info[Property]
}

interface MyInfo{
  name: string, 
  hobby:{
    one: string
  } 
}

let data: Options<MyInfo>
type data = {
  name: string
  hobby: {
    one: string
  }
}
```

`in` 关键字后面只能是 `string | number | symbol`，否则该接口报错：

```typescript
type CreateMutable<Type> = {
    [Property in Type]: any // ERROR, Type 'Info' is not assignable to type 'symbol'.
}

type CreateMutable<Info> = {
      // ERROR, Type 'boolean' is not assignable to type 'string | number | symbol'
    [Property in boolean]: any 
}
```

### [映射修饰符](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)

在使用映射类型期间，可以使用两个修饰符，`-`  和 `+` （默认），修饰符能删除只读`readonly`和可选性`?`。

```typescript
type Modifiers<Type> = {
  // 删除 key 的只读性
  -readonly [Property in keyof Type]: Type[Property];
};

type Modifiers<Type> = {
  // 删除 key 的可选性
  [Property in keyof Type]-?: Type[Property];
};

type Info = {
  readonly id: string;
  readonly name: string;
  age?: number;
};

type A = Modifiers<Info>;
type A = {
    id: string;
    name: string;
    age: number
}
```

### [使用 as 重新映射 映射类型的 key](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

能改变 key 的名字。

```typescript
type Getters<Type> = {
    // 正式书写时没有 \。
      // 这里添加 \ 是因为不添加这个 md 的样式就有问题
    [Property in keyof Type as `get\${Capitalize<string & Property>}`]: () => Type[Property]
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters<Person>;
// 得到类型 => 
type LazyPerson = {
    getName: () => string;
    getAge: () => number;
    getLocation: () => string;
}
```

## [条件类型](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

### 语法

`SomeType extends OtherType ? TrueType : FalseType;`

如果` SomeType` 可以分配给 `OtherType`，则应用类型 `TrueType`，反之应用类型 `FalseType`

### 示例

```tsx
type ConditionType<Type> = Type extends string ? string : number;

let data: ConditionType<number>;
data = '1'; // error - Type 'string' is not assignable to type 'number'
data = 1; // correct
```
